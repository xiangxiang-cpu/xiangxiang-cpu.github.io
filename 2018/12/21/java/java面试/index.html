<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|[object Object]:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":350,"display":"always","padding":18,"offset":40,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
  <meta name="description" content="类加载 一个Java文件从编码完成到最终执行，一般主要包括两个过程  javac：将java源文件编译为.class字节码文件（javac是把你写的java代码编译成计算机能识别的内部代码） java：把编译声称的.class文件交给Java虚拟机(JVM)执行（JVM初始化、加载.class、执行main()）  而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试">
<meta property="og:url" content="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="翔翔の据点">
<meta property="og:description" content="类加载 一个Java文件从编码完成到最终执行，一般主要包括两个过程  javac：将java源文件编译为.class字节码文件（javac是把你写的java代码编译成计算机能识别的内部代码） java：把编译声称的.class文件交给Java虚拟机(JVM)执行（JVM初始化、加载.class、执行main()）  而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/eaf81a4c510fd9f9a14099a4c13f2f2e2934a444.jpeg">
<meta property="og:image" content="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/37d12f2eb9389b50828b0dfd61271ed9e6116ec5.jpeg">
<meta property="og:image" content="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403092524169">
<meta property="og:image" content="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403095015188">
<meta property="og:image" content="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403101055691">
<meta property="article:published_time" content="2018-12-20T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-28T08:04:41.046Z">
<meta property="article:author" content="zhx">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/eaf81a4c510fd9f9a14099a4c13f2f2e2934a444.jpeg">

<link rel="canonical" href="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java面试 | 翔翔の据点</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!--     <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js"></script>
  <script type="text/javascript">
  $(document).ready(function() {
    $('.inactive').click(function(){
      if($(this).siblings('ul').css('display')=='none'){
        $(this).addClass('inactives');
        $(this).siblings('ul').slideDown(100).children('li');
      }else{
        $(this).removeClass('inactives');
        $(this).siblings('ul').slideUp(100);
      }
    })
  });
  </script> -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">翔翔の据点</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Arrogance is the only obstacle to survival. Not weakness or ignorance.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">35</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/xiangxiang-cpu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/yeah.jpg">
      <meta itemprop="name" content="zhx">
      <meta itemprop="description" content="中国南京 东南大学 软件学院">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翔翔の据点">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java面试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-21 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-21T00:00:00+08:00">2018-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-28 16:04:41" itemprop="dateModified" datetime="2022-03-28T16:04:41+08:00">2022-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="类加载">类加载</h2>
<p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<ul>
<li>javac：将java源文件编译为.class字节码文件（javac是把你写的java代码编译成计算机能识别的内部代码）</li>
<li>java：把编译声称的.class文件交给Java虚拟机(JVM)执行（JVM初始化、加载.class、执行main()）</li>
</ul>
<p>而我们所说的类加载过程即是指<strong>JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程</strong>。</p>
<p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p>
<p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个<strong>需要运行的类时才会加载，且只加载一次</strong>。</p>
<a id="more"></a>
<h3 id="过程">过程</h3>
<p>类的生命周期：加载前还有编译</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/eaf81a4c510fd9f9a14099a4c13f2f2e2934a444.jpeg" alt="img"></p>
<p><strong>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段</strong>。</p>
<p>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。</p>
<p>另外注意这里的几个阶段是按顺序<strong>开始</strong>，而不是按顺序<strong>进行</strong>或<strong>完成</strong>，因为这些阶段通常都是<strong>互相交叉地混合进行</strong>的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h4 id="加载">加载</h4>
<p>简单来说，加载指的是把<strong>class字节码文件</strong>从各个来源通过类加载器<strong>装载入内存中</strong>。</p>
<p>这里有两个重点：</p>
<p><strong>字节码来源</strong>。</p>
<p>（1）本地磁盘（本地路径下编译生成的.class文件</p>
<p>（2）网上加载.class文件（Applet）</p>
<p>（3）从数据库中</p>
<p>（4）压缩文件中的.class文件（ZAR，jar等）</p>
<p>（5）从其他文件生成的（JSP应用）</p>
<p>（6）从远程网络，以及动态代理实时编译</p>
<p><strong>类加载器</strong>。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。</p>
<p>注：为什么会有自定义类加载器？</p>
<p>一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。</p>
<p>另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。</p>
<h4 id="验证">验证</h4>
<p>主要是为了保证<strong>加载进来的字节流符合虚拟机规范</strong>，不会造成安全错误。</p>
<ol>
<li>
<p>对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
</li>
<li>
<p>对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
</li>
<li>
<p>对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。</p>
</li>
<li>
<p>对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
</li>
</ol>
<h4 id="准备">准备</h4>
<p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。</p>
<p>特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的<strong>默认初始值</strong>。</p>
<p>比如8种基本类型的初值，默认为0；</p>
<p>引用类型的初值则为null；</p>
<p>常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456</p>
<h4 id="解析">解析</h4>
<p>将常量池内的符号引用替换为直接引用的过程。</p>
<p>两个重点：</p>
<p>符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</p>
<p>直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量</p>
<p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
<p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h4 id="初始化">初始化</h4>
<p>这个阶段主要是对类变量初始化，是执行类构造器的过程。</p>
<p>换句话说，只对static修饰的变量或语句进行初始化。</p>
<p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
<p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<h4 id="总结">总结</h4>
<p>类加载过程只是一个类生命周期的一部分，在其前，有<strong>编译</strong>的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的<strong>类使用</strong>过程，当使用完成之后，还会在方法区垃圾<strong>回收</strong>的过程中进行卸载。如果想要了解Java类整个生命周期的话，可以自行上网查阅相关资料，这里不再多做赘述。</p>
<h2 id="命令行参数args">命令行参数args</h2>
<p>String args[ ]或者String[ ] args表示给主方法传一个字符串数组。而args是一个字符串数组的变量名，不是关键字，是arguments的缩写，只是一个默认名，一般都习惯性照写，也可以用别的名字。</p>
<p>String[] args是main函数的形式参数，可以用来获取命令行用户输入进去的参数。如果你是java的初学者，编写一些简单的小程序是用不到它的，但是你在写程序的时候不管用的到用不到，声明main函数的时候一定要在括号里写上它，否则会报错。</p>
<p>命令行传参方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java helloworld arg0 arg1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面两个字符串随便写什么，它们作为实参传入main函数，arg0传入args[0]，arg1传入args[1]。</span></span><br></pre></td></tr></table></figure>
<p>这和在main函数里调用其他函数并且向被调用函数传递参数是一样的道理，只不过传给main函数罢了。</p>
<h2 id="JVM">JVM</h2>
<p>当我们调用 Java 命令运行<strong>某个 Java 程序</strong>时，该命令将会启动<strong>一条 Java 虚拟机进程</strong>，不管该 Java 程序有多么复杂，该程序启动了多少个线程，它们都处于该 Java 虚拟机进程里。同一个 JVM 的所有线程、所有变量都处于同一个进程里，它们都使用该 JVM 进程的内存区。</p>
<p>当系统出现以下几种情况时， JVM 进程将被终止：</p>
<ul>
<li>程序运行到最后正常接收；</li>
<li>程序运行到使用System.exit（）或Runtime.getRuntime（）.exit（）代码结束程序；</li>
<li>程序运行中遇到未捕获的异常或错误结束；</li>
<li>程序所在平台强制结束了JVM进程；</li>
</ul>
<h2 id="类加载机制">类加载机制</h2>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/37d12f2eb9389b50828b0dfd61271ed9e6116ec5.jpeg" alt="img"></p>
<p>java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。</p>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p>
<h2 id="面向对象的特征">面向对象的特征</h2>
<p><strong>抽象</strong>：</p>
<p>抽象是将一类对象的共同特征总结出来<strong>构造类的过程</strong>，包括<strong>数据抽象</strong>和<strong>行为抽象</strong>两方面。抽象只关注对象有哪些<strong>属性和行为</strong>，并不关注这些行为的细节是什么。</p>
<ol>
<li>研究事物的静态特征(属性)</li>
<li>研究事物的动态特征(方法/函数)</li>
<li>形成结果(类,class)</li>
<li>类和对象相互转变(new)</li>
</ol>
<p>举例说明：</p>
<p>学生有姓名，有年龄，有身份证号，这些都是静态特征，即属性</p>
<p>学生会吃饭，会睡觉，会学习，这些都是动态特征，即行为</p>
<p><strong>封装</strong>：</p>
<p>通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。</p>
<p>面向对象的本质就是将现实世界描绘成一系列<strong>完全自治、封闭的对象</strong>。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。封装给对象提供了隐藏内部特性和行为的能力，对象提供一些能被其它对象访问的方法来改变它内部的数据。</p>
<p><strong>继承</strong>：</p>
<p>继承是从已有类得到继承信息创建新类的过程。</p>
<p>提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。<strong>继承让变化中的软件系统有了一定的延续性</strong>，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</p>
<p><strong>多态性</strong>：</p>
<p>多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为<strong>编译时</strong>的多态性和<strong>运行时</strong>的多态性。如果将对象的方法视为对象向外界提供的服务，那么<strong>运行时</strong>的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p>
<p><strong>注意：运行时的多态是面向对象最精髓的东西，要实现多态需要的三个必要条件？</strong></p>
<ol>
<li>要有类的继承</li>
<li>要有方法的重写（子类继承父类并重写父类中已有的或抽象的方法）</li>
<li>对象造型（父类的引用指向子类的对象，这样同样的引用调用同样的方法会根据子类对象的不同而表现不同的行为）</li>
</ol>
<h4 id="构造方法">构造方法</h4>
<h2 id="类成员访问修饰符">类成员访问修饰符</h2>
<p>类的成员（方法、变量、<strong>包括内部类</strong>）的修饰符可以是以下四种：</p>
<ul>
<li>private则只有在当前类能访问。</li>
<li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。</li>
<li>protected 只能被本类、同一个包中的类访问；如果在其他包中被访问，则必须是该成员所属类的子类。</li>
<li>public则是在所有地方都能访问。</li>
</ul>
<p>外部类的修饰符只能是public或默认</p>
<h2 id="packge、import">packge、import</h2>
<p>1）代码中涉及的指令package cn.edu360;它的执行过程是：</p>
<p>在该源文件所在的目录（out/production）下，先创建一个cn文件夹，再在cn文件夹里创建一个edu360文件夹，然后将源文件编译后的class文件放入其中；</p>
<p>2）代码中涉及的另一条指令import cn.edu360.Farther;这个导包指令的执行过程是：</p>
<p>在该源文件所在目录中搜寻有没有一个叫cn文件夹的，再搜寻cn文件夹中是不是有edu360这个文件夹，进而再搜寻edu360文件夹中是否有Farther这个类，有的话才进行导入，否则会报错。</p>
<p>然后才想通了这句话：所说的同一个包或者不同包，指的是编译后的class文件是否在同一个文件夹里。</p>
<p>原文链接：<a href="https://blog.csdn.net/u013771764/article/details/81226908" target="_blank" rel="noopener">https://blog.csdn.net/u013771764/article/details/81226908</a></p>
<p>在某一个包中的类，无法调用</p>
<p><strong>java工程要建立良好的包结构，尽量不要在 package 根目录建类</strong></p>
<h2 id="原码补码反码移码">原码补码反码移码</h2>
<p><a href="https://blog.csdn.net/zl10086111/article/details/80907428" target="_blank" rel="noopener">https://blog.csdn.net/zl10086111/article/details/80907428</a></p>
<p><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">https://www.zhihu.com/question/20159860</a></p>
<h4 id="机器数">机器数</h4>
<p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1</p>
<p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p>
<p>那么，这里的 00000011 和 10000011 就是机器数。</p>
<h4 id="真数（真值）">真数（真值）</h4>
<p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。</p>
<p>例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。</p>
<p>所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>
<p>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p>
<h4 id="原码">原码</h4>
<p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式。</p>
<h4 id="反码">反码</h4>
<p>反码的表示方法是:</p>
<ul>
<li>正数的反码是其本身</li>
<li><strong>负数</strong>的反码是在其原码的基础上，符号位不变，其余各个位取反</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算</p>
<h4 id="补码">补码</h4>
<p>补码的表示方法是:</p>
<ul>
<li>正数的补码就是其本身</li>
<li><strong>负数</strong>的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。 (即在反码的基础上+1)</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码在计算其数值</p>
<h4 id="为什么要使用反码和补码">为什么要使用反码和补码</h4>
<p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
</blockquote>
<p>所以不需要过多解释. 但是对于负数:</p>
<blockquote>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>
<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别&quot;符号位&quot;显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了<strong>将符号位也参与运算</strong>的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>
<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403092524169" alt="img"></p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>如果用原码表示, 让符号位也参与计算, 显然对于某些加减来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p>
<p>从上面的原码表中可以看见<strong>左边每增加一个二进制单位对应的真数是递减的</strong>，而右边每增加一个二进制单位对应的真数是递增的，所以对于原码来说，能满足正数的加法，但无法满足负数的加法</p>
<p>为了满足负数对加法的需求，就必须让负数与他对应的二进制码是同步递增或者同步递减</p>
<p>于是就通过符号位不变，其余位取反来<strong>满足这个同步递增或者递减的要求</strong>，由于正数本来就满足它本身的加法，所以不需要做任何改变。这就是反码的定义由来。</p>
<p>为了解决原码做减法的问题, 出现了反码:</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403095015188" alt="img"></p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
</blockquote>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在&quot;0&quot;这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是<strong>0带符号是没有任何意义</strong>的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.这导致在实际计算中每当跨过0（溢出）一次，就有一个单位的误差。</p>
<p>要解决这个问题就必须<strong>让反码中的[1111_1111]和[0000_0000]合并</strong></p>
<p>由于[1111_1111]+[0000_0001]=[0000_0000]，所以在负数反码的基础上+1就可以解决反码中跨0的误差问题，同时不会对负数与它对应的二进制反码的同步递增产生影响，所以在反码的基础上+1就完美的解决了符号参与预算的问题，这就是补码为什么是在负数反码的基础上+1的由来。</p>
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403101055691" alt="img"></p>
<blockquote>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
</blockquote>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以**-128并没有原码和反码表示**.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p>
<p>使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理</p>
<p>==反码运算结果是反码，补码运算结果是补码==</p>
<h4 id="反码和补码的原理">反码和补码的原理</h4>
<p>（深入补码原码の原理，而不是表面上的求法）</p>
<p><strong>1. 原码</strong></p>
<p>所谓原码就是机器数，是==加了一位符号位的二进制数==，正数符号位为0，负数符号位为1，计算机中存储、处理、运算的数据通常是8位、16位、32位或64位的，这里以最简单的8位为例讲解。注意符号位是包含在8位中的其中1位，故可直观读出的数只有7位（只有后7位数可以按权展开）。有心人可能注意到原码是有缺陷的，它<strong>只能表示255种状态</strong>，因为0000_0000（＋0）和1000_0000（－0）其实是一个数，因此原码的表示范围成了－127到＋127，这个问题需要神奇的补码来解决，因为在补码中1000_0000被用来表示－128。</p>
<p><strong>2. 反码</strong></p>
<p>所谓反码，英语里又叫==ones’ complement（对1求补）==，这里的1，本质上是一个有限位计数系统里所能表示出的<strong>最大值</strong>，在8位二进制里就是1111_1111，在1位十进制里就是9，在3位十六进制里就是FFF（再大就要进位了）。</p>
<ul>
<li>反码原理：用最大数减去一个数就能得到它的反。很容易看出在二进制里1111_1111减去任何数结果都是把这个数按位取反，0变1，1变零，所以才称之为反码。</li>
<li>用原码求反码的方法：正数不变，负数保留符号位1不变，剩下位按位取反。</li>
</ul>
<p><strong>3. 补码</strong></p>
<p>所谓补码，英语里又叫==two’s complement（对2求补）==，这个2指的是计数系统的<strong>容量（模）</strong>，就是计数系统所能表示的状态数。对1位二进制数来说只有0和1两种状态，所以模是10也就是十进制的2，对7位二进制数来说就是1000_0000，这个模是不可能取到的，因为位数多一位。</p>
<ul>
<li>补码原理：用模减去一个数（无符号部分）就能得到这个数的补。比如1000_0000－101_0010=010_1110</li>
<li>用原码求补码的方法：事实上因为1000_0000 = 111_1111 + 1 = (111_1111－101_0010) + 1，所以又可以表述为<strong>先求反再加1</strong>。总结求补码的方法就是正数依旧不变，负数保留符号位不变，先求反码再加上1。</li>
</ul>
<p><strong>4. 如何运算？？？</strong></p>
<p>记住了怎么求补码，接下来讲讲运算。通过原码的符号位和数值，我们能迅速指出它代表的数，判断其正负并进行四则运算，相比而言反码和补码对于人则显得过于晦涩。如果说原码是给人看的数字语言，那么补码就是计算机的数字语言。<strong>计算机不需要知道什么是正负、大小</strong>，这些判断对它而言过于复杂。事实上它<strong>存储、处理、传输的数都只有补码一种形式</strong>，人所做的加减乘除，在计算机里只通过<strong>相加和移位</strong>就能解决，这都来自于补码系统的内在自洽和巧夺天工的神奇魔力，也是后文要阐述的重点。</p>
<p>对加法和减法，按上文的方法求得补码之后，直接相加就可以了，但相加的时候<strong>符号位一定要一起参与运算</strong>，有时候，两符号位相加或者接受来自低位的进位会发生溢出，就扔掉溢出的一位（稍后会解释为什么），由新的符号位决定结果的正负，如果是0表示正数，结果就是原码，如果是1表示负数，结果还要再求补数得到原码。</p>
<h4 id="模">模</h4>
<p>在介绍补码概念之前，先介绍一下“<a href="https://baike.baidu.com/item/%E6%A8%A1/13332718" target="_blank" rel="noopener">模</a>”的概念：“模”是指一个计量系统的计数范围，如过去计量粮食用的斗、时钟等。计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模”。如：时钟的计量范围是0~11，模=12。表示n位的计算机计量范围是0 ~ 2^n - 1，模= 2^n。“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。<strong>任何有模的计量器，均可化减法为加法运算</strong>。</p>
<p>假设当前时针指向8点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨2小时，即8-2=6；另一种是顺拨10小时，8+10=12+6=6，即8-2=8+10=8+(12-2)(mod 12)．在12为模的系统里，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。</p>
<p>若用一般公式可表示为：a-b=a-b+mod=a+(mod-b)。</p>
<p>对“模”而言，2和10互为补数。实际上，以12为模的系统中，11和1，8和4，9和3，7和5，6和6都有这个特性，共同的特点是两者相加等于模。</p>
<p>对于计算机，其概念和方法完全一样。计算机的逻辑运算单元中，只有加法运算器，用来对两个数进行相加，并没有减法器的电路。n位计算机，设n=8，所能表示的最大数是11111111，若再加1成100000000(9位)，但因只有8位，最高位1自然丢失。又回到了 00000000，所以8位系统的模为2^8。在这样的系统中<strong>减法问题也可以化成加法问题</strong>，只需把减数用相应的补数表示就可以了。把补数用到计算机对数的处理上，就是补码。</p>
<h2 id="数据类型">数据类型</h2>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>boolean</th>
<th>byte</th>
<th>char</th>
<th>short</th>
<th>Int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>void</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制位数</td>
<td>1</td>
<td>8</td>
<td>16</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
<td>–</td>
</tr>
<tr>
<td>封装器类</td>
<td>Boolean</td>
<td>Byte</td>
<td>Character</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
<td>Void</td>
</tr>
</tbody>
</table>
<p>整数默认都是int，小数默认都是float</p>
<p>可以在数值前用()进行显示类型转换（可能会有精度损失），或者加后缀来说明类型（不是转换）</p>
<p>整数的进制前缀、类型后缀可以共存</p>
<ul>
<li><strong>整数</strong>前面可以有0，0x开头，表示八进制，16进制</li>
<li>后缀L，表示long，不能作为小数的后缀</li>
<li>后缀F，表示float，后缀D，表示double，可以作为小数、整数后缀</li>
</ul>
<h3 id="大小、取值范围、精度">大小、取值范围、精度</h3>
<p>对于数值类型的基本类型的<strong>大小、取值范围</strong>，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p>
<ul>
<li>
<p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p>
</li>
<li>
<p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p>
</li>
<li>
<p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p>
<p>char本质就是整数，使用Unicode表示字符（0~65536）</p>
</li>
<li>
<p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p>
</li>
</ul>
<h3 id="float和double理解">float和double理解</h3>
<p>float、double两种类型的最小值与Float.MIN_VALUE、Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。</p>
<p>也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值<strong>超出了它们的精度范围</strong>。</p>
<p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的&quot;E+数字&quot;表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×10^3，3.14E-300就是3.14×10^-300=0.00314。</p>
<p>（把小数点移到最前面存储小数）</p>
<ul>
<li>float：1 位符号位，8 位指数，23 位有效尾数</li>
<li>double： 1 位符号位，11 位指数，52 位有效尾数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二进制浮点数（整数部分和小数部分都是二进制表示）</span><br><span class="line">1010100010 &#x3D; 101010001.0*2</span><br><span class="line">&#x3D; 10101000.10*2^10(2次方) &#x3D; 1010100.010*2^11(3次方) &#x3D; .1010100010*2^1010(10次方)</span><br><span class="line"></span><br><span class="line">尾数：.1010100010  指数：1010  基数：2</span><br></pre></td></tr></table></figure>
<p>范围？？？</p>
<p>float和double的范围是由指数的位数来决定的。<br>
float的指数位有8位，而double的指数位有11位，分布如下：<br>
float：<br>
1bit（符号位） 8bits（指数位） 23bits（尾数位）<br>
double：<br>
1bit（符号位） 11bits（指数位） 52bits（尾数位）<br>
于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。<br>
其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。<br>
float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。</p>
<p>精度？？？</p>
<p>float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。<br>
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；<br>
double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。</p>
<h4 id="浮点数的比较问题">浮点数的比较问题</h4>
<h3 id="简单类型及其封装">简单类型及其封装</h3>
<p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<p>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。简单类型主要分为3类：布尔、字符、数值</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>boolean</th>
<th>byte</th>
<th>char</th>
<th>short</th>
<th>Int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>void</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制位数</td>
<td>1</td>
<td>8</td>
<td>16</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
<td>–</td>
</tr>
<tr>
<td>封装器类</td>
<td>Boolean</td>
<td>Byte</td>
<td>Character</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
<td>Void</td>
</tr>
</tbody>
</table>
<p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机可以完成<strong>基本类型和它们对应包装类之间的自动转换</strong>。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，<strong>所有基本类型（包括void）的包装类都使用了final修饰</strong>，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p>
<ul>
<li>基本类型的优势：数据存储相对简单，运算效率比较高</li>
<li>包装类的优势：有的容易，比如<strong>集合的元素必须是对象类型</strong>，满足了java一切皆是对象的思想</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;                  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.out.println(a == b);     <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == c);     <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;        </span><br><span class="line">        System.out.println(f1 == f2);</span><br><span class="line">        System.out.println(f3 == f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntegerCache是Integer的内部类</p>
<p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1 == f2的结果是true，而f3 == f4的结果是false。</p>
<h3 id="类型转换">类型转换</h3>
<h4 id="简单类型-自动转换">简单类型-自动转换</h4>
<p>这些类型由&quot;小&quot;到&quot;大&quot;分别为 (byte，short，char) – int – long – float – double。</p>
<p>这里我们所说的&quot;大&quot;与&quot;小&quot;,并不是指占用字节的多少,而是指表示<strong>值的范围的大小</strong>。</p>
<ol>
<li>具体地讲，当一个较&quot;小&quot;数据与一个较&quot;大&quot;的数据<strong>一起运算时</strong>，系统将自动将&quot;小&quot;数据转换成&quot;大&quot;数据,再进行运算。</li>
<li>而在<strong>方法调用</strong>时,实际参数较&quot;小&quot;,而被调用的方法的形式参数数据又较&quot;大&quot;时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将&quot;小&quot;数据转换成&quot;大&quot;数据,再进行方法的调用。自然,对于多个同名的重载方法,会转换成最&quot;接近&quot;的&quot;大&quot;数据并进行调用？？？</li>
</ol>
<p>①下面的语句可以在Java中直接通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b;</span><br><span class="line"><span class="keyword">int</span> i=b;</span><br><span class="line"><span class="keyword">long</span> l=b;</span><br><span class="line"><span class="keyword">float</span> f=b;</span><br><span class="line"><span class="keyword">double</span> d=b;</span><br></pre></td></tr></table></figure>
<p>②如果低级类型为char型，向高级类型（整型）转换时，会转换为<strong>对应ASCII码值</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">int</span> i=c;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"output:"</span>+i); <span class="comment">// 输出：output:99;</span></span><br></pre></td></tr></table></figure>
<p>③对于byte,short,char三种类型而言，他们是<strong>平级的</strong>，因此不能相互自动转换，可以使用下述的强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> i=<span class="number">99</span> ;</span><br><span class="line"><span class="keyword">char</span> c=(<span class="keyword">char</span>)i;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"output:"</span>+c); <span class="comment">// 输出：output:c;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单类型-强制转换">简单类型-强制转换</h4>
<p>将&quot;大&quot;数据转换为&quot;小&quot;数据时，你可以使用强制类型转换。</p>
<p>即你必须采用下面这种语句格式： int n=(int)3.14159/2;</p>
<p>可以想象，这种转换肯定可能会<strong>导致溢出或精度的下降</strong>。</p>
<h4 id="表达式-数据类型自动提升">表达式-数据类型自动提升</h4>
<p>关于类型的自动提升，注意下面的规则。</p>
<p>①所有的byte,short,char型的值将被提升为int型；</p>
<p>②如果有一个操作数是long型，计算结果是long型；</p>
<p>③如果有一个操作数是float型，计算结果是float型；</p>
<p>④如果有一个操作数是double型，计算结果是double型；</p>
<p>例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b;</span><br><span class="line">b=<span class="number">3</span>;</span><br><span class="line">b=(<span class="keyword">byte</span>)(b*<span class="number">3</span>); <span class="comment">// 必须声明byte。</span></span><br></pre></td></tr></table></figure>
<h4 id="包装类过渡-类型转换">包装类过渡-类型转换</h4>
<p>一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。例如：</p>
<p>①当希望把float型转换为double型时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1=<span class="number">100.00f</span>;</span><br><span class="line">Float F1=<span class="keyword">new</span> Float(f1);</span><br><span class="line"><span class="keyword">double</span> d1=F1.doubleValue(); <span class="comment">// F1.doubleValue()为Float类的返回double值型的方法</span></span><br></pre></td></tr></table></figure>
<p>②当希望把double型转换为int型时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1=<span class="number">100.00</span>;</span><br><span class="line">Double D1=<span class="keyword">new</span> Double(d1);</span><br><span class="line"><span class="keyword">int</span> i1=D1.intValue();</span><br></pre></td></tr></table></figure>
<p>简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。</p>
<p>即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value)</p>
<p>而在各个包装类中，总有<strong>形为××Value()的方法</strong>，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。</p>
<h4 id="字符串与其它类型间的转换">字符串与其它类型间的转换</h4>
<p><strong>其它类型向字符串的转换</strong></p>
<p>①调用类的串转换方法:X.toString();</p>
<p>②自动转换:X+&quot;&quot;;</p>
<p>③使用String的方法:String.valueOf(X);</p>
<p><strong>字符串作为值,向其它类型的转换</strong></p>
<p>①先转换成相应的封装器实例,再调用对应的方法转换成其它类型</p>
<p>例如，字符中&quot;32.1&quot;转换double型的值的格式为:new Float(“32.1”).doubleValue()</p>
<p>也可以用:Double.valueOf(“32.1”).doubleValue()</p>
<p>②静态parseXXX方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">byte</span> b = Byte.parseByte( s );</span><br><span class="line"><span class="keyword">short</span> t = Short.parseShort( s );</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt( s );</span><br><span class="line"><span class="keyword">long</span> l = Long.parseLong( s );</span><br><span class="line">Float f = Float.parseFloat( s );</span><br><span class="line">Double d = Double.parseDouble( s );</span><br></pre></td></tr></table></figure>
<p>③Character的getNumericValue(char ch)方法</p>
<h4 id="Date类与其它数据类型的相互转换">Date类与其它数据类型的相互转换</h4>
<p>整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式：</p>
<p>①Date(int year, int month, int date)：以int型表示年、月、日</p>
<p>②Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分</p>
<p>③Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、分、秒</p>
<p>在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。</p>
<p>获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。</p>
<p>而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。</p>
<p>有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法，首先在文件开始引入，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果希望得到YYYYMMDD的格式</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sy1=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMDD"</span>);</span><br><span class="line">String dateFormat=sy1.format(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果希望分开得到年，月，日</span></span><br><span class="line">SimpleDateFormat sy=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy"</span>);</span><br><span class="line">SimpleDateFormat sm=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"MM"</span>);</span><br><span class="line">SimpleDateFormat sd=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd"</span>);</span><br><span class="line">String syear=sy.format(date);</span><br><span class="line">String smon=sm.format(date);</span><br><span class="line">String sday=sd.format(date);</span><br></pre></td></tr></table></figure>
<h4 id="总结-2">总结</h4>
<p>只有boolean不参与数据类型的转换</p>
<p>（1）.自动类型的转换：</p>
<ol>
<li>常数在表数范围内是能够自动类型转换的</li>
<li>数据范围小的能够自动数据类型大的转换（注意特例）int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度</li>
<li><strong>引用类型能够自动转换为父类的</strong></li>
<li>基本类型和它们包装类型是能够互相转换的</li>
<li>不能把对象类型转换成不相关类的对象。</li>
</ol>
<p>（2）强制类型转换：用圆括号括起来目标类型，置于变量前</p>
<p><strong>3、Java中的基本类型有哪些？String 是最基本的数据类型吗？</strong></p>
<ol>
<li>Java中的基本数据类型只有8个：byte（1）、short（2）、int（4）、long（8）、float（4）、double（8）、char（2）、boolean（1 bit）；其余单位都是byte</li>
<li>除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</li>
<li>String不是基本数据类型，它定义的为对象。</li>
</ol>
<p><strong>4、float f=3.4;是否正确？</strong></p>
<p>不正确。==3.4是双精度数==，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失。</p>
<p>因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F。3.4f也可</p>
<p><strong>5、short s1 = 1; s1 = s1 + 1;有错吗？short s1 = 1; s1 += 1;有错吗？</strong></p>
<p>short s1 = 1;</p>
<p>对于short s1 = 1; s1 = s1 + 1；由于==1是int类型==，因此==s1+1运算结果自动提升为int 型==，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1；+=操作符会进行<strong>隐式自动类型转换</strong>，是 <strong>Java 语言规定的运算符</strong>；Java编译器会对它进行特殊处理，因此可以正确编译。因为s1+= 1;相当于s1 = (short)(s1 + 1)</p>
<h2 id="equals、-、hashcode">equals、==、hashcode</h2>
<p>== 任何情况下都是判断两个对象在内存中的首地址是否相同</p>
<p>equals取决于所在的类是否重写了这个方法，如果不重写，则使用Object类的equals方法（用==实现的）</p>
<ul>
<li>String的重写了equals方法，作用和==相同</li>
<li>自定义类可以自行重写</li>
</ul>
<p><strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hashCode，这句话对不对？</strong></p>
<p>不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：（1）如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；（2）如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p>
<p>实现高质量的equals方法的诀窍包括：</p>
<ol>
<li>使用==操作符检查&quot;参数是否为这个对象的引用&quot;；</li>
<li>使用instanceof操作符检查&quot;参数是否为正确的类型&quot;；</li>
<li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li>
<li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li>
<li>重写equals时总是要重写hashCode；</li>
<li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</li>
</ol>
<h2 id="和-的区别">&amp;和&amp;&amp;的区别</h2>
<p>&amp;运算符有两种用法：</p>
<p>(1)按位与；</p>
<p>(2)逻辑与（不短路）</p>
<p>&amp;&amp;运算符是<strong>短路与运算</strong>。</p>
<p><strong>逻辑</strong>与跟<strong>短路</strong>与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。</p>
<p>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h2 id="Math类">Math类</h2>
<p>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</p>
<p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。</p>
<p><strong>四舍五入</strong>的原理是==在参数上加0.5然后进行下取整==。</p>
<h2 id="switch">switch</h2>
<p>可以switch的对象有：</p>
<ol>
<li>Java5以前：char、byte、short、int、以及他们的封装类</li>
<li>Java5：enum</li>
<li>Java7：String</li>
</ol>
<h2 id="有效率进行乘法：移位运算">有效率进行乘法：移位运算</h2>
<p><strong>用最有效率的方法计算2乘以8？</strong></p>
<p>2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）</p>
<h2 id="Java保留字-and-关键字">Java保留字 and 关键字</h2>
<p>Java有没有goto？</p>
<p>goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p>
<h2 id="方法的重载（overload）和重写（overwrite）">方法的重载（overload）和重写（overwrite）</h2>
<p>面试时，问：重载（Overload）和重写（Override）的区别？</p>
<p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<ol>
<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同、参数顺序不同）则视为重载；</li>
<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</li>
</ol>
<p>重载条件：</p>
<ul>
<li>有不同的参数列表（参数类型不同、参数个数不同或者二者都不同、参数顺序不同）</li>
<li>能否重载和返回类型无关，不能根据返回类型进行区分</li>
<li>不能重载的情况：仅仅参数变量名不同 或者 仅仅返回值类型不同</li>
</ul>
<p>重写条件：</p>
<p>在子类中可以使用super关键字调用父类方法</p>
<p><strong>1、重写规则之一：</strong></p>
<p>访问修饰符的限制一定要不小于被重写方法的访问修饰符</p>
<p>（public 、protected  、default  、private 权限依次增加）</p>
<pre><code>比如：Object类有个toString()方法, 开始重写这个方法的时候我们总容易忘记Public修饰符, 出错的原因就是：没有加任何访问修饰符的方法具有包访问权限, Default访问权限小于Public访问权限, 所以编译器出错。
</code></pre>
<p><strong>2、重写规则之二：</strong></p>
<p><strong>参数列表</strong>必须与被重写方法的相同。</p>
<p>区别于重载：重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。</p>
<p><strong>3、重写规则之三：</strong></p>
<p><strong>返回类型</strong>必须与被重写方法的返回类型相同（兼容也不行）。</p>
<p>父类方法A：void catch(){} 子类方法 B：int catch(){} 两者虽然参数相同, 返回类型不同, 所以不是重写。</p>
<p>父类方法A：int catch(){} 子类方法 B：long catch(){} 返回类型虽然兼容父类, 但是不同就是不同, 所以不是重写。</p>
<pre><code>ps1:
如果在没有加注@Override？？？的情况下, 方法名和参数列表完全相同,且满足规则A的情况下, 返回值类型必须完全一致的情况下、才不会出现编译错误（即为该方法为强制重写方法）。
如果以上条件中参数列表不同，且返回值类型不同这样编译并不会出现错误（这个方法为在子类的新方法，且不是重写方法）。

ps2:
当子类的方法重写或实现父类的方法时, 方法的后置条件（即方法的返回值）要比父类更严格。
即：如果重写方法的参数列表和方法名相同,且其他条件满足的情况下,方法的返回值为父类的子类,那么该方法也为重写方法
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Computer <span class="title">sale</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Computer(); &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HP <span class="title">make</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> HP(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBM</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBM <span class="title">sale</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> IBM(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HP</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Computer <span class="title">make</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Computer(); &#125; <span class="comment">// compilation error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、重写规则之四：</strong></p>
<p>重写方法不能抛出新的异常，或者比被重写方法声明的检查异常更广的检查异常。</p>
<p>但是可以抛出更少，更有限或者不抛出异常。</p>
<pre><code>举个简单的例子：父类异常好比父亲偷盗抢掠、那么儿子不能比父亲更坏、要学好、自然异常就要少。虽然举得例子与社会主义核心价值观有冲突、但是比较形象。// 2016/12/10 10:55 bluetata 追記 add
</code></pre>
<p><strong>5、重写规则之五：</strong></p>
<p>如果一个方法不能被继承, 则不能重写它。</p>
<p>比较典型的就是父类的private方法。因为private说明该方法对子类是不可见的, 子类再写一个同名的方法并不是对父类方法进行复写(Override), 而是<strong>重新生成一个新的方法</strong>, 也就不存在多态的问题了。</p>
<p>同理也可以解释final, 因为方法同样是不可覆盖的。</p>
<p><strong>6、重写规则之六：</strong></p>
<p>不能重写被标识为final的方法。</p>
<p>final方法可以被继承, 但是不能被重写, 一个方法如果被final修饰, 那么也就意味着, 这个方法不会被改动</p>
<p>（声明一个final方法的主要目的是<strong>防止方法的内容被修改</strong>）。</p>
<p><strong>7、重写规则之七：</strong></p>
<p>静态方法不能被重写。</p>
<p>《JAVA编程思想》中多次的提到：方法是静态的、他的行为就不具有多态性。</p>
<p>静态方法是与类、而非单个对象相关联的。</p>
<p>父类的普通方法可以被继承和重写，不多作解释，如果子类继承父类，而且子类没有重写父类的方法，但是子类会有从父类继承过来的方法。静态的方法可以被继承，但是不能重写。如果父类中有一个静态的方法，子类也有一个与其方法名，参数类型，参数个数都一样的方法，并且也有static关键字修饰，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。《JAVA编程思想》：只有普通的方法调用可以是多态的，静态方法是与类而不是与某个对象相关联。</p>
<pre><code>// 2016/11/22 16:45 bluetata 追記 add Start
</code></pre>
<h4 id="overwrite注解">@overwrite注解</h4>
<p>Java 中的覆盖@Override注解 写与不写的一点点理解</p>
<p>一般来说，写与不写没什么区别，JVM可以自识别</p>
<p><strong>写的情况下</strong>：即说明子类要覆盖基类的方法，基类必须存在方法（控制类型public,protected，返回值，参数列表类型）与子类方法完成一致的方法，否则会报错（找不到被Override的方法）。</p>
<p><strong>不写的情况下</strong>：当基类存在与子类各种条件都符合的方法是即实现覆盖； 如果条件不符合时，则是当成新定义的方法使用。</p>
<p>所以如果想覆盖基类方法时，最好还是写上@Override注解，这样有利于编译器帮助检查错误</p>
<p>发生在父类和子类之间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写equals方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">      		<span class="comment">// instanceof 已经处理了obj = null的情况</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Student stuObj = (Student) obj;</span><br><span class="line">	<span class="comment">// 地址相等，直接equal</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == stuObj) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果两个对象姓名、年龄、性别相等，我们认为两个对象相等</span></span><br><span class="line">	<span class="keyword">if</span> (stuObj.name.equals(<span class="keyword">this</span>.name) &amp;&amp; stuObj.sex.equals(<span class="keyword">this</span>.sex) &amp;&amp; stuObj.age.equals(<span class="keyword">this</span>.age)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法-2">构造方法</h2>
<p>不含返回值，概念不同于void，返回值的类型就是该类本身？</p>
<p>自定义构造函数override默认构造函数</p>
<p>因为构造器不能被继承，所以不能被重写？？？</p>
<h3 id="从一个构造方法调用另一个（private）构造方法">从一个构造方法调用另一个（private）构造方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    sout;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">private</span>) myClass(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    m_d = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Static">Static</h2>
<h3 id="static-method-field">static method/field</h3>
<ul>
<li>field/method未用static修饰，则称为<strong>实例成员</strong></li>
<li>static方法只能访问static方法或变量</li>
<li>静态<strong>变量</strong>（方法）的<strong>调用</strong>：类名.静态变量名（方法名）</li>
<li>static方法也可以用对象来调用</li>
<li>！static方法中<strong>不能有this和super</strong></li>
</ul>
<h4 id="Java虚拟机和main方法？P109">Java虚拟机和main方法？P109</h4>
<p>JVM需要在类外调用main方法，必须是public</p>
<p>又JVM运行时系统在开始执行一个程序前，并没有创建main所在类的对象，只能通过类名调用main()，必须是static</p>
<h3 id="static-初始化器（块）">static 初始化器（块）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对static field 进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="static初始化器和构造方法的差别">static初始化器和构造方法的差别</h4>
<ol>
<li>
<p>静态初始化器是对类本身进行初始化，构造方法是对每个新创建的对象初始化</p>
</li>
<li>
<p>前者不能由程序来调用，他是在所属类被加载入内存时由系统调用执行的（且仅在此执行一次）</p>
</li>
<li>
<p>前者不是方法，没有返回值等</p>
<p>ps：类是在第一次被使用的时候才被装载，不是在程序启动时就装载所有可能用到的类</p>
<p>​	如果有多个static初始化器，则顺序执行</p>
</li>
</ol>
<h4 id="执行顺序">执行顺序</h4>
<p><a href="https://blog.csdn.net/caomiao2006/article/details/51533382" target="_blank" rel="noopener">https://blog.csdn.net/caomiao2006/article/details/51533382</a></p>
<p>它们的初始化顺序以此是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器</p>
<h5 id="变量和初始化块之间的顺序">变量和初始化块之间的顺序</h5>
<p>静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。</p>
<h5 id="无继承：">无继承：</h5>
<p>静态变量<br>
静态初始化块<br>
变量<br>
初始化块<br>
构造器</p>
<h5 id="有继承：">有继承：</h5>
<p>父类–静态变量<br>
父类–静态初始化块<br>
<strong>子类–静态变量</strong><br>
<strong>子类–静态初始化块</strong><br>
父类–变量<br>
父类–初始化块<br>
父类–构造器<br>
子类–变量<br>
子类–初始化块<br>
子类–构造器</p>
<p>并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。</p>
<h2 id="对象的应用">对象的应用</h2>
<ul>
<li>
<p>对象也可以称为类类型的变量，实际为引用型</p>
</li>
<li>
<p>引用型的变量实际上保存的是对象在内存中的首地址（也称为对象的句柄）</p>
</li>
<li>
<p>引用变量可作为参数传递、作为方法的返回值</p>
</li>
</ul>
<h3 id="类类型的数组">类类型的数组</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person[] per;</span><br><span class="line">per = <span class="keyword">new</span> Person[<span class="number">3</span>];</span><br><span class="line">per[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">25</span>);</span><br><span class="line">per[<span class="number">1</span>] = <span class="keyword">new</span> Person(<span class="string">"B"</span>,<span class="number">25</span>);</span><br><span class="line">per[<span class="number">2</span>] = <span class="keyword">new</span> Person(<span class="string">"C"</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>ps数组类型的使用</p>
<p><a href="http://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-array.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明数组变量</span></span><br><span class="line"><span class="comment">// 首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</span></span><br><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line"><span class="comment">// Java语言使用new操作符来创建数组，语法如下：</span></span><br><span class="line"></span><br><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"><span class="comment">// 上面的语法语句做了两件事：</span></span><br><span class="line"><span class="comment">// 一、使用 dataType[arraySize] 创建了一个数组。</span></span><br><span class="line"><span class="comment">// 二、把新创建的数组的引用赋值给变量 arrayRefVar。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组变量的声明，和创建数组可以用一条语句完成，如下所示：</span></span><br><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，你还可以使用如下的方式创建数组。</span></span><br><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure>
<p>pps：foreach</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ppps：数组作为参数或者返回值，详见类与对象笔记</p>
<h2 id="hash系列">hash系列</h2>
<p>hashmap、hashset</p>
<h2 id="跳到特定的某一层循环">跳到特定的某一层循环</h2>
<p>直接在for之间加标签即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j)</span><br><span class="line">            <span class="keyword">break</span> A; <span class="comment">// 直接跳出最外层循环</span></span><br><span class="line">    &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
    <div style="text-align:center;color: #ccc;font-size:14px;">
-------------------------- the end~ &nbsp;&nbsp;
<i class="fa fa-heart-o" aria-hidden="true"></i>
 thanks for your reading~ --------------------------
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>zhx
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/" title="java面试">http://yoursite.com/2018/12/21/Java/java面试/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/21/Java/%E7%BB%A7%E6%89%BF%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/" rel="prev" title="Java继承、抽象类和接口">
      <i class="fa fa-chevron-left"></i> Java继承、抽象类和接口
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="Java多线程">
      Java多线程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>
  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载"><span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程"><span class="nav-text">过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载"><span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证"><span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备"><span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析"><span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令行参数args"><span class="nav-text">命令行参数args</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载机制"><span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的特征"><span class="nav-text">面向对象的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-text">构造方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类成员访问修饰符"><span class="nav-text">类成员访问修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#packge、import"><span class="nav-text">packge、import</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原码补码反码移码"><span class="nav-text">原码补码反码移码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#机器数"><span class="nav-text">机器数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#真数（真值）"><span class="nav-text">真数（真值）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原码"><span class="nav-text">原码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反码"><span class="nav-text">反码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补码"><span class="nav-text">补码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要使用反码和补码"><span class="nav-text">为什么要使用反码和补码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反码和补码的原理"><span class="nav-text">反码和补码的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模"><span class="nav-text">模</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#大小、取值范围、精度"><span class="nav-text">大小、取值范围、精度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#float和double理解"><span class="nav-text">float和double理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#浮点数的比较问题"><span class="nav-text">浮点数的比较问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单类型及其封装"><span class="nav-text">简单类型及其封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单类型-自动转换"><span class="nav-text">简单类型-自动转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单类型-强制转换"><span class="nav-text">简单类型-强制转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表达式-数据类型自动提升"><span class="nav-text">表达式-数据类型自动提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包装类过渡-类型转换"><span class="nav-text">包装类过渡-类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串与其它类型间的转换"><span class="nav-text">字符串与其它类型间的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date类与其它数据类型的相互转换"><span class="nav-text">Date类与其它数据类型的相互转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-2"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals、-、hashcode"><span class="nav-text">equals、&#x3D;&#x3D;、hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和-的区别"><span class="nav-text">&amp;和&amp;&amp;的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math类"><span class="nav-text">Math类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-text">switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有效率进行乘法：移位运算"><span class="nav-text">有效率进行乘法：移位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java保留字-and-关键字"><span class="nav-text">Java保留字 and 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法的重载（overload）和重写（overwrite）"><span class="nav-text">方法的重载（overload）和重写（overwrite）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#overwrite注解"><span class="nav-text">@overwrite注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法-2"><span class="nav-text">构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从一个构造方法调用另一个（private）构造方法"><span class="nav-text">从一个构造方法调用另一个（private）构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static"><span class="nav-text">Static</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static-method-field"><span class="nav-text">static method&#x2F;field</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java虚拟机和main方法？P109"><span class="nav-text">Java虚拟机和main方法？P109</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-初始化器（块）"><span class="nav-text">static 初始化器（块）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static初始化器和构造方法的差别"><span class="nav-text">static初始化器和构造方法的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行顺序"><span class="nav-text">执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#变量和初始化块之间的顺序"><span class="nav-text">变量和初始化块之间的顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无继承："><span class="nav-text">无继承：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有继承："><span class="nav-text">有继承：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的应用"><span class="nav-text">对象的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类类型的数组"><span class="nav-text">类类型的数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash系列"><span class="nav-text">hash系列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳到特定的某一层循环"><span class="nav-text">跳到特定的某一层循环</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhx"
      src="/images/avatar/yeah.jpg">
  <p class="site-author-name" itemprop="name">zhx</p>
  <div class="site-description" itemprop="description">中国南京 东南大学 软件学院</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xiangxiang-cpu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiangxiang-cpu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:harrison_zhanghx@foxmail.com" title="E-Mail → mailto:harrison_zhanghx@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/114514" title="QQ 114514 → 114514"><i class="fa fa-qq fa-fw"></i>QQ 114514</a>
      </span>
      <span class="links-of-author-item">
        <a href="/114514" title="weixin 114514 → 114514"><i class="fa fa-weixin fa-fw"></i>weixin 114514</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://creeper121386.github.io/" title="https:&#x2F;&#x2F;creeper121386.github.io" rel="noopener" target="_blank">WHY's blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-music"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhx</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  


  <!-- 鼠标效果 -->
  


  <!-- 动态背景 -->
  
</body>
</html>

