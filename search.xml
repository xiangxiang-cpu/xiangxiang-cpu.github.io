<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo美化</title>
    <url>/2019/01/25/Blog/hexo%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>测试quote功能</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Elegant in code, simple in core</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="1-官方文档">-1. 官方文档</h2>
<p>官方文档http://theme-next.iissnan.com/getting-started.html</p>
<a id="more"></a>
<p><a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">https://theme-next.org/docs/getting-started/</a></p>
<p>2.4 使用pjax，可加速？</p>
<p><a href="https://theme-next.org/docs/theme-settings/" target="_blank" rel="noopener">https://theme-next.org/docs/theme-settings/</a></p>
<p>内容概要：</p>
<ol>
<li>控制台显示最新版本发布</li>
<li>cache开关</li>
<li>hexo g后是否去除多余文件</li>
<li>产权？？？</li>
<li>文本对齐？？？</li>
<li>窄的设备上减少padding</li>
<li>用户logo（不是头像</li>
<li>代码块风格</li>
<li>阅读进度（屏幕顶部</li>
<li>书签（保存阅读进度</li>
<li>右上角github</li>
<li>字体设置</li>
</ol>
<h2 id="0-文件结构">0. 文件结构</h2>
<ol>
<li>站点配置文件 - <code>hexo\themes\next\_config.yml</code></li>
<li>主题配置文件 - <code>hexo\themes\next\_config.yml</code></li>
<li>自定义配置文件 - 主题配置文件中，custom_file_path字段规定</li>
</ol>
<h2 id="选中颜色修改">选中颜色修改</h2>
<p>内容选中默认是蓝色的，偶然看到推酷网站上面是绿色的，很喜欢就打算把自己博客也改改。<br>
打开<code>hexo\themes\next\source\css\_schemes\Gemini</code>下面的<code>index.styl</code>在最下面添加如下代码，需要配置选中背景色和字体颜色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span></span><br><span class="line">    <span class="selector-tag">background</span> <span class="selector-id">#33a183</span></span><br><span class="line">    <span class="selector-tag">color</span> <span class="selector-id">#fff</span></span><br><span class="line"><span class="selector-pseudo">::-moz-selection</span></span><br><span class="line">    <span class="selector-tag">background</span> <span class="selector-id">#33a183</span></span><br><span class="line">    <span class="selector-tag">color</span> <span class="selector-id">#fff</span></span><br><span class="line"><span class="selector-pseudo">::-webkit-selection</span></span><br><span class="line">    <span class="selector-tag">background</span> <span class="selector-id">#33a183</span></span><br><span class="line">    <span class="selector-tag">color</span> <span class="selector-id">#fff</span></span><br></pre></td></tr></table></figure>
<h2 id="pdf显示">pdf显示</h2>
<p>坑！把类似IDM之类的浏览器插件都关了，或者取消监视</p>
<p><img src="/2019/01/25/Blog/hexo%E7%BE%8E%E5%8C%96/image-20200408202520694.png" alt="image-20200408202520694"></p>
<p>hexo下，Install module to <code>source/lib</code> directory:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pdf source&#x2F;lib&#x2F;pdf</span><br></pre></td></tr></table></figure>
<p>主题配置文件中，pdf.enable: true</p>
<p>pdf还是放在和md文件同名的文件夹里</p>
<p>引用方式<code><div class="pdfobject-container" data-target="wind_song.pdf" data-height="800px"></div></code></p>
<p>就是这些~不需要安装hexo-pdf</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建和使用</title>
    <url>/2018/12/21/Blog/hexo%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="1-常用命令简化和组合">-1. 常用命令简化和组合</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g    # 等同于hexo generate，生成静态文件</span><br><span class="line">hexo s    # 等同于hexo server，在本地服务器运行</span><br><span class="line">hexo s --debug</span><br><span class="line">Ctrl + C 退出本地服务器</span><br><span class="line"></span><br><span class="line">hexo p    # 等同于hexo port</span><br><span class="line">hexo d    # 等同于hexo deploy，用于将本地文件发布到github上 </span><br><span class="line">hexo n 	  # 等同于hexo new，用于新建一篇文章</span><br></pre></td></tr></table></figure>
<p>当本地不想使用默认的4000端口时（比如在服务器上，默认使用80端口），可以使用 port 命令更改启动端口</p>
<p>另外，<strong>hexo</strong>支持命令合并，比方说 生成静态文件 → 本地启动80端口，我们可以执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -g -p 80</span><br></pre></td></tr></table></figure>
<p>生成静态文件并发布</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<h3 id="hexo文件结构及作用">hexo文件结构及作用</h3>
<h2 id="0-准备">0. 准备</h2>
<ol>
<li>注册github账号</li>
<li>本地安装好git</li>
</ol>
<h2 id="1-创建github仓库">1. 创建github仓库</h2>
<p>仓库名为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[your_github_username].github.io</span><br></pre></td></tr></table></figure>
<p>仓库名字一定不能写错！</p>
<a id="more"></a>
<h2 id="2-安装node">2. 安装node</h2>
<p>Node.js主要用于安装hexo，npm开头的命令都依赖于Node.js</p>
<p>nvm来管理node.js的版本真的很方便，这样就可以根据自己的需要来回切换node.js版本！</p>
<p>安装nvm管理工具（先关掉360等软件，不然会弹出警告！）</p>
<p>从官网下载安装包 <a href="https://github.com/coreybutler/nvm-windows/releases%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%BA%A2%E6%A1%86%E9%87%8C%E9%9D%A2%E7%9A%84%E9%82%A3%E4%B8%AA" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases，下载红框里面的那个</a></p>
<p><img src="/2018/12/21/Blog/hexo%E6%90%AD%E5%BB%BA/E:%5Cblog%5Chexo%5Csource_posts%5CBlog%5Chexo%E6%90%AD%E5%BB%BA%5Cimage-20240112213851906.png" alt="image-20240112213851906"></p>
<p>解压之后，nvm-setup.exe安装</p>
<p>如果出现版本号，即安装成功</p>
<p><img src="/2018/12/21/Blog/hexo%E6%90%AD%E5%BB%BA/E:%5Cblog%5Chexo%5Csource_posts%5CBlog%5Chexo%E6%90%AD%E5%BB%BA%5Cimage-20240112214131081.png" alt="image-20240112214131081"></p>
<p>查看可用的node.js版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls anaillable</span><br><span class="line">nvm install node 12.17.0</span><br></pre></td></tr></table></figure>
<p>不要装太低！低了npm不能用，后面用了16.20.2</p>
<p>安装完检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>随意切换node版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use [版本号]</span><br></pre></td></tr></table></figure>
<p>查看所有node版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure>
<h2 id="3-安装hexo">3. 安装hexo</h2>
<p>（1）安装hexo</p>
<p>鼠标右键任意地方，选择Git Bash，使用以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="comment"># 如果不执行第二句，出现“ERROR Deployer not found: git“这样的提示错误</span></span><br></pre></td></tr></table></figure>
<p>（2）创建放置博客文件的文件夹</p>
<ul>
<li>hexo文件夹，我放置在D盘，D:\blog\hexo</li>
<li>最好不要在中文路径下面，会出现莫名其妙的错误</li>
<li>注意：==以后进行hexo操作都要进入到此文件夹中==</li>
</ul>
<p>（3）初始化hexo</p>
<ul>
<li>初始化进入hexo文件夹，鼠标右键选择“Git Bash”，执行以下命令，</li>
<li>这时候会在该文件夹中创建网站所需要的文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>执行完毕后，将会生成以下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- node_modules       &#x2F;&#x2F;依赖安装目录</span><br><span class="line">|-- scaffolds          &#x2F;&#x2F;模板文件夹，新建的文章将会从此目录下的文件中继承格式</span><br><span class="line">|-- source             &#x2F;&#x2F;资源文件夹，用于放置图片、数据、文章等资源</span><br><span class="line">|   |-- _posts         &#x2F;&#x2F;文章目录</span><br><span class="line">|-- themes             &#x2F;&#x2F;主题文件夹</span><br><span class="line">|   |-- landscape      &#x2F;&#x2F;默认主题</span><br><span class="line">|-- .gitignore         &#x2F;&#x2F;指定不纳入git版本控制的文件</span><br><span class="line">|-- _config.yml        &#x2F;&#x2F;站点配置文件</span><br><span class="line">|-- db.json</span><br><span class="line">|-- package.json</span><br><span class="line">&#96;-- package-lock.json  &#x2F;&#x2F; hexo的版本和依赖包</span><br></pre></td></tr></table></figure>
<p>（4）安装依赖包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>会在Hexo目录中安装 node_modules</p>
<p>（5）生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>（6）预览</p>
<p>此时最基本的网站已经搭建好了，只不过是在本地放着，我们可以先预览一下</p>
<p>在git中执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>这时候，会在本地开启一个http服务，监听4000端口</p>
<p>我们在浏览器访问http://127.0.0.1:4000</p>
<h2 id="3’-更新hexo">3’. 更新hexo</h2>
<p>查看hexo版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<p>npm-check检查更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br></pre></td></tr></table></figure>
<p>npm-upgrade更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br></pre></td></tr></table></figure>
<p>这时候会有一个选择菜单式的持续输出供你选择依赖包的更新与否</p>
<p>其中的 <code>npm install</code> 可以加上参数 <code>-save</code> ，这样</p>
<ul>
<li>会把依赖包安装到 node_modules 目录中</li>
<li>会在package.json的dependencies属性下添加依赖包的名称和版本号</li>
<li>之后运行npm install命令时，会自动安装依赖包到node_modules目录中</li>
</ul>
<p>如果不加save参数的话</p>
<ul>
<li>之后把X包安装到node_modules目录中</li>
<li>不会添加到 package.json 文件的 dependencies 属性中。</li>
</ul>
<p>再查看hexo文件夹下面的 package.json 文件的 dependencies 属性,可以看到hexo的版本和依赖包已经更新了。</p>
<h2 id="4-部署本地文件到github">4. 部署本地文件到github</h2>
<p>本地文件要发布到github上面，则需要使本地git和互联网上的通信。怎么通信呢？</p>
<p>有两种方法，https和ssh公钥方式。</p>
<p>使用https的话需要每次输入密码，不过配置起来简单。</p>
<p>常用的是ssh公钥的方式。</p>
<p>先来在本地初始化一下git设置吧</p>
<h3 id="a-本机git初始设置">a. 本机git初始设置</h3>
<p>1、设置姓名和邮箱地址</p>
<p>（安装git时，已经配置好的话，可以跳过这一步）</p>
<p>终端输入：任意目录中都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config  --global  user.name  &quot;your name&quot;</span><br><span class="line">git config  --global  user.email  your_email@youremail.com</span><br></pre></td></tr></table></figure>
<p>我用的是我的用户名和邮箱设置的</p>
<p>邮箱仅仅是识别用的key，不一定是真实存在的邮箱</p>
<p>设置完成会在~/.gitconfig文件中生成如下配置</p>
<p>gitconfig这个文件在C:\Users\zhx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~&#x2F;.gitconfig</span><br><span class="line"></span><br><span class="line">[user]</span><br><span class="line">        name &#x3D; your name</span><br><span class="line">        email &#x3D; your_email@youremail.com</span><br><span class="line">[filter &quot;lfs&quot;]</span><br><span class="line">        required &#x3D; true</span><br><span class="line">        clean &#x3D; git-lfs clean -- %f</span><br><span class="line">        smudge &#x3D; git-lfs smudge -- %f</span><br><span class="line">        process &#x3D; git-lfs filter-process</span><br></pre></td></tr></table></figure>
<p>我用的是我的用户名和邮箱设置的，设置完成会在~/.gitconfig文件中生成如下配置</p>
<p>2、本地生成ssh key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C zhx@qq.com</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>SSH 为 [Secure Shell](<a href="https://baike.baidu.com/item/Secure" target="_blank" rel="noopener">https://baike.baidu.com/item/Secure</a> Shell) 的缩写，为建立在应用层基础上的安全协议。</p>
</li>
<li>
<p>SSH 是较可靠，专为<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/1071998" target="_blank" rel="noopener">远程登录</a>会话和其他网络服务提供安全性的协议。</p>
</li>
<li>
<p>和在linux生成的ssh一样，也可以生成的秘钥时候设置私钥密码（我后来设置了一个没有密码的ssh，每次输入太麻烦了）</p>
</li>
<li>
<p>-t = The type of the key to generate</p>
</li>
<li>
<p>-C = comment to identify the key</p>
</li>
</ul>
<p>所以这个注释你可以输入任何内容，很多网站和软件用这个注释作为密钥的名字</p>
<ul>
<li>
<p>会提示创建文件的路径，以及设置密码（直接回车，即为空密码）</p>
</li>
<li>
<p>生成id_rsa密钥和id_rsa.pub公钥</p>
</li>
<li>
<p>known_hosts文件，这个文件会把<strong>远程计算机的相关信息</strong>记录在这个文件里，确保你下次登录的时候是相同的服务器，避免遭受hijack之类的攻击。如果登录的服务器信息有所变动，那你登录的时候就会提示你，然后登录失败。</p>
</li>
</ul>
<p>3、把本机生成的公开的秘钥添加到github中</p>
<p>在<code>C:\Users\zhx\.ssh</code>下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>将公钥复制下来</p>
<p>4、将公钥放在github上</p>
<p>打开github登陆后，点击自己头像下箭头，找到settings（设置）</p>
<p>在左边栏目里面选择SSH keys，然后点击Add SSH key</p>
<p>随便填一个Title，把上面把cat出来的内容全部添加到key文本框里，然后点击add key。</p>
<p>添加成功后，创建github时用到的邮箱会收到GitHub发的一个”A new public key was add to your account”的邮件。（可能会比较慢）</p>
<p>5、使用私人密钥与GitHub进行认证和通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Hi xiangxiang-cpu! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<h3 id="b-将hexo和github进行关联">b. 将hexo和github进行关联</h3>
<p>1、编辑E：\hexo下的_config.yml文件，在_config.yml最下方，添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:thinkerwalker&#x2F;thinkerwalker.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>
<p>hexo的配置文件中任何引号’:’后面都是带一个空格的</p>
</li>
<li>
<p>repository: 后面的地址其实在github上有生成。新建仓库时候，会有生成如下图</p>
<p><img src="/2018/12/21/Blog/hexo%E6%90%AD%E5%BB%BA/image-20200408150322601.png" alt="image-20200408150322601"></p>
</li>
<li>
<p>这里发现还有HTTPS，其实HTTPS也可以和本地进行通信，只不过通信时候，每次要求输入GitHub账号密码</p>
</li>
</ul>
<p>2、将本地文件同步到GitHub</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>此时，我们的博客已经搭建起来，并发布到Github上了，这时可以登陆自己的Github查看代码是否已经推送到对应Repository，在浏览器访问http://xiangxiang-cpu.github.io<br>
就能看到自己的博客了。配置域名后，上面链接会失效？？？</p>
<p>第一次访问地址，可能访问不了，您可以在几分钟后进行访问，一般不超过10分钟。</p>
<h2 id="5-发表一篇文章">5. 发表一篇文章</h2>
<p>1、在Git Bash执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new “firstblog”</span><br></pre></td></tr></table></figure>
<p>2、这时候会在hexo\source_post文件夹中，生成一个firstblog.md文件，这时候，我们可以在里面编辑内容。</p>
<p>3、可以先在本地预览一下生成的博客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>4、访问http://127.0.0.1:4000</p>
<p>5、同步到GitHub上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>6、访问自己的网址即可查看，<a href="https://xiangxiang-cpu.github.io" target="_blank" rel="noopener">https://xiangxiang-cpu.github.io</a></p>
<h2 id="6-配置域名">6. 配置域名</h2>
<p>1、在hexo/source文件夹中新建一个CNAME文件，注意不是txt！</p>
<p>然后里面添加自己的网站域名（theworld.ltd）</p>
<p>2、到自己的域名解析中添加CNAME值，主机记录www，<a href="http://xn--username-nw7m987ov50e.github.io" target="_blank" rel="noopener">解析到username.github.io</a></p>
<p><img src="/2018/12/21/Blog/hexo%E6%90%AD%E5%BB%BA/image-20200408151636893.png" alt="image-20200408151636893"></p>
<ul>
<li>A记录，指向IP</li>
<li>CNAME记录， 当需要将域名指向另一个域名，再由另一个域名提供 IP 地址</li>
<li>@主机记录，不用输一级域名（www）也能访问</li>
<li>www主机记录，需要输www才能访问</li>
</ul>
<p>3、hexo g -d</p>
<p>4、等个10min就能用域名访问辣~</p>
<h2 id="7-安装插件">7. 安装插件</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install http:&#x2F;&#x2F;.... --save</span><br></pre></td></tr></table></figure>
<p>加save</p>
<h2 id="8-使用">8. 使用</h2>
<p>本地更新完博客后</p>
<p>在hexo根目录下（不是_posts文件夹下）打开git bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>就推送到服务器啦</p>
<h2 id="9-bug">9. bug</h2>
<p>TypeError [ERR_INVALID_ARG_TYPE]: The “mode” argument must be of type number.</p>
<p><img src="/2018/12/21/Blog/hexo%E6%90%AD%E5%BB%BA/hexo%E6%90%AD%E5%BB%BA%5Cimage-20240112213129975.png" alt="image-20240112213129975"></p>
<p>原因：node 版本太高了</p>
<p><img src="/2018/12/21/Blog/hexo%E6%90%AD%E5%BB%BA/hexo%E6%90%AD%E5%BB%BA%5Cimage-20240112213312194.png" alt="image-20240112213312194"></p>
<p><a href="https://www.jb51.net/article/202124.htm" target="_blank" rel="noopener">https://www.jb51.net/article/202124.htm</a></p>
<h4 id="出现404">出现404</h4>
<p><a href="https://www.jianshu.com/p/2349c763cc02?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/2349c763cc02?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>
<h2 id="old-安装node-js">old. 安装node.js</h2>
<p>不用这种方法，容易安装到太高版本的node</p>
<ul>
<li>
<p>下载node.js的网址https://nodejs.org/en/download/</p>
<p>我选择 <strong>Windows Installer (.msi)</strong> ，不太喜欢用zip的= =</p>
</li>
<li>
<p>Node.js主要用于安装hexo，npm开头的命令都依赖于Node.js</p>
</li>
<li>
<p>如果出现以下提示，则代表你的Node.js没有安装或者还未生效，如果已经安装了则重启电脑</p>
<p>bash: nmp: command not found</p>
</li>
<li>
<p>查看node版本的命令：在cmd或者git bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="介绍npm">介绍npm</h3>
<p><a href="https://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-npm.html</a></p>
<p>NPM是随同NodeJS一起安装的包管理工具</p>
<h4 id="使用淘宝-NPM-镜像">使用淘宝 NPM 镜像</h4>
<p>大家都知道国内直接使用npm的官方镜像是非常慢的，这里推荐使用淘宝NPM镜像。</p>
<p>淘宝NPM镜像是一个完整npmjs.org镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 cnpm 命令来安装模块了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install [name]</span><br></pre></td></tr></table></figure>
<h4 id="查看npm版本">查看npm版本</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<h4 id="更新npm">更新npm</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install npm -g</span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h4 id="安装包">安装包</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &lt;Module Name&gt;</span><br><span class="line">包名可以直接是github的链接</span><br></pre></td></tr></table></figure>
<p>包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 <strong>require(‘xx’)</strong> 的方式就好，无需指定第三方包路径。</p>
<h4 id="全局安装与本地安装">全局安装与本地安装</h4>
<p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install express          <span class="comment"># 本地安装</span></span><br><span class="line">npm install express -g   <span class="comment"># 全局安装</span></span><br></pre></td></tr></table></figure>
<h5 id="本地安装">本地安装</h5>
<ul>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ul>
<h5 id="全局安装">全局安装</h5>
<ul>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ul>
<h4 id="查看安装信息">查看安装信息</h4>
<p>你可以使用以下命令来查看所有全局安装的模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm list -g</span><br></pre></td></tr></table></figure>
<p>如果要查看某个模块的版本号，可以使用命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm list grunt</span><br></pre></td></tr></table></figure>
<h4 id="Package-json-属性说明">Package.json 属性说明</h4>
<ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字</li>
</ul>
<h4 id="卸载模块">卸载模块</h4>
<p>我们可以使用以下命令来卸载 Node.js 模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall express</span><br></pre></td></tr></table></figure>
<p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm ls</span><br></pre></td></tr></table></figure>
<h4 id="更新模块">更新模块</h4>
<p>我们可以使用以下命令更新模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm update express</span><br></pre></td></tr></table></figure>
<h4 id="搜索模块？">搜索模块？</h4>
<p>使用以下来搜索模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm search express</span><br></pre></td></tr></table></figure>
<h2 id></h2>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>押尾指弹曲练习记录！</title>
    <url>/2018/10/28/Guitar/oshio_kotaro/</url>
    <content><![CDATA[<div class="pdfobject-container" data-target="wind_song.pdf" data-height="800px"></div>
]]></content>
      <categories>
        <category>Guitar</category>
      </categories>
  </entry>
  <entry>
    <title>Java Collection</title>
    <url>/2018/12/21/Java/Collection/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/28241176" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28241176</a></p>
<p><img src="/2018/12/21/Java/Collection/v2-76c3c04de2e8609c488fa0081fb99c26_720w.png" alt="img"></p>
<h2 id="ArrayList和Vector区别">ArrayList和Vector区别</h2>
<p>1、Vector是线程安全的，ArrayList不是线程安全的。<br>
2、ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</p>
<p>add remove get capacity size isEmpty</p>
<p><strong>只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性</strong>。</p>
<p>当执行synchronized修饰的方法前，系统会对该方法加一把锁，方法执行完成后释放锁，**加锁和释放锁的这个过程，在系统中是有开销的，因此，**在单线程的环境中，Vector效率要差很多。（多线程环境不允许用ArrayList，需要做处理）。</p>
<h1>Arrays</h1>
<h2 id="数组的初始化方式">数组的初始化方式</h2>
<h3 id="Fill">Fill</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] actorArray = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 把全部位置都用“Bill”填充</span></span><br><span class="line">        Arrays.fill(actorArray,<span class="string">"Bill"</span>);         					                           System.out.println(Arrays.toString(actorArray));</span><br><span class="line">        <span class="comment">// 输出为[Bill, Bill, Bill, Bill, Bill]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="CopyOf-CopyOfRange">CopyOf / CopyOfRange</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] actorArray = &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line"><span class="comment">// 从开始点的length个长度</span></span><br><span class="line">String[] actorArray2 = Arrays.copyOf(actorArray, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [开始下标，结束下标)，前闭后开</span></span><br><span class="line">String[] actorArray3 = Arrays.copyOfRange(actorArray, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(actorArray));</span><br><span class="line">System.out.println(Arrays.toString(actorArray2));</span><br><span class="line">System.out.println(Arrays.toString(actorArray3));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// [0, 1]</span></span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="先声明，再赋值-声明的同时赋值">先声明，再赋值 &amp; 声明的同时赋值</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	a[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 会报错！</span></span><br><span class="line"><span class="comment">// int[] b1 = new int[3]&#123;0, 1, 2&#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="sort-方法">sort()方法</h2>
<h3 id="重载compare-方法">重载compare()方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreArray</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BufferedReader br;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Double[] d = <span class="keyword">new</span> Double[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;Double&gt; c = <span class="keyword">new</span> Mycomparator();   <span class="comment">// 实例化一个Comparator对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"../exp6/exp6_score.txt"</span>));</span><br><span class="line">            String s1;</span><br><span class="line">            <span class="keyword">while</span> ((s1 = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[count++] = Double.valueOf(s1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重写compare函数，实现从大到小排序</span></span><br><span class="line">            Arrays.sort(d, c);</span><br><span class="line">            <span class="comment">//Arrays.sort(d);</span></span><br><span class="line">            System.out.println(Arrays.toString(d));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycomparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Double</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double o1, Double o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(o1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(o2));</span><br><span class="line">        <span class="keyword">if</span>(b1.compareTo(b2)==-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b1.compareTo(b2)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这一行不能写if  系统会认为可能没有返回值</span></span><br><span class="line">        <span class="comment">// 用else表示程序会有一个 确定的出口</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值 -1 小于 0 等于 1 大于</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="BinarySearch">BinarySearch</h2>
<ul>
<li>二分查找前提是已经<strong>排好序</strong>的数组（字符串也可以排序）</li>
</ul>
<p><a href="https://blog.csdn.net/cxhply/article/details/49423501" target="_blank" rel="noopener">https://blog.csdn.net/cxhply/article/details/49423501</a></p>
<h3 id="binarySearch-Object-Object-key">binarySearch(Object[], Object key)</h3>
<p>a: 要搜索的数组；key：要搜索的值</p>
<p>如果key在数组中，则返回搜索值的索引；否则返回-1或“-”（插入点）。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素的索引。</p>
<p><strong>技巧：</strong></p>
<p>[1] 搜索值是数组元素，得搜索值的下标（从0开始计数）；</p>
<p>[2] 搜索值不是数组元素，且<strong>在数组范围内</strong>，得“ - 待插入点下标（从1开始计数）”；</p>
<p>[3] 搜索值不是数组元素，且<strong>大于</strong>数组内元素，返回 – (length + 1);</p>
<p>[4] 搜索值不是数组元素，且<strong>小于</strong>数组内元素，返回 – 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index1 = Arrays.binarySearch(arr, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index2 = Arrays.binarySearch(arr, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index3 = Arrays.binarySearch(arr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index4 = Arrays.binarySearch(arr, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"index1 = "</span> +</span><br><span class="line">                index1 +</span><br><span class="line">                <span class="string">", index2 = "</span> +</span><br><span class="line">                index2 +</span><br><span class="line">                <span class="string">", index3 = "</span> +</span><br><span class="line">                index3 +</span><br><span class="line">                <span class="string">", index4 = "</span> +</span><br><span class="line">                index4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index1 = -5, index2 = 2, index3 = -1, index4 = -7</span></span><br></pre></td></tr></table></figure>
<h3 id="binarySearch-Object-int-fromIndex-int-toIndex-Object-key">binarySearch(Object[], int fromIndex, int toIndex, Object key)</h3>
<p>a：要搜索的数组</p>
<p>fromIndex：指定范围的开始处索引</p>
<p>toIndex：指定范围的结束处索引</p>
<p><strong>均为从0开始计数，且前闭后开</strong></p>
<p>key：要搜索的值</p>
<p>如果要搜索的元素key在指定的范围内，则返回搜索值的索引；否则返回-1或“-”（插入点）。</p>
<p><strong>技巧：</strong></p>
<p>[1] 该搜索键在范围内，搜索值是数组元素，得搜索值的下标（从0开始计数）；</p>
<p>[2] 该搜索键在范围内，搜索值不是数组元素，且<strong>在数组范围内</strong>，得“ - 待插入点下标（从1开始计数）”；</p>
<p>[3] 该搜索键不在范围内，搜索值不是数组元素，且<strong>大于</strong>数组内元素，返回–(toIndex + 1)；</p>
<p>[4] 该搜索键不在范围内，搜索值不是数组元素，且<strong>小于</strong>数组内元素，返回 –(fromIndex  + 1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index5 = Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index6 = Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index7 = Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index8 = Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index9 = Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"index5 = "</span> +</span><br><span class="line">                index5 +</span><br><span class="line">                <span class="string">", index6 = "</span> +</span><br><span class="line">                index6 +</span><br><span class="line">                <span class="string">", index7 = "</span> +</span><br><span class="line">                index7 +</span><br><span class="line">                <span class="string">", index8 = "</span> +</span><br><span class="line">                index8 +</span><br><span class="line">                <span class="string">", index9 = "</span> +</span><br><span class="line">                index9);</span><br><span class="line"><span class="comment">// index5 = -5, index6 = 2, index7 = -2, index8 = -4, index9 = -2</span></span><br></pre></td></tr></table></figure>
<h2 id="toString-方法">toString()方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] actorArray=&#123;<span class="string">"b"</span>,<span class="string">"a"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(actorArray));</span><br><span class="line">Arrays.sort(actorArray);</span><br><span class="line">System.out.println(Arrays.toString(actorArray));</span><br><span class="line">System.out.println(actorArray);</span><br><span class="line">System.out.println(actorArray.toString());</span><br><span class="line"><span class="comment">//[b, a, c]</span></span><br><span class="line"><span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">//[Ljava.lang.String;@1b6d3586</span></span><br><span class="line"><span class="comment">//[Ljava.lang.String;@1b6d3586</span></span><br></pre></td></tr></table></figure>
<h2 id="equals-方法">equals()方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] actorArray = &#123;<span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">String[] actorArray2 = &#123;<span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">String[] actorArray3 = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用值（地址）不相同</span></span><br><span class="line">System.out.println(actorArray == actorArray2);<span class="comment">// false</span></span><br><span class="line">System.out.println(Arrays.equals(actorArray, actorArray2));<span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺序不同也被认为是不同的数组</span></span><br><span class="line">System.out.println(Arrays.equals(actorArray3, actorArray2));<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="hashcode">hashcode</h2>
<p>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 。</p>
<p>public int <strong>hashCode</strong>()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。</p>
<p><img src="/2018/12/21/Java/Collection/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5C%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="容器类继承关系图"></p>
<h1>collection主要方法:</h1>
<p><a href="http://www.cnblogs.com/taiwan/p/6954135.html" target="_blank" rel="noopener">http://www.cnblogs.com/taiwan/p/6954135.html</a></p>
<ul>
<li>boolean add(Object o)添加对象到集合</li>
<li>boolean remove(Object o)删除指定的对象</li>
<li>boolean contains(Object o)查找集合中是否有指定的对象</li>
<li>int size()返回当前集合中元素的数量</li>
<li>boolean isEmpty()判断集合是否为空</li>
<li>void clear()删除集合中所有元素</li>
<li>boolean containsAll(Collection c)查找集合中是否有集合c中的元素</li>
<li>boolean addAll(Collection c)将集合c中所有的元素添加给该集合</li>
<li>void removeAll(Collection c)从集合中删除c集合中也有的元素</li>
<li>void retainAll(Collection c)从集合中删除集合c中不包含的元素</li>
<li>Iterator iterator()返回一个迭代器</li>
</ul>
<h2 id="List">List</h2>
<p>(collection的抽象子接口，可重复<strong>有序</strong>)</p>
<p><strong>主要方法：</strong></p>
<ul>
<li>void add(int index,Object element)在指定位置上添加一个对象</li>
<li>boolean addAll(int index,Collection c)将集合c的元素添加到指定的位置</li>
<li>Object get(int index)返回List中指定位置的元素</li>
<li>int indexOf(Object o)返回第一个出现元素o的位置.</li>
<li>Object remove(int index)删除指定位置的元素</li>
<li>Object set(int index,Object element)用元素element取代位置index上的元素,返回被取代的元素</li>
<li>void sort()</li>
</ul>
<h3 id="LinkedList和ArrayList比较">LinkedList和ArrayList比较</h3>
<ul>
<li>
<p>LinkedList没有同步方法</p>
</li>
<li>
<p>ArrayList非同步的（unsynchronized）</p>
</li>
<li>
<p>LinkedList中插入元素很快，而ArrayList中插入元素很慢</p>
</li>
<li>
<p>LinkedList中随机访问很慢，而ArrayList中随机访问很快</p>
</li>
<li>
<p>Vector(同步) 非常类似ArrayList，但是Vector是同步的</p>
</li>
<li>
<p>Stack 记住 push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。注意：Stack刚创建后是空栈。</p>
</li>
</ul>
<h3 id="ArrayList">ArrayList</h3>
<p>原文：<a href="https://blog.csdn.net/robert_chen1988/article/details/73381641" target="_blank" rel="noopener">https://blog.csdn.net/robert_chen1988/article/details/73381641</a></p>
<h4 id="常用的方法">常用的方法</h4>
<ul>
<li>add(E e):                     在数组<strong>末尾</strong>添加元素</li>
<li>size():                           数组中实际元素个数，并不是数组容量</li>
<li>add(int index, E e):    在数组指定位置添加元素</li>
<li>clear():                         将数组中元素清空</li>
<li>contains(E e):             判断数组中是否含有某个元素</li>
<li>get(int index):             返回数组指定位置的元素</li>
<li>indexOf(E e):              返回数组指定元素<strong>第一次</strong>出现的位置</li>
<li>set(int index, E e):     替换数组指定位置的值</li>
<li>remove(int index):     移除数组指定位置的元素</li>
<li>remove(E e):              移除数组中<strong>第一次</strong>出现的指定元素</li>
<li>addAll(Collection&lt;? extends E&gt; c):                     在数组末尾添加另一个数组</li>
<li>addAll(int index, collection&lt;? extends E&gt; c):     在数组指定位置添加另一个数组</li>
<li>removeAll(Collection&lt;?&gt;c):                                   将数组中属于数组 c 中的元素全部删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       	<span class="comment">// 添加到末尾位置</span></span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        list1.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(list1.size());<span class="comment">// 3</span></span><br><span class="line">        System.out.println(list1);<span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">       	<span class="comment">// 插入到特定位置</span></span><br><span class="line">        list1.add(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list1);<span class="comment">// [1, 2, 4, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear</span></span><br><span class="line">        list1.clear();</span><br><span class="line">        System.out.println(list1);<span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        list1.add(<span class="number">5</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">1</span>);</span><br><span class="line">        list2.add(<span class="number">2</span>);</span><br><span class="line">        list2.add(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 把括号中ArrayList中的全部元素加到list2的末端</span></span><br><span class="line">        list2.addAll(list1);</span><br><span class="line">        System.out.println(list2);<span class="comment">// [1, 2, 3, 5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否含有特定元素</span></span><br><span class="line">        System.out.println(list2.contains(<span class="number">5</span>));<span class="comment">// true</span></span><br><span class="line">        <span class="comment">// get</span></span><br><span class="line">        System.out.println(list2.get(<span class="number">2</span>));<span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// 返回某个元素所在的位置，如果不包含则返回</span></span><br><span class="line">        System.out.println(list2.indexOf(<span class="number">5</span>));<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// set</span></span><br><span class="line">        list2.set(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(list2);<span class="comment">// [1, 2, 10, 5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Removes</span></span><br><span class="line">        list2.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(list2);<span class="comment">// [1, 2, 5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将某个元素首次出现位置删除（如果存在）</span></span><br><span class="line">        list2.remove(Integer.valueOf(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list2);<span class="comment">// [2, 5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把某个元素出现的所有位置全部删除</span></span><br><span class="line">        list2.removeAll(Arrays.asList(<span class="number">5</span>));</span><br><span class="line">        System.out.println(list2);<span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<h3 id="LinkedList">LinkedList</h3>
<p><a href="https://blog.csdn.net/gongchuangsu/article/details/51527042" target="_blank" rel="noopener">https://blog.csdn.net/gongchuangsu/article/details/51527042</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 基本操作 ************************/</span></span><br><span class="line">        linkedList.addFirst(<span class="number">0</span>);    <span class="comment">// 添加元素到列表开头</span></span><br><span class="line">        linkedList.add(<span class="number">1</span>);         <span class="comment">// 在列表结尾添加元素</span></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">2</span>);       <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">3</span>);     <span class="comment">// 添加元素到列表结尾</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"LinkedList: "</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"getFirst(): "</span> + linkedList.getFirst());       <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"getLast(): "</span> + linkedList.getLast());         <span class="comment">// 返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeFirst(): "</span> + linkedList.removeFirst()); <span class="comment">// 移除并返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeLast(): "</span> + linkedList.removeLast());   <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After remove:"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"contains(1) is :"</span> + linkedList.contains(<span class="number">1</span>));  <span class="comment">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class="line">        System.out.println(<span class="string">"size is : "</span> + linkedList.size());             <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 位置访问操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.set(<span class="number">1</span>, <span class="number">3</span>);                                             <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After set(1, 3):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"get(1): "</span> + linkedList.get(<span class="number">1</span>));               <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Search操作  ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"indexOf(3): "</span> + linkedList.indexOf(<span class="number">3</span>));        <span class="comment">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class="line">        System.out.println(<span class="string">"lastIndexOf(3): "</span> + linkedList.lastIndexOf(<span class="number">3</span>));<span class="comment">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Queue操作   ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"peek(): "</span> + linkedList.peek());                <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"element(): "</span> + linkedList.element());          <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        linkedList.poll();                                                 <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"After poll():"</span> + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(<span class="string">"After remove():"</span> + linkedList);                <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        linkedList.offer(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"After offer(4):"</span> + linkedList);                <span class="comment">// 将指定元素添加到此列表的末尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Deque操作   ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.offerFirst(<span class="number">2</span>);                                          <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerFirst(2):"</span> + linkedList);</span><br><span class="line">        linkedList.offerLast(<span class="number">5</span>);                                           <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerLast(5):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"peekFirst(): "</span> + linkedList.peekFirst());      <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"peekLast(): "</span> + linkedList.peekLast());        <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        linkedList.pollFirst();                                            <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollFirst():"</span> + linkedList);</span><br><span class="line">        linkedList.pollLast();                                             <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollLast():"</span> + linkedList);</span><br><span class="line">        linkedList.push(<span class="number">2</span>);                                                <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">        System.out.println(<span class="string">"After push(2):"</span> + linkedList);</span><br><span class="line">        linkedList.pop();                                                  <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">        System.out.println(<span class="string">"After pop():"</span> + linkedList);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">3</span>);                               <span class="comment">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">3</span>);                                <span class="comment">// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 遍历操作   ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Iterator："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种for循环遍历</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for2："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp1.size() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"pollFirst()或pollLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp2.size() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"removeFirst()或removeLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/**Output</span></span><br><span class="line"><span class="comment">         LinkedList: [0, 1, 2, 3]</span></span><br><span class="line"><span class="comment">         getFirst(): 0</span></span><br><span class="line"><span class="comment">         getLast(): 3</span></span><br><span class="line"><span class="comment">         removeFirst(): 0</span></span><br><span class="line"><span class="comment">         removeLast(): 3</span></span><br><span class="line"><span class="comment">         After remove:[1, 2]</span></span><br><span class="line"><span class="comment">         contains(1) is :true</span></span><br><span class="line"><span class="comment">         size is : 2</span></span><br><span class="line"><span class="comment">         -----------------------------------------</span></span><br><span class="line"><span class="comment">         After set(1, 3):[1, 3]</span></span><br><span class="line"><span class="comment">         get(1): 3</span></span><br><span class="line"><span class="comment">         -----------------------------------------</span></span><br><span class="line"><span class="comment">         indexOf(3): 1</span></span><br><span class="line"><span class="comment">         lastIndexOf(3): 2</span></span><br><span class="line"><span class="comment">         -----------------------------------------</span></span><br><span class="line"><span class="comment">         peek(): 1</span></span><br><span class="line"><span class="comment">         element(): 1</span></span><br><span class="line"><span class="comment">         After poll():[3, 3]</span></span><br><span class="line"><span class="comment">         After remove():[3]</span></span><br><span class="line"><span class="comment">         After offer(4):[3, 4]</span></span><br><span class="line"><span class="comment">         -----------------------------------------</span></span><br><span class="line"><span class="comment">         After offerFirst(2):[2, 3, 4]</span></span><br><span class="line"><span class="comment">         After offerLast(5):[2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">         peekFirst(): 2</span></span><br><span class="line"><span class="comment">         peekLast(): 5</span></span><br><span class="line"><span class="comment">         After pollFirst():[3, 4, 5]</span></span><br><span class="line"><span class="comment">         After pollLast():[3, 4]</span></span><br><span class="line"><span class="comment">         After push(2):[2, 3, 4]</span></span><br><span class="line"><span class="comment">         After pop():[3, 4]</span></span><br><span class="line"><span class="comment">         After removeFirstOccurrence(3):[4, 3]</span></span><br><span class="line"><span class="comment">         After removeFirstOccurrence(3):[4]</span></span><br><span class="line"><span class="comment">         -----------------------------------------</span></span><br><span class="line"><span class="comment">         Iterator：17 ms</span></span><br><span class="line"><span class="comment">         for：8419 ms</span></span><br><span class="line"><span class="comment">         for2：12 ms</span></span><br><span class="line"><span class="comment">         pollFirst()或pollLast()：12 ms</span></span><br><span class="line"><span class="comment">         removeFirst()或removeLast()：10 ms</span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure>
<h2 id="Set">Set</h2>
<p>(不包含重复的元素，没有顺序）</p>
<h2 id="Collections">Collections</h2>
<p>sort（collection没有）</p>
<p>binarySearch</p>
<p>fill</p>
<p>reverse()</p>
<h2 id="Java中Collection和Collections的区别"><a href="http://www.cnblogs.com/dashi/p/3597937.html" target="_blank" rel="noopener">Java中Collection和Collections的区别</a></h2>
<p>1、java.util.Collection 是一个<strong>集合接口（集合类的一个顶级接口）</strong>。</p>
<ul>
<li>它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</li>
<li>其直接继承接口有List与Set。</li>
</ul>
<p>Collection<br>
├List<br>
│├LinkedList<br>
│├ArrayList<br>
│└Vector<br>
│　└Stack<br>
└Set</p>
<p>2、java.util.Collections 是一个helper class/包装类（工具类/帮助类）</p>
<ul>
<li>它包含有各种有关集合操作的<strong>静态多态方法</strong>。</li>
<li>此类<strong>不能实例化</strong>，就像一<strong>个工具类</strong>，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。</li>
</ul>
<h1>Map</h1>
<ul>
<li>
<p>map特点：高效查找，不能排序（需要转换为List）TBD</p>
</li>
<li>
<p>Map没有继承Collection接口，Map提供key到value的映射通常来说，Map是一个由键值对组成的数据结构，且在集合中每个键是唯一的。下面就以K和V来代表键和值，来说明一下java中关于Map的九大问题。</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li>
<p>boolean equals(Object o)比较对象</p>
</li>
<li>
<p>boolean remove(Object o)删除一个对象</p>
</li>
<li>
<p>put(Object key,Object value)添加key和value</p>
</li>
</ul>
<p><strong>Map.Entry说明</strong></p>
<p>Map是java中的接口，Map.Entry是Map的一个内部接口。</p>
<p>Map提供了一些常用方法，如keySet()、entrySet()等方法，keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。</p>
<p>Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。</p>
<h2 id="四种遍历方法：">四种遍历方法：</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.首先我们要知道map储存数据的方式，map储存数据的形式是一个key和一个value对应，即</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 其储存的数据类型可以是任意的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.接下来我们简单的介绍一下它添加数据和遍历数据的方法：</span></span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        map.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        map.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"通过Map.keySet遍历key和value："</span>);</span><br><span class="line">		<span class="comment">// foreach循环，遍历 ：后的所有内容</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"key= "</span> + key + <span class="string">" and value= "</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">		<span class="comment">// entrySet()的返回值也是返回一个Set集合，此集合的类 型为Map.Entry</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();  <span class="comment">//通过构造操作符来遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">            System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet遍历key和value"</span>);  <span class="comment">//同样是foreach方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四种</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String v : map.values())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//https://blog.csdn.net/qq_36719861/article/details/79503456</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>通过Map.keySet遍历key和value：<br>
key= key1 and value= value1<br>
key= key2 and value= value2<br>
key= key3 and value= value3<br>
通过Map.entrySet使用iterator遍历key和value：<br>
key= key1 and value= value1<br>
key= key2 and value= value2<br>
key= key3 and value= value3<br>
通过Map.entrySet遍历key和value<br>
key= key1 and value= value1<br>
key= key2 and value= value2<br>
key= key3 and value= value3<br>
通过Map.values()遍历所有的value，但不能遍历key<br>
value= value1<br>
value= value2<br>
value= value3</p>
<p>这里要特别说明（ Map.Entry，是Map的内部类，它用来描述Map中的键/值对）。 Map是一个接口，我们平时多用它的实现类HashMap。</p>
<h2 id="常用方法">常用方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">//map使用方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// map实例化</span></span><br><span class="line">        Map&lt;String, Integer&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        maps.put(<span class="string">"A"</span>, <span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">"B"</span>, <span class="number">20</span>);</span><br><span class="line">        maps.put(<span class="string">"C"</span>, <span class="number">30</span>);</span><br><span class="line">        maps.put(<span class="string">"D"</span>, <span class="number">40</span>);</span><br><span class="line">        maps.put(<span class="string">"E"</span>, <span class="number">50</span>);</span><br><span class="line">        maps.put(<span class="string">"F"</span>, <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 修改元素</span></span><br><span class="line">        maps.replace(<span class="string">"F"</span>, <span class="number">65</span>);</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        maps.remove(<span class="string">"E"</span>);</span><br><span class="line">        <span class="comment">// 遍历map-原始方法</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : maps.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"key:"</span> + entry.getKey() + <span class="string">";value:"</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="comment">// 遍历map-forEach方法（Java8新特性）</span></span><br><span class="line">        maps.forEach((k, v) -&gt; System.out.println(<span class="string">"key : "</span> + k + <span class="string">"; value : "</span> + v));<span class="comment">// 查询元素</span></span><br><span class="line">        <span class="keyword">int</span> f = maps.get(<span class="string">"F"</span>);</span><br><span class="line">        System.out.println(<span class="string">"F的值为:"</span> + f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GUI</title>
    <url>/2018/12/21/Java/GUI/</url>
    <content><![CDATA[<h1>GUI</h1>
<p>Graphical User Interface（用户图形界面）</p>
<ul>
<li>Java的GUI提供的对象都存在 java.Awt 和 javax.Swing 两个包中.</li>
</ul>
<ul>
<li>java.Awt:Abstract Window ToolKit(抽象 窗口工具包)</li>
</ul>
<ul>
<li>java.Swing：在AWT的基础上，建立的一套图形界面系统，提供了更多的组件，而且完全由java实现，增强了移植性，属于轻量级控件。(跨平台很好)</li>
</ul>
<a id="more"></a>
<h1>IDEA 开发GUI</h1>
<ol>
<li>在项目下的src文件夹上右键,新建GUI Form</li>
<li>在界面上任意选择一个组件，然后点Ｆ４，跳转到GUI所绑定的Class对象,找到主panel的位置,点击Alt+insert,弹出快捷操作.</li>
</ol>
<h1>设计步骤</h1>
<h2 id="创建组件-Component">创建组件 Component</h2>
<ul>
<li>Container（顶层/中间）
<ul>
<li>Window（JFrame、JDialog）</li>
<li>Panel（JApplet）</li>
</ul>
</li>
<li>JComponent</li>
<li>辅助类（颜色、字体等）</li>
</ul>
<p><strong>JComponent记住关键属性</strong></p>
<h3 id="按钮">按钮</h3>
<ul>
<li>
<p>按钮</p>
</li>
<li>
<p>单选</p>
</li>
<li>
<p>多选</p>
<p>ButtonGroup是纯逻辑显示</p>
</li>
</ul>
<h3 id="文本区">文本区</h3>
<ul>
<li>文本行（单行）</li>
<li>文本区（多行）</li>
</ul>
<h2 id="指定布局-Layout">指定布局 Layout</h2>
<ul>
<li>
<p>只有容器和他的子类可以设置布局</p>
</li>
<li>
<p>如果有同类的组件，最好用数组放在一起</p>
</li>
<li>
<p>GridLayout的行数和列数都可以是1，实现纵向和横向切割</p>
<p>狗日的Layout</p>
</li>
<li>
<p>BorderLayout拖动时：上下的高度不变，左右的宽度不变</p>
</li>
<li>
<p>注意ButtonGroup的应用</p>
</li>
</ul>
<h3 id="布局管理器分类">布局管理器分类</h3>
<h4 id="setLayout-null-：没有布局">setLayout(null)：没有布局</h4>
<p>// 将容器的布局管理器设置为null</p>
<h4 id="重点：FlowLayout：流式">重点：FlowLayout：流式</h4>
<ul>
<li>大小和位置：大小不变，自左而右，自上而下</li>
<li>对齐，间距</li>
<li>P274</li>
</ul>
<p>根据内容确定大小，可能在行之间流动</p>
<h4 id="重点：BorderLayout：边界式">重点：BorderLayout：边界式</h4>
<ul>
<li>将容器分为5个区域：东南西北中（上&amp;下是完整的），默认为中间</li>
<li>经常将两种布局嵌套起来用</li>
</ul>
<h4 id="GridLayout：网格式">GridLayout：网格式</h4>
<h5 id="1、GridLayout布局特征">1、GridLayout布局特征</h5>
<p>网格布局特点：</p>
<ol>
<li>
<p>使容器中的各组件呈M行×N列的网格状分布。</p>
</li>
<li>
<p>网格每列宽度相同，等于容器的宽度除以网格的列数。<br>
网格每行高度相同，等于容器的高度除以网格的行数。</p>
</li>
<li>
<p>各组件的排列方式为：从上到下，从左到右。<br>
容器大小改变时，组件的相对位置不变，大小会改变。</p>
</li>
<li>
<p>设置行数和列数时，行数或者列数可以有一个为<strong>零（即不限）</strong><br>
若rows为0，cols为3，则列固定为3，行不限，每行只能放3个</p>
</li>
</ol>
<p>若cols为0，rows为3，则行固定为3，列不限，每行必定有控件</p>
<ol start="5">
<li>至于其他规则，很明显啦。<br>
假设你有13个控件，你又设置了三行，一行五个，你觉得第三行应该有多少个？</li>
</ol>
<p>并且如果组件数量超过设定的个数，布局管理器会自动增加网格个数，原则是保持行数不变。就是</p>
<p>假设还是13个控件，你设置了两行，一行五个，放不下系统就给加了行，第三行放多出来的三个）</p>
<h5 id="2、网格布局GridLayout类的常用构造函数和方法">2、网格布局GridLayout类的常用构造函数和方法</h5>
<p><img src="/2018/12/21/Java/GUI/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5CGridLayout1.png" alt="GridLayout1"></p>
<p><img src="/2018/12/21/Java/GUI/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5CGridLayout2.png" alt="GridLayout2"></p>
<h5 id="3、网格布局实例：">3、网格布局实例：</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原文：<a href="https://blog.csdn.net/qq_33639584/article/details/55050948" target="_blank" rel="noopener">https://blog.csdn.net/qq_33639584/article/details/55050948</a></p>
<h4 id="GridBagLayout">GridBagLayout</h4>
<p><a href="https://www.cnblogs.com/taoweiji/archive/2012/12/14/2818787.html" target="_blank" rel="noopener">https://www.cnblogs.com/taoweiji/archive/2012/12/14/2818787.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GridBagDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    JButton B1;</span><br><span class="line">    JButton B2;</span><br><span class="line">    JButton B3;</span><br><span class="line">    JPanel P1;</span><br><span class="line">    JComboBox C1;</span><br><span class="line">    JTextField TF1;</span><br><span class="line">    JButton B7;</span><br><span class="line">    JList L1;</span><br><span class="line">    JTextArea TA1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GridBagDemo demo = <span class="keyword">new</span> GridBagDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridBagDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B1 = <span class="keyword">new</span> JButton(<span class="string">"打开"</span>);</span><br><span class="line">        B2 = <span class="keyword">new</span> JButton(<span class="string">"保存"</span>);</span><br><span class="line">        B3 = <span class="keyword">new</span> JButton(<span class="string">"另存为"</span>);</span><br><span class="line">        P1 = <span class="keyword">new</span> JPanel();</span><br><span class="line">        String[] str = &#123;<span class="string">"java笔记"</span>, <span class="string">"C#笔记"</span>, <span class="string">"HTML5笔记"</span>&#125;;</span><br><span class="line">        C1 = <span class="keyword">new</span> JComboBox(str);</span><br><span class="line">        TF1 = <span class="keyword">new</span> JTextField();</span><br><span class="line">        B7 = <span class="keyword">new</span> JButton(<span class="string">"清空"</span>);</span><br><span class="line">        L1 = <span class="keyword">new</span> JList(str);</span><br><span class="line">        TA1 = <span class="keyword">new</span> JTextArea();</span><br><span class="line">        TA1.setBackground(Color.PINK);<span class="comment">//为了看出效果，设置了颜色</span></span><br><span class="line"></span><br><span class="line">        GridBagLayout layout = <span class="keyword">new</span> GridBagLayout();</span><br><span class="line">        <span class="keyword">this</span>.setLayout(layout);</span><br><span class="line">        <span class="keyword">this</span>.add(B1);<span class="comment">//把组件添加进jFrame</span></span><br><span class="line">        <span class="keyword">this</span>.add(B2);</span><br><span class="line">        <span class="keyword">this</span>.add(B3);</span><br><span class="line">        <span class="keyword">this</span>.add(P1);</span><br><span class="line">        <span class="keyword">this</span>.add(C1);</span><br><span class="line">        <span class="keyword">this</span>.add(TF1);</span><br><span class="line">        <span class="keyword">this</span>.add(B7);</span><br><span class="line">        <span class="keyword">this</span>.add(L1);</span><br><span class="line">        <span class="keyword">this</span>.add(TA1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个GridBagConstraints，</span></span><br><span class="line">        GridBagConstraints constraint = <span class="keyword">new</span> GridBagConstraints();</span><br><span class="line">        <span class="comment">// 是用来控制添加进的组件的显示位置</span></span><br><span class="line">        constraint.fill = GridBagConstraints.BOTH;<span class="comment">// 使组件完全填满其显示区域</span></span><br><span class="line">        <span class="comment">//该方法是为了设置如果组件所在的区域比组件本身要大时的显示情况</span></span><br><span class="line">        <span class="comment">//NONE：不调整组件大小。</span></span><br><span class="line">        <span class="comment">//HORIZONTAL：加宽组件，使它在水平方向上填满其显示区域，但是不改变高度。</span></span><br><span class="line">        <span class="comment">//VERTICAL：加高组件，使它在垂直方向上填满其显示区域，但是不改变宽度。</span></span><br><span class="line">        <span class="comment">//BOTH：使组件完全填满其显示区域。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该方法是设置组件水平所占用的格子数，如果为0，就说明该组件是该行的最后一个</span></span><br><span class="line">        constraint.gridwidth = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 该方法设置组件水平的拉伸幅度，如果为0就说明不拉伸，不为0就随着窗口增大进行拉伸，0到1之间</span></span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 该方法设置组件垂直的拉伸幅度，如果为0就说明不拉伸，不为0就随着窗口增大进行拉伸，0到1之间</span></span><br><span class="line">        constraint.weighty = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置组件</span></span><br><span class="line">        layout.setConstraints(B1, constraint);</span><br><span class="line"></span><br><span class="line">        constraint.gridwidth = <span class="number">1</span>;</span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        constraint.weighty = <span class="number">0</span>;</span><br><span class="line">        layout.setConstraints(B2, constraint);</span><br><span class="line"></span><br><span class="line">        constraint.gridwidth = <span class="number">1</span>;</span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        constraint.weighty = <span class="number">0</span>;</span><br><span class="line">        layout.setConstraints(B3, constraint);</span><br><span class="line"></span><br><span class="line">        constraint.gridwidth = <span class="number">0</span>;<span class="comment">//该方法是设置组件水平所占用的格子数，如果为0，就说明该组件是该行的最后一个</span></span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不能为1，P1是占了4个格，并且可以横向拉伸，</span></span><br><span class="line">        <span class="comment">//但是如果为1，后面行的列的格也会跟着拉伸,导致B7所在的列也可以拉伸</span></span><br><span class="line">        <span class="comment">//所以应该是跟着TF1进行拉伸</span></span><br><span class="line">        constraint.weighty = <span class="number">0</span>;</span><br><span class="line">        layout.setConstraints(P1, constraint);<span class="comment">// 用Panel占空位置</span></span><br><span class="line"></span><br><span class="line">        constraint.gridwidth = <span class="number">2</span>;</span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        constraint.weighty = <span class="number">0</span>;</span><br><span class="line">        layout.setConstraints(C1, constraint);</span><br><span class="line">        ;</span><br><span class="line">        constraint.gridwidth = <span class="number">4</span>;</span><br><span class="line">        constraint.weightx = <span class="number">1</span>;</span><br><span class="line">        constraint.weighty = <span class="number">0</span>;</span><br><span class="line">        layout.setConstraints(TF1, constraint);</span><br><span class="line">        ;</span><br><span class="line">        constraint.gridwidth = <span class="number">0</span>;</span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        constraint.weighty = <span class="number">0</span>;</span><br><span class="line">        layout.setConstraints(B7, constraint);</span><br><span class="line">        ;</span><br><span class="line">        constraint.gridwidth = <span class="number">2</span>;</span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        constraint.weighty = <span class="number">1</span>;</span><br><span class="line">        layout.setConstraints(L1, constraint);</span><br><span class="line">        ;</span><br><span class="line">        constraint.gridwidth = <span class="number">5</span>;</span><br><span class="line">        constraint.weightx = <span class="number">0</span>;</span><br><span class="line">        constraint.weighty = <span class="number">1</span>;</span><br><span class="line">        layout.setConstraints(TA1, constraint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应事件-Event">响应事件 Event</h2>
<p>连续显示：先getText、再+新的文本一起set回去</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常用功能2</title>
    <url>/2018/12/21/Java/Java%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A32/</url>
    <content><![CDATA[<h1>Java常用功能详解2</h1>
<h2 id="Java中时间的测量">Java中时间的测量</h2>
<p>实例：测试ArrayList和LinkedList在读写遍历中的性能差异</p>
<ul>
<li>long startTime1 = System.nanoTime();    //获取开始时间</li>
<li>干点事情</li>
<li>long endTime1 = System.nanoTime();    //获取结束时间</li>
<li>System.out.println(“ArrayList的add程序运行时间：” + (endTime1 - startTime1) + “ns”);</li>
</ul>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benchmark</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> runTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; intArrayList;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LinkedList&lt;Integer&gt; intLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        runTime = <span class="number">100_000</span>;</span><br><span class="line">        intArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        intLinkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">/*********************************************************/</span></span><br><span class="line">        <span class="keyword">long</span> startTime1 = System.nanoTime();    <span class="comment">//获取开始时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; runTime; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            intArrayList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime1 = System.nanoTime();    <span class="comment">//获取结束时间</span></span><br><span class="line">        <span class="comment">// 输出程序运行时间</span></span><br><span class="line">        System.out.println(<span class="string">"ArrayList的add程序运行时间："</span> + (endTime1 - startTime1) + <span class="string">"ns"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO&amp;File</title>
    <url>/2018/12/21/Java/IO%20&amp;%20File/</url>
    <content><![CDATA[<h1>IO &amp; File</h1>
<h2 id="Java-语言的IO类库">Java 语言的IO类库</h2>
<p>必须借助输入输出包java.ios，实现输入输出和文件操作</p>
<h3 id="流的概念">流的概念</h3>
<ul>
<li>
<p>从内容划分，字节流和字符流</p>
<ol>
<li>
<p>字节流处理字节数据，基本类型为：InputStream和OutputStream</p>
<p>处理图片、视频、音频、.class文件等二进制数据（不能被解释为字符），也可以处理文本文件</p>
</li>
<li>
<a id="more"></a>
</li>
</ol>
</li>
<li>
<p>从传输方向，输入流和输出流</p>
</li>
<li>
<p>流 即为位组合或字符构成的序列</p>
</li>
</ul>
<h4 id="输入输出流">输入输出流</h4>
<ul>
<li>文件属于外设或外存</li>
<li>使程序的输入输出独立于相关设备，增强可移植性</li>
<li>沿着数据序列顺序进行</li>
</ul>
<h4 id="缓冲流">缓冲流</h4>
<p>为一个流配备一个缓冲区（专门用来传送数据的一块内存）</p>
<p>读写都经过缓冲区过渡</p>
<ol>
<li>写数据时，缓冲区满时，将全部数据发送至相应外设</li>
<li>读数据时，缓冲区空时，读取尽可能多的数据填满缓冲区</li>
</ol>
<h3 id="使用InputStream和OutputStream">使用InputStream和OutputStream</h3>
<ul>
<li>InputStream常用方法P177</li>
<li>流中的方法都声明抛出异常，调用时必须try-catch，否则编译不能通过</li>
<li>fout = new FileOutputStream(“myfile.txt”);如果指定的文件不存在，创建新文件，若存在，则清楚源文件的内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//filename：App10_1.java       利用输入输出流读写文本文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App10_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 声明文件字节输入（出）流对象，完成与外设的连接</span></span><br><span class="line">    FileInputStream fin;</span><br><span class="line">    FileOutputStream fout;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 向文件中写</span></span><br><span class="line">      fin =<span class="keyword">new</span> FileInputStream(FileDescriptor.in);</span><br><span class="line">      fout =<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\cgj\\myfile.txt"</span>); </span><br><span class="line">      System.out.println(<span class="string">"请输入一串字符，并以 # 结束："</span>);</span><br><span class="line">      <span class="keyword">while</span> ((ch=(<span class="keyword">char</span>)fin.read())!=<span class="string">'#'</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        	fout.write(ch);</span><br><span class="line">      &#125;</span><br><span class="line">      fin.close();</span><br><span class="line">      fout.close();</span><br><span class="line">      System.out.println();</span><br><span class="line">      <span class="comment">// 向int变量写</span></span><br><span class="line">      fin=<span class="keyword">new</span> FileInputStream(<span class="string">"d:\\cgj\\myfile.txt"</span>);</span><br><span class="line">      fout=<span class="keyword">new</span> FileOutputStream(FileDescriptor.out);</span><br><span class="line">      <span class="keyword">while</span> (fin.available()&gt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        data=fin.read();</span><br><span class="line">        fout.write(data);</span><br><span class="line">      &#125;</span><br><span class="line">      fin.close();</span><br><span class="line">      fout.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(<span class="string">"文件没找到！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e)</span><br><span class="line">    &#123;  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Exception</title>
    <url>/2018/12/21/Java/Java%20Exception/</url>
    <content><![CDATA[<h1>Java Exception</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/21/Java/Java%20Exception/D:%5CDocuments%5C0%E9%87%8D%E8%A6%81%E5%9B%BE%EF%BC%81%EF%BC%81%EF%BC%81%5CJava%E5%BC%82%E5%B8%B8.png" alt="Java异常"></p>
<a id="more"></a>
<h2 id="异常处理的基本概念">异常处理的基本概念</h2>
<h3 id="错误的分类">错误的分类</h3>
<h4 id="性质">性质</h4>
<ol>
<li>
<p>语法错：（编译系统负责检测和报告）能给出错误的位置和性质，不能通过源代码到字节码的编译过程</p>
</li>
<li>
<p>语义错（运行错）：eg除数为零，变量赋值超出范围，下标越界，打开文件不存在，网络连接中断。</p>
<p>​				必须进行异常处理</p>
</li>
<li>
<p>逻辑错</p>
</li>
</ol>
<h4 id="严重程度">严重程度</h4>
<ol>
<li>错误（致命）：硬件或操作系统的错误。内存溢出，虚拟机错误（找不到.class文件，没有main方法）</li>
<li>异常：由异常处理代码调整程序运行方向</li>
</ol>
<h2 id="异常处理类">异常处理类</h2>
<ul>
<li>
<p>Error子类，定义了应用程序无法捕获的错误，由系统保留</p>
<ul>
<li>error类及其子类的对象，代表了程序运行时Java系统内部的错误（内存、栈溢出等）</li>
<li>由Java虚拟机生成并抛给系统，Java程序不对这种错误进行处理，必须交给操作系统处理</li>
</ul>
</li>
<li>
<p>Exception子类是给Java程序使用的，是用户能捕捉到的异常类型</p>
</li>
<li>
<p>程序对错误和异常的处理3种方式：</p>
<ol>
<li>error，不能处理</li>
<li>runtime 应当避免</li>
<li>非runtime异常，必须捕获</li>
</ol>
</li>
</ul>
<h2 id="异常的处理">异常的处理</h2>
<ul>
<li>
<p>runtime异常：程序终止在第一个异常，之后的程序无法运行，不希望这样</p>
</li>
<li>
<p>捕获异常的意义：接受和处理异常，不影响其他语句的执行</p>
</li>
</ul>
<h3 id="try-catch-finally语句">try-catch-finally语句</h3>
<ul>
<li>
<p><strong>try</strong> is used to monitor method invocation 要检查的语句序列（直接的throw 和 包含throw的方法）</p>
<ul>
<li>发生第一个异常之后，直接跳到catch，不再执行之后的语句</li>
</ul>
</li>
<li>
<p><strong>catch</strong> is used to catch thrown exceptions 异常发生的处理，紧跟在try后面</p>
<p>当catch中包含System.exit(0)时，程序直接终止</p>
</li>
<li>
<p><strong>finally</strong> is used for execute essential code –whether there are exceptions or not 一定会运行的语句块</p>
<p>为异常处理提供一个统一出口，统一管理程序状态，<strong>对一些资源做清理工作（关闭打开的文件）</strong></p>
</li>
<li>
<p>3个不能只有一个</p>
</li>
<li>
<pre><code class="language-Java">public void demo(String filename)
    {
        File file = new File(filename);
        FileInputStream fis = null;
        try
        {
            FileInputStream fis = new FileInputStream(f);
            int b = fis.read();
        } catch (IOException e)
        {
            System.out.println(e);
        } finally
        {
            try
            {
                if (fis != null)
                {
                    fis.close();
                }
            } catch (IOException e)
            {
                System.out.println(e);
            }
        }
    }
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 多异常处理</span><br><span class="line"></span><br><span class="line">- 一个try后紧跟若干个catch块实现</span><br><span class="line"></span><br><span class="line">- 认真设计catch的顺序</span><br><span class="line"></span><br><span class="line">  - 将较具体、较常见的放前面</span><br><span class="line">  - 若将catch子类异常语句块，写到了catch父类异常语句块的前面，编译不能通过</span><br><span class="line"></span><br><span class="line">- 异常类对象进入哪个catch：</span><br><span class="line"></span><br><span class="line">  1. catch这个异常类本身 </span><br><span class="line"></span><br><span class="line">  2. catch这个异常类的父类（所有的子类都是父类）</span><br><span class="line"></span><br><span class="line">- 所有catch都不能处理，程序自动流转到上层（如果上层也有try-catch块）</span><br><span class="line"></span><br><span class="line">- 如果全部不行，由java运行系统处理（一般终止程序），退出JVM返回到操作系统 </span><br><span class="line"></span><br><span class="line">## 抛出异常</span><br><span class="line"></span><br><span class="line">- 抛出系统已经定义好的异常没有太大意义，系统会自动抛出，只需要写catch</span><br><span class="line"></span><br><span class="line">  - 括号中加字符串，将会追加错误的详细描述或信息</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;Java</span><br><span class="line">    throw new IllegalArgumentException(&quot;&quot;);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>通常从代码中抛出的是自定义异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zhx</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> s =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s*=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//int m = Integer.parseInt(args[0]);</span></span><br><span class="line">            <span class="comment">//int m = Integer.parseInt("hahaha");</span></span><br><span class="line">            <span class="comment">//int m = Integer.parseInt("-1");</span></span><br><span class="line">            System.out.println(m+<span class="string">"!="</span>+multi(m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"命令行无参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"应输入一个整数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 输出异常的名称，如下</span></span><br><span class="line">            <span class="comment">// 出现的异常是：java.lang.IllegalArgumentException</span></span><br><span class="line">            System.out.println(<span class="string">"出现的异常是："</span>+e.toString());</span><br><span class="line">            e.printStackTrace();<span class="comment">// 输出当前异常对象的堆栈使用轨迹</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件操作的异常">文件操作的异常</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IODemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(String filename)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		File f = <span class="keyword">new</span> File(filename);</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">			<span class="keyword">int</span> b = fis.read();</span><br><span class="line">			fis.close();</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (IOException e)</span><br><span class="line">   	 	&#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps：为什么Java 是void main() 而c++ 是int main() ?</p>
<p>​	main函数可以向外抛异常，虚拟机接受？有异常机制</p>
<p><img src="/2018/12/21/Java/Java%20Exception/D:%5CDocuments%5C0%E9%87%8D%E8%A6%81%E5%9B%BE%EF%BC%81%EF%BC%81%EF%BC%81%5CFileException.png" alt="FileException"></p>
<h2 id="throw-and-throws">throw and throws</h2>
<ul>
<li><strong>所有声明都带 s：implements，throws，extends</strong></li>
<li><strong>throw</strong> throws exceptions in method body</li>
<li><strong>throws</strong> Declare Possible Exceptions，defines Exception Specification</li>
<li>异常的处理是强制的，声明throws异常列表后，必须处理（写相应的catch语句块）
<ul>
<li>error意味着程序必须结束，不能挽回（虚拟机无法提供资源，或崩溃）</li>
<li>有两个例外：
<ul>
<li>Runtime Exception：编译可以通过，尽量在调试中避免，不用try-catch-finally捕获他</li>
<li>Java编译器要求Java程序必须捕捉或声明所有的非运行时异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException, IllegalArgumentException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!file.exists())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"File Don't exist!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File is a Directory"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">       <span class="comment">//。。。</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Blabla"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Rethrow-Exceptions">Rethrow Exceptions</h2>
<p>向上抛出异常</p>
<p>大工程实用？显示每一层的路径</p>
<h2 id="自定义异常类">自定义异常类</h2>
<p>课本第169页</p>
<h3 id="创建步骤">创建步骤</h3>
<ol>
<li>
<p>确定继承自哪个父类（必须是Throwable的直接或间接子类）</p>
</li>
<li>
<p>定义属性和方法</p>
<ul>
<li>
<p>一般加入两个构造方法：无参的，和含String的</p>
</li>
<li>
<pre><code class="language-java">// 自定义异常父类
public class InvalidCarException extends Exception
{

}
// 自定义异常子类
public class InvalidCarPriceException extends InvalidCarException
{
    double price;
	// 异常子类也可以有构造函数
    InvalidCarPriceException(double p)
    {
        price = p;
    }

// toString()函数可重载
    public String toString()
    {
        return (&quot;错误的价格参数: &quot; + price);
    }
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">public class Car</span><br><span class="line">&#123;</span><br><span class="line">    int speed;</span><br><span class="line">    double regularPrice;</span><br><span class="line">    String color;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 父类构造方法抛出异常</span><br><span class="line">    Car(int speedVal, double priceVal, String colorVal) throws</span><br><span class="line">                                                        InvalidCarSpeedException,</span><br><span class="line">                                                        InvalidCarPriceException</span><br><span class="line">    &#123;</span><br><span class="line">        if (speedVal &lt; 0)	&#x2F;&#x2F; 注意不要把成员变量和参数写错!</span><br><span class="line">        &#123;</span><br><span class="line">            throw new InvalidCarSpeedException(speedVal);&#x2F;&#x2F; 抛出一个new出来的异常类的对象</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            speed &#x3D; speedVal;</span><br><span class="line">        &#125;</span><br><span class="line">        if (priceVal &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new InvalidCarPriceException(priceVal);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            regularPrice &#x3D; priceVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        color &#x3D; colorVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类的构造方法记得throws和父类相同的异常</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主类</span></span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            cars[<span class="number">0</span>] = <span class="keyword">new</span> Truck(<span class="number">100</span>, -<span class="number">5</span>, <span class="string">"Black"</span>, <span class="number">3000</span>);</span><br><span class="line">            cars[<span class="number">1</span>] = <span class="keyword">new</span> Truck(-<span class="number">1</span>, <span class="number">10000</span>, <span class="string">"Black"</span>, <span class="number">1000</span>);</span><br><span class="line">            cars[<span class="number">2</span>] = <span class="keyword">new</span> Ford(<span class="number">100</span>, <span class="number">10000</span>, <span class="string">"Black"</span>, <span class="number">3000</span>);</span><br><span class="line">            cars[<span class="number">3</span>] = <span class="keyword">new</span> Ford(<span class="number">100</span>, <span class="number">10000</span>, <span class="string">"Black"</span>, <span class="number">5000</span>);</span><br><span class="line">            cars[<span class="number">4</span>] = <span class="keyword">new</span> Sedan(<span class="number">100</span>, <span class="number">10000</span>, <span class="string">"Black"</span>, <span class="number">25</span>);</span><br><span class="line">            cars[<span class="number">5</span>] = <span class="keyword">new</span> Sedan(<span class="number">100</span>, <span class="number">10000</span>, <span class="string">"Black"</span>, <span class="number">19</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidCarException e)<span class="comment">// catch 异常类的对象</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用对象的.toString()方法打印异常信息</span></span><br><span class="line">            System.out.println(<span class="string">"自定义异常："</span> + e.toString() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承自">继承自</h3>
<ol>
<li>
<p>Exception为直接父类</p>
</li>
<li>
<p>某个已经存在的系统异常类</p>
</li>
<li>
<p>已经自定义的异常类</p>
</li>
</ol>
<h3 id="Exception-in-Overriding">Exception in Overriding</h3>
<ul>
<li>
<p>子类覆盖的函数抛出的<strong>异常范围不能扩大</strong>！</p>
<p>Remember the compatibility<br>
• the return type is reduced<br>
• the access control is enlarged<br>
• the exception type is reduced</p>
</li>
</ul>
<p>try 和 catch 作用域问题？</p>
<h3 id="Exception-Idioms（今后看）">Exception Idioms（今后看）</h3>
<ul>
<li>Use exceptions only for exceptional conditions</li>
<li>Use checked exceptions for recoverable conditions and runtime</li>
<li>exceptions for programming errors</li>
<li>Avoid unnecessary use of checked exceptions</li>
<li>Favor the use of standard Exceptions</li>
<li>Throw exceptions appropriate to the abstraction</li>
<li>Document all exceptions thrown by each method</li>
<li>Include failure-capture information in detail messages</li>
<li>Strive for failure atomicity</li>
<li>Don’t ignore exceptions</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构</title>
    <url>/2018/12/21/Java/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1>Java中栈的应用</h1>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack(栈)继承了Vector类，底层实现是数组。</span></span><br><span class="line"><span class="comment"> * 此处只介绍了Stack自己定义的方法,父类中的方法不再一一介绍。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个栈</span></span><br><span class="line">        Stack&lt;String&gt; stack;</span><br><span class="line">        <span class="comment">// 实例化栈变量</span></span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add方法向栈中添加元素,添加成功返回true</span></span><br><span class="line">        stack.add(<span class="string">"1"</span>);</span><br><span class="line">        stack.add(<span class="string">"2"</span>);</span><br><span class="line">        stack.add(<span class="string">"3"</span>);</span><br><span class="line">        stack.add(<span class="string">"4"</span>);</span><br><span class="line">        stack.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// push方法向栈中添加元素,返回结果是当前添加的元素</span></span><br><span class="line">        stack.push(<span class="string">"a"</span>);</span><br><span class="line">        stack.push(<span class="string">"b"</span>);</span><br><span class="line">        stack.push(<span class="string">"c"</span>);</span><br><span class="line">        stack.push(<span class="string">"d"</span>);</span><br><span class="line">        stack.push(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// push和add都是向栈中添加元素,底层实现也是一样的,都是先将Vector扩容,再添加</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************************************/</span></span><br><span class="line">        String pop = stack.pop();</span><br><span class="line">        System.out.println(pop); <span class="comment">// e</span></span><br><span class="line">        System.out.println(stack); <span class="comment">// [1, 2, 3, 4, 5, a, b, c, d]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************************************/</span></span><br><span class="line">        String peek = stack.peek();</span><br><span class="line">        System.out.println(peek); <span class="comment">// d</span></span><br><span class="line">        System.out.println(stack); <span class="comment">// [1, 2, 3, 4, 5, a, b, c, d]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isEmpty = stack.empty();</span><br><span class="line">        System.out.println(isEmpty); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************************************/</span></span><br><span class="line">        <span class="keyword">int</span> index = stack.search(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(index); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言类的特性</title>
    <url>/2018/12/21/Java/Java%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>Java语言类的特性</h1>
<h2 id="方法的重载（overload）">方法的重载（overload）</h2>
<p>不行：仅仅参数变量名不同 或者 仅仅返回值类型不同</p>
<h2 id="构造方法">构造方法</h2>
<p>不含返回值，概念不同于void，返回值的类型就是该类本身？</p>
<p>自定义构造函数override默认构造函数</p>
<a id="more"></a>
<h3 id="从一个构造方法调用另一个（private）构造方法">从一个构造方法调用另一个（private）构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    sout;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">private</span>) myClass(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    m_d = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Static">Static</h2>
<h3 id="static-method-field">static method/field</h3>
<ul>
<li>field/method未用static修饰，则称为<strong>实例成员</strong></li>
<li>static方法只能访问static方法或变量</li>
<li>静态<strong>变量</strong>（方法）的<strong>调用</strong>：类名.静态变量名（方法名）</li>
<li>static方法也可以用对象来调用</li>
<li>！static方法中<strong>不能有this和super</strong></li>
</ul>
<h4 id="Java虚拟机和main方法？P109">Java虚拟机和main方法？P109</h4>
<p>JVM需要在类外调用main方法，必须是public</p>
<p>又JVM运行时系统在开始执行一个程序前，并没有创建main所在类的对象，只能通过类名调用main()，必须是static</p>
<h3 id="static-初始化器（块）">static 初始化器（块）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对static field 进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="static初始化器和构造方法的差别">static初始化器和构造方法的差别</h4>
<ol>
<li>
<p>静态初始化器是对类本身进行初始化，构造方法是对每个新创建的对象初始化</p>
</li>
<li>
<p>前者不能由程序来调用，他是在所属类被加载入内存时由系统调用执行的（且仅在此执行一次）</p>
</li>
<li>
<p>前者不是方法，没有返回值等</p>
<p>ps：类是在第一次被使用的时候才被装载，不是在程序启动时就装载所有可能用到的类</p>
<p>​	如果有多个static初始化器，则顺序执行</p>
</li>
</ol>
<h4 id="执行顺序">执行顺序</h4>
<p><a href="https://blog.csdn.net/caomiao2006/article/details/51533382" target="_blank" rel="noopener">https://blog.csdn.net/caomiao2006/article/details/51533382</a></p>
<p>它们的初始化顺序以此是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器</p>
<h5 id="变量和初始化块之间的顺序">变量和初始化块之间的顺序</h5>
<p>静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。</p>
<h5 id="无继承：">无继承：</h5>
<p>静态变量<br>
静态初始化块<br>
变量<br>
初始化块<br>
构造器</p>
<h5 id="有继承：">有继承：</h5>
<p>父类–静态变量<br>
父类–静态初始化块<br>
<strong>子类–静态变量</strong><br>
<strong>子类–静态初始化块</strong><br>
父类–变量<br>
父类–初始化块<br>
父类–构造器<br>
子类–变量<br>
子类–初始化块<br>
子类–构造器</p>
<p>并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。</p>
<h2 id="对象的应用">对象的应用</h2>
<ul>
<li>
<p>对象也可以称为类类型的变量，实际为引用型</p>
</li>
<li>
<p>引用型的变量实际上保存的是对象在内存中的首地址（也称为对象的句柄）</p>
</li>
<li>
<p>引用变量可作为参数传递、作为方法的返回值</p>
</li>
</ul>
<h3 id="？比较两对象是否相等">？比较两对象是否相等</h3>
<ul>
<li>
<p>==</p>
</li>
<li>
<p>equals()方法？</p>
</li>
</ul>
<h3 id="类类型的数组">类类型的数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] per;</span><br><span class="line">per = <span class="keyword">new</span> Person[<span class="number">3</span>];</span><br><span class="line">per[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">25</span>);</span><br><span class="line">per[<span class="number">1</span>] = <span class="keyword">new</span> Person(<span class="string">"B"</span>,<span class="number">25</span>);</span><br><span class="line">per[<span class="number">2</span>] = <span class="keyword">new</span> Person(<span class="string">"C"</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>ps数组类型的使用</p>
<p><a href="http://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-array.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明数组变量</span></span><br><span class="line"><span class="comment">// 首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</span></span><br><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line"><span class="comment">// Java语言使用new操作符来创建数组，语法如下：</span></span><br><span class="line"></span><br><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"><span class="comment">// 上面的语法语句做了两件事：</span></span><br><span class="line"><span class="comment">// 一、使用 dataType[arraySize] 创建了一个数组。</span></span><br><span class="line"><span class="comment">// 二、把新创建的数组的引用赋值给变量 arrayRefVar。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组变量的声明，和创建数组可以用一条语句完成，如下所示：</span></span><br><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，你还可以使用如下的方式创建数组。</span></span><br><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure>
<p>pps：foreach</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ppps：数组作为参数或者返回值，详见类与对象笔记</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用功能1</title>
    <url>/2018/12/21/Java/Java%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Java常用功能详解</p>
<h2 id="Scanner">Scanner</h2>
<p>原文：<a href="https://blog.csdn.net/Megustas_JJC/article/details/68960433" target="_blank" rel="noopener">https://blog.csdn.net/Megustas_JJC/article/details/68960433</a></p>
<p><code>import java.util.Scanner</code></p>
<a id="more"></a>
<h3 id="关于nextInt-、next-和nextLine-的理解">关于nextInt()、next()和nextLine()的理解</h3>
<p><strong>nextInt(), nextDouble(), …:</strong></p>
<p>it only reads the int value, nextInt() places the cursor（光标） in the same line after reading the input.</p>
<p>（nextInt()只读取数值，剩下”\n”还没有读取，并将cursor放在本行中）</p>
<p><strong>next():</strong></p>
<p>read the input only till the space. It can’t read two words separated by space. Also, next() places the cursor in the same line after reading the input.</p>
<p>（next()只读空格之前的数据，并且cursor指向本行）<br>
next() 方法遇见第一个有效字符（非空格，非换行符）时，开始扫描，当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。</p>
<p><strong>nextLine():</strong></p>
<p>reads input including space between the words (that is, it reads till the end of line \n). Once the input is read, nextLine() positions the cursor in the next line.</p>
<p>nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。</p>
<h4 id="实例">实例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextTest</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String s1,s2;  </span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);  </span><br><span class="line">        System.out.print(<span class="string">"请输入第一个字符串："</span>);  </span><br><span class="line">        s1=sc.nextLine();  </span><br><span class="line">        System.out.print(<span class="string">"请输入第二个字符串："</span>);  </span><br><span class="line">        s2=sc.next();  </span><br><span class="line">        System.out.println(<span class="string">"输入的字符串是："</span>+s1+<span class="string">" "</span>+s2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>请输入第一个字符串：home<br>
请输入第二个字符串：work<br>
输入的字符串是：home work</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改程序</span></span><br><span class="line">s1=sc.next();  </span><br><span class="line">s2=sc.nextLine();</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>请输入第一个字符串：home<br>
请输入第二个字符串：输入的字符串是：home</p>
<h4 id="解析">解析</h4>
<p>​	可以看到，nextLine()自动读取了被next()去掉的Enter，作为他的结束符，所以没办法给s2从键盘输入值。</p>
<p>​	经过验证，我发现其他的next的方法，如double nextDouble() ， float nextFloat() ， int nextInt() 等与nextLine()连用时都存在这个问题。</p>
<p>​	解决的办法是：在每一个 next()、nextDouble() 、 nextFloat()、nextInt() 等语句之后加一个nextLine()语句，将被next()去掉的Enter结束符过滤掉。</p>
<p>ps：如果nextInt() 输入了String，会抛错误</p>
<h2 id="将String转换为int">将String转换为int</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = Integer.parseInt(<span class="string">"hahah"</span>);<span class="comment">// will throw NumberFormatException</span></span><br><span class="line"><span class="keyword">int</span> m = Integer.parseInt(<span class="string">"2"</span>);<span class="comment">// 正常</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行输入参数">命令行输入参数</h2>
<p>run-&gt;  edit configurations-&gt;  program arguments</p>
<h3 id="Java命令行的参数">Java命令行的参数</h3>
<p>1、什么是命令行的参数？</p>
<p>如: java Test1 365 156 “China”</p>
<p>注意：（以上Test1必须为主类，否则不能运行）</p>
<p>2、命令行的参数由谁来接收？</p>
<p>一个程序开始于对函数main()的调用。在这样做的时候，有两个参数被送给main(),</p>
<p>其中的一个描述了命令行参数的个数，通常称为argc；另一个是命令行参数的数组，通常称为argv。（C语言中，标准的main函数就是这样的）</p>
<p>命令行参数都是字符串，所以argv的类型是char* [argc+1]。该程序的名字也作为argv[0]传进来，</p>
<p>所以argc的值至少是1。这个参数的表总以0结束，也就是说，argv[argc]==0。[1]</p>
<p>3、在命令行给定参数时，应注意什么？</p>
<p>命令行的参数以空格隔开。但是，若命令行的参数本身包含空格时，则</p>
<p>该参数必须用一对双引号括起来。</p>
<p>如: java Test1 365 156 China “Beijing of China”</p>
<p>4、命令行中输入*（表示乘法）的方法：若直接在命令行中输入*（乘法），系统会处理成当前路径名的几个字符串，若要<em>表示乘法，应该输入“ <em>”或“ * ”，由args取得该字符串后，再用trim()去掉两端空格即可，当然也可输入“#</em>”，然后再想办法去掉前面的#即可，即只要不单独输入</em>即可。</p>
<p>5、Total Commander启动时可以把一个或两个文件夹做为命令行参数。这些文件夹用来设置一侧或两侧的文件窗口。这样你可以在程序或启动菜单为Total Commander创建多个图标，每个Total Commander启动后打开不同文件夹甚至压缩包。而且可以指定不同的ini文件，不止默认的wincmd.ini，这样同一机器上的不同用户可以拥有不同的设置。作者：奋斗的小程序员<br>
来源：CSDN<br>
原文：<a href="https://blog.csdn.net/sum_tw/article/details/55820376" target="_blank" rel="noopener">https://blog.csdn.net/sum_tw/article/details/55820376</a></p>
<h2 id="获得字符串某一位的字符">获得字符串某一位的字符 &amp;</h2>
<h2 id="判断字符包含内容是否为数字">判断字符包含内容是否为数字</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"12haha"</span>;</span><br><span class="line">        <span class="keyword">char</span> ch1 = str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> ch2 = str.charAt(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(ch1))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(ch1 + <span class="string">" is Digit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(ch2))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(ch2 + <span class="string">" is NOT Digit"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>1 is Digit<br>
a is NOT Digit</p>
<h2 id="如何输出一个对象">如何输出一个对象</h2>
<p>重载toString()函数</p>
<h2 id="用EOFException？读到文件结尾后">用EOFException？读到文件结尾后</h2>
<h2 id="相对路径">相对路径</h2>
<p>在project中，相对路径的根目录是project的根文件夹（IdeaProject文件夹）</p>
<p>相对路径用  …/ 来表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"../exp6/exp6_score.txt"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2018/12/21/Java/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1>泛型</h1>
<p>java不允许从父类用（）强制转换为子类：会抛出ClassCastException</p>
<h2 id="泛型的符号表示">泛型的符号表示</h2>
<ul>
<li>E：element</li>
<li>K：key</li>
<li>N：number</li>
<li>T：type</li>
<li>V：value</li>
<li>SUV：第2，3，4个种类</li>
</ul>
<a id="more"></a>
<h2 id="类型可以出2现的地方">类型可以出2现的地方</h2>
<ul>
<li>类变量</li>
<li>局部变量</li>
<li>参数</li>
<li>返回值</li>
</ul>
<h2 id="通配符？">通配符？</h2>
<h3 id="有上界">有上界</h3>
<p>List<Integer>不是List<Number>的子类</Number></Integer></p>
<p>解决：用List&lt;? extends Number&gt;</p>
<h3 id="有下界">有下界</h3>
<? super XXX>

### 无边界

<?>
<h1>泛型的应用实例</h1>
<h2 id="普通泛型">普通泛型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T是type的简称</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;    <span class="comment">// var的类型由T指定，即：由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 返回值的类型由外部决定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 设置的类型也由外部决定</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 里面的var类型为String类型</span></span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> Point&lt;String&gt;();</span><br><span class="line">        p.setVar(<span class="string">"it"</span>);<span class="comment">// 设置字符串</span></span><br><span class="line">       	<span class="comment">// 取得字符串的长度</span></span><br><span class="line">        System.out.println(p.getVar().length()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment">// 此处指定了两个泛型类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;      <span class="comment">// 此变量的类型由外部决定</span></span><br><span class="line">    <span class="keyword">private</span> V value;    <span class="comment">// 此变量的类型由外部决定</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 定义两个泛型类型的对象</span></span><br><span class="line">        Notepad&lt;String, Integer&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 里面的key为String，value为Integer</span></span><br><span class="line">        t = <span class="keyword">new</span> Notepad&lt;String, Integer&gt;();</span><br><span class="line">        t.setKey(<span class="string">"汤姆"</span>);     <span class="comment">// 设置第一个内容</span></span><br><span class="line">        t.setValue(<span class="number">20</span>);     <span class="comment">// 设置第二个内容</span></span><br><span class="line">        <span class="comment">// 取得信息</span></span><br><span class="line">        System.out.print(<span class="string">"姓名；"</span> + t.getKey());</span><br><span class="line">        <span class="comment">// 取得信息</span></span><br><span class="line">        System.out.print(<span class="string">"，年龄；"</span> + t.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通配符泛型">通配符泛型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;        <span class="comment">// 定义泛型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Info&lt;String&gt; i = <span class="keyword">new</span> Info&lt;String&gt;();        <span class="comment">// 使用String为泛型类型</span></span><br><span class="line">        i.setVar(<span class="string">"it"</span>);                            <span class="comment">// 设置内容</span></span><br><span class="line">        fun(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以接收任意的泛型对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;?&gt; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"内容："</span> + temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="受限泛型">受限泛型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;        <span class="comment">// 定义泛型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">        Info&lt;Integer&gt; i1 = <span class="keyword">new</span> Info&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 声明Float的泛型对象</span></span><br><span class="line">        Info&lt;Float&gt; i2 = <span class="keyword">new</span> Info&lt;Float&gt;();</span><br><span class="line">        <span class="comment">// 设置整数，自动装箱</span></span><br><span class="line">        i1.setVar(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 设置小数，自动装箱</span></span><br><span class="line">        i2.setVar(<span class="number">30.1f</span>);</span><br><span class="line">        fun(i1);</span><br><span class="line">        fun(i2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;? extends Number&gt; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 只能接收Number及其Number的子类</span></span><br><span class="line">        System.out.print(temp + <span class="string">"、"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;        <span class="comment">// 定义泛型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;();        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">new</span> Info&lt;Object&gt;();        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.setVar(<span class="string">"hello"</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        i2.setVar(obj);</span><br><span class="line">        fun(i1);</span><br><span class="line">        fun(i2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;? <span class="keyword">super</span> String&gt; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 只能接收String或String以上的类型（Object）的泛型</span></span><br><span class="line">        System.out.println(temp + <span class="string">"、"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="泛型无法向上转型">泛型无法向上转型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;        <span class="comment">// 定义泛型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 泛型类型为String</span></span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;();</span><br><span class="line">        Info&lt;String&gt; i3 = <span class="keyword">new</span> Info&lt;String&gt;();</span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">null</span>;</span><br><span class="line">        i2 = i1;<span class="comment">//这句会出错 incompatible types</span></span><br><span class="line">        i1 = i2;<span class="comment">//这句也会出错 incompatible type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口">泛型接口</h2>
<h3 id="泛型类实现泛型接口">泛型类实现泛型接口</h3>
<p>class InfoImpl<T> implements Info<T>；</T></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>;    <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;    <span class="comment">// 定义 实验泛型接口 的泛型类</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;<span class="comment">// 定义属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        <span class="comment">// 通过构造方法设置属性内容</span></span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现了接口中的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Info&lt;String&gt; i = <span class="keyword">null</span>;        <span class="comment">// 声明接口对象</span></span><br><span class="line">        i = <span class="keyword">new</span> InfoImpl&lt;String&gt;(<span class="string">"汤姆"</span>);    <span class="comment">// 通过子类实例化对象</span></span><br><span class="line">        System.out.println(<span class="string">"内容："</span> + i.getVar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通类实现特定类型的泛型接口">普通类实现特定类型的泛型接口</h3>
<p>class InfoImpl implements Info<String></String></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;        <span class="comment">// 在接口上定义泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>;    <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span> <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="keyword">var</span>;   <span class="comment">// 定义属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(String <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        <span class="comment">// 通过构造方法设置属性内容</span></span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(String <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arsg[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Info i = <span class="keyword">null</span>;        <span class="comment">// 声明接口对象</span></span><br><span class="line">        i = <span class="keyword">new</span> InfoImpl(<span class="string">"汤姆"</span>);    <span class="comment">// 通过子类实例化对象</span></span><br><span class="line">        System.out.println(<span class="string">"内容："</span> + i.getVar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法">泛型方法</h2>
<p>自动包装和解包功能，30自动包装成new Integer (25)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">fun</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        String str = d.fun(<span class="string">"汤姆"</span>); <span class="comment">//    传递字符串</span></span><br><span class="line">        <span class="comment">// 也可以在泛型方法前面加&lt;&gt;强调是泛型方法</span></span><br><span class="line">        <span class="comment">// String str = d.&lt;String&gt;fun("汤姆");</span></span><br><span class="line">        <span class="keyword">int</span> i = d.fun(<span class="number">30</span>);        <span class="comment">// 传递数字，自动装箱</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过泛型方法返回泛型类型实例？？">通过泛型方法返回泛型类型实例？？</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;    <span class="comment">// 指定上界，只能是Number或者他的子类</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">// 覆写Object类中的toString()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i = fun(<span class="number">30</span>);</span><br><span class="line">        System.out.println(i.getVar());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 方法中传入或返回的泛型类型由调用方法时所设置的参数类型决定</span></span><br><span class="line">    <span class="comment">// public static + &lt;T&gt; + 返回值类型 + 方法名(T 参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function">Info&lt;T&gt; <span class="title">fun</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Info&lt;T&gt; temp = <span class="keyword">new</span> Info&lt;T&gt;(); <span class="comment">// 根据传入的数据类型实例化Info</span></span><br><span class="line">        temp.setVar(param); <span class="comment">// 将传递的内容设置到Info对象的var属性之中</span></span><br><span class="line">        <span class="keyword">return</span> temp;<span class="comment">// 返回实例化对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="使用泛型统一传入的参数类型">使用泛型统一传入的参数类型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;    <span class="comment">// 指定上限，只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;        <span class="comment">// 此类型由外部决定</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;        <span class="comment">// 覆写Object类中的toString()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;();</span><br><span class="line">        Info&lt;String&gt; i2 = <span class="keyword">new</span> Info&lt;String&gt;();</span><br><span class="line">        i1.setVar(<span class="string">"HELLO"</span>);        <span class="comment">// 设置内容</span></span><br><span class="line">        i2.setVar(<span class="string">"汤姆"</span>);        <span class="comment">// 设置内容</span></span><br><span class="line">        add(i1, i2);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 使用泛型统一传入的参数类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Info&lt;T&gt; i1, Info&lt;T&gt; i2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(i1.getVar() + <span class="string">" "</span> + i2.getVar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="泛型数组">泛型数组</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer i[] = fun1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);    <span class="comment">// 返回泛型数组</span></span><br><span class="line">        fun2(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun1(T... arg)</span><br><span class="line">    &#123;    <span class="comment">// 接收可变参数</span></span><br><span class="line">        <span class="keyword">return</span> arg;            <span class="comment">// 返回泛型数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(T param[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 输出</span></span><br><span class="line">        System.out.print(<span class="string">"接收泛型数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (T t : param)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(t + <span class="string">"、"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可变参数">可变参数</h3>
<p>有些方法的语义要求它们必须能接受个数可变的实参——例如著名的main方法，就需要能接受所有的命令行参数为实参，而命令行参数的数目，事先根本无法确定下来。对于这个问题，传统上一般是采用“利用一个数组来包裹要传递的实参”的做法来应付。大体说来，“<strong>Varargs</strong>”是“variable number of arguments”的意思。</p>
<ul>
<li>若除了可变长参数还有其它参数，可变长参数一定要放在最后</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//求若干个整型数中的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>... items)</span><span class="comment">//定义可变参数items</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// max默认值为int能表示的最小值，值为-2147483648</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : items)</span><br><span class="line">        &#123;</span><br><span class="line">            max = item &gt; max ? item : max;<span class="comment">//取大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回比number大的数的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLagerNum</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span>... items)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  	<span class="comment">// 若除了可变长参数还有其它参数，可变长参数一定要放在最后</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : items)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (item &gt; number)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Demo vp = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(<span class="string">"最大值："</span> + vp.getMax());  <span class="comment">//可以不写参数</span></span><br><span class="line">        System.out.println(<span class="string">"最大值："</span> + vp.getMax(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>));  <span class="comment">//可以在参数中直接写入若干个参数</span></span><br><span class="line">        System.out.println(<span class="string">"最大值："</span> + vp.getMax(-<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>));        <span class="comment">//可以在参数中直接写入若干个参数</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"比number大的数的个数："</span> + vp.getLagerNum(<span class="number">9</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">14</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">21</span>));  <span class="comment">//9为number，后边的是items</span></span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">14</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">21</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"比number大的数的个数："</span> + vp.getLagerNum(<span class="number">9</span>, a));     <span class="comment">//items也可以用数组替代</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大值：-2147483648</span></span><br><span class="line"><span class="comment">最大值：7</span></span><br><span class="line"><span class="comment">最大值：5</span></span><br><span class="line"><span class="comment">比number大的数的个数：3</span></span><br><span class="line"><span class="comment">比number大的数的个数：3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//原文：https://blog.csdn.net/u013007900/article/details/79334017</span></span><br></pre></td></tr></table></figure>
<h2 id="泛型的嵌套设置">泛型的嵌套设置</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的set、get函数，以及对应的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;  	<span class="comment">// 接收两个泛型类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(T <span class="keyword">var</span>, V value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">this</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的set、get函数，以及对应的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> S info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(S info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setInfo(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(S info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">getInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将Info作为Demo的泛型类型</span></span><br><span class="line">        Demo&lt;Info&lt;String, Integer&gt;&gt; d = <span class="keyword">null</span>;</span><br><span class="line">        Info&lt;String, Integer&gt; i = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        i = <span class="keyword">new</span> Info&lt;String, Integer&gt;(<span class="string">"汤姆"</span>, <span class="number">30</span>);</span><br><span class="line">        d = <span class="keyword">new</span> Demo&lt;Info&lt;String, Integer&gt;&gt;(i);<span class="comment">// 在Demo类中设置Info类的对象</span></span><br><span class="line">        System.out.println(<span class="string">"内容一："</span> + d.getInfo().getVar());</span><br><span class="line">        System.out.println(<span class="string">"内容二："</span> + d.getInfo().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1>多线程</h1>
<h2 id="并发和并行区别">并发和并行区别</h2>
<p>并发（concurrency），并行（parallelism）</p>
<p><a href="https://blog.csdn.net/weixin_30363263/article/details/80732156" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30363263/article/details/80732156</a></p>
<a id="more"></a>
<h3 id="例子一：">例子一：</h3>
<p>假设一个有三个学生需要辅导作业，帮每个学生辅导完作业是一个任务</p>
<p>顺序执行：老师甲先帮学生A辅导，辅导完之后再取给B辅导，最后再去给C辅导，效率低下 ，很久才完成三个任务</p>
<p>并发：老师甲先给学生A去讲思路，A听懂了自己书写过程并且检查，而甲老师在这期间直接去给B讲思路，讲完思路再去给C讲思路，让B自己整理步骤。这样老师就没有空着，一直在做事情，很快就完成了三个任务。与顺序执行不同的是，顺序执行，老师讲完思路之后学生在写步骤，这在这期间，老师是完全空着的，没做事的，所以效率低下。</p>
<p>并行：直接让三个老师甲、乙、丙三个老师“同时”给三个学生辅导作业，也完成的很快。</p>
<h3 id="例子二：">例子二：</h3>
<p>顺序执行：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</p>
<p>并发：你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</p>
<p>并行：你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。此处注意理解：是同时吃，同时说，要真严格的说的话，需要2张嘴才是并行。。</p>
<ul>
<li>
<p>并发的关键是你有处理多个任务的能力，<strong>不一定要同时</strong>。</p>
</li>
<li>
<p>并行的关键是你有<strong>同时处理多个任务</strong>的能力。</p>
</li>
</ul>
<p>所以我认为它们最关键的点就是：是否是『同时』。</p>
<h3 id="理解">理解</h3>
<p>（1）并行是指两个或者多个事件在<strong>同一时刻</strong>发生；而并发是指两个或多个事件在同一时间间隔发生。</p>
<p>（2）并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</p>
<p>（3）在一台处理器上“同时”（这个“同时”实际上是“交替”）处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</p>
<p>普通解释：</p>
<p>并发：交替做不同事情的能力</p>
<p>并行：同时做不同事情的能力</p>
<p>专业术语：</p>
<p>并发：不同的代码块交替执行</p>
<p>并行：不同的代码块同时执行</p>
<h3 id="总结：">总结：</h3>
<ul>
<li>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。</li>
<li>如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。</li>
</ul>
<p>并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。</p>
<p>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。</p>
<p>如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p>
<p>我相信你已经能够得出结论——<strong>“并行”概念是“并发”概念的一个子集</strong>。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p>
<p><strong>并发就是指代码逻辑上可以并行，有并行的潜力，但是不一定当前是真的以物理并行的方式运行。并发指的是代码的性质，并行指的是物理运行状态。</strong></p>
<p>顾名思义，并发强调的是一起出发，并行强调的是一起执行。<strong>并发的反义是顺序，并行的反义是串行。并发并行并不是互斥概念，只不过并发强调任务的抽象调度，并行强调任务的实际执行。</strong></p>
<h2 id="并发、并行、串行的区别">并发、并行、串行的区别</h2>
<ul>
<li>
<p>并发执行：单处理器上，同一时刻只能执行一个代码（微观串行，宏观并行）</p>
</li>
<li>
<p>并行执行：同一时刻有多个代码在处理器上执行</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>并发是指多个线程轮流执行（单核CPU）；</li>
<li>并行是指多个线程同时执行（多核CPU），微观上是同时的；</li>
<li>串行是指一个一个的执行，处理完一个才能处理下一个，不轮换；</li>
</ul>
<h2 id="课件上其他">课件上其他</h2>
<ul>
<li>所有进程都有一个main线程，main线程是进程的第一个线程。</li>
<li>进程中有main方法，作为进程的起点；线程中有run方法，作为线程的起点</li>
</ul>
<p><img src="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5C%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg" alt="多线程"></p>
<h2 id="Java线程具有五种基本状态">Java线程具有五种基本状态</h2>
<p>**新建状态（New）：**当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>
<p>**就绪状态（Runnable）：**当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
<p><strong>运行状态（Running）：<strong>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是</strong>进入到运行状态的唯一入口</strong>，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
<p>**阻塞状态（Blocked）：**处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<p>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>
<p>2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
<p>3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
<p>**死亡状态（Dead）：**线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<h2 id="Java多线程的创建及启动">Java多线程的创建及启动</h2>
<h3 id="1-继承Thread类，重写该类的run-方法">1.继承Thread类，重写该类的run()方法</h3>
<p>run方法需要重写，因为Thread基类的run函数什么都不做</p>
<p>main方法是进程的入口，run方法是线程的入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 定义线程的引用</span></span><br><span class="line">                Thread myThread1 = <span class="keyword">new</span> MyThread();     <span class="comment">// 创建一个新的线程  myThread1  此线程进入新建状态</span></span><br><span class="line">                Thread myThread2 = <span class="keyword">new</span> MyThread();     <span class="comment">// 创建一个新的线程 myThread2 此线程进入新建状态</span></span><br><span class="line">                myThread1.start();                     <span class="comment">// 调用start()方法使得线程进入就绪状态</span></span><br><span class="line">                myThread2.start();                     <span class="comment">// 调用start()方法使得线程进入就绪状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread。</p>
<p>其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。</p>
<p>通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。</p>
<h3 id="2-实现Runnable接口，并重写该接口的run-方法">2.实现Runnable接口，并重写该接口的run()方法</h3>
<p>背景：如果一个类继承了Thread，那么他将不能继承别的类。如果实现Runnable接口，并赋给thread类，那么这个类还可以继承别的类</p>
<p>该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Runnable myRunnable = <span class="keyword">new</span> MyRunnable(); <span class="comment">// 创建一个Runnable实现类的对象</span></span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(myRunnable); <span class="comment">// 将myRunnable作为Thread target创建新的线程</span></span><br><span class="line">                Thread thread2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">                thread1.start(); <span class="comment">// 调用start()方法使得线程进入就绪状态</span></span><br><span class="line">                thread2.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Thread和Runnable之间关系">Thread和Runnable之间关系</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Runnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">                <span class="comment">// Thread thread1 = new Thread(myRunnable);第二种方法创建线程的语句</span></span><br><span class="line">                Thread thread = <span class="keyword">new</span> MyThread(myRunnable);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in MyRunnable run"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in MyThread run"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，与实现Runnable接口创建线程方式相似，不同的地方在于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> MyThread(myRunnable);</span><br></pre></td></tr></table></figure>
<p>那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？</p>
<p>通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下Thread类中对Runnable接口中run()方法的实现：</p>
<p>什么都没做，所以需要重写/或者实现Runnable接口中run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	<span class="keyword">if</span> (target != <span class="keyword">null</span>)</span><br><span class="line">   	&#123;</span><br><span class="line">     	target.run();</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，当执行到Thread类中的run()方法时，（前提是MyThread子类没有重写run方法）会首先判断target是否存在，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。</p>
<p>但是上述给到的列子中，由于<strong>多态</strong>的存在，根本就没有执行到Thread类中的run()方法，而是直接先执行了运行时类型即MyThread类中的run()方法。</p>
<h2 id="Java多线程的就绪、运行和死亡状态">Java多线程的就绪、运行和死亡状态</h2>
<p>就绪状态转换为运行状态：当此线程得到处理器资源；</p>
<p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p>
<p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p>
<p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p>
<p>由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                myRunnable.stopThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> &amp;&amp; !stop; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java多线程的阻塞状态与线程控制">Java多线程的阻塞状态与线程控制</h2>
<p>上文已经提到Java阻塞的几种具体类型。下面分别看下引起Java线程阻塞的主要方法。</p>
<p><img src="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5C%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="线程的状态"></p>
<h3 id="1-join">1.join()</h3>
<ul>
<li>join —— 让一个线程等待另一个线程完成才继续执行</li>
<li>用来管理资源</li>
<li>会抛出被打断异常InterruptedException</li>
<li>重载形式
<ul>
<li>join() : wait until the thread terminated</li>
<li>join(long millis) : wait until the thread terminated or wait after millisecond time</li>
</ul>
</li>
</ul>
<h4 id="一个例子：">一个例子：</h4>
<p>如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，知道B线程执行完为止，A才能得以继续执行。</p>
<p>某个线程B加入，代表调用B的线程需要等待B执行完毕才可以继续</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                thread.start();</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// main线程需要等待thread线程执行完后才能继续执行</span></span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="另一个例子：">另一个例子：</h4>
<p><img src="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5Cjoin%E4%BE%8B%E5%AD%901.bmp" alt="join例子1"></p>
<p>如果不加join，可能出现：在t线程仍然在使用文件输入流fis时，main线程已经把他关闭了</p>
<p><img src="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5Cjoin%E4%BE%8B%E5%AD%902.bmp" alt="join例子2"></p>
<h3 id="2-sleep">2.sleep()</h3>
<ul>
<li>sleep —— 让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。</li>
<li>sleep()方法常用来暂停线程执行。</li>
<li>在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，处于sleep()中的线程也不会执行。</li>
<li>前面有讲到，当调用了新建的线程的start()方法后，线程进入到就绪状态，可能会在接下来的某个时间获取CPU时间片得以执行，如果希望这个新线程必然性的立即执行，直接调用原来线程的sleep(10)即可。</li>
<li>sleep可能抛出被打断的异常  InterruptedException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                thread.start();</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 紧跟在thread.start();的后面</span></span><br><span class="line">                    <span class="comment">// 使得thread必然能够马上得以执行</span></span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Interrupt">2.5.Interrupt()</h3>
<p>Blocked，TimedWaiting，Waiting都可以被打断</p>
<h4 id="interrupt">interrupt()</h4>
<p>A.interrupt()，把A线程强行中断</p>
<ul>
<li>Interrupts this thread.</li>
<li>cause the thread receives InterruptedException</li>
</ul>
<h4 id="interrupted">interrupted()</h4>
<ul>
<li>return boolean</li>
<li>Tests whether the current thread has been interrupted.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread started, sleep forever"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread interrupted"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"continue sleeping 3s"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Main started, wait 5s"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InterruptDemo());</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            t.interrupt();</span><br><span class="line">            <span class="comment">// 等待t线程结束，main线程才继续执行</span></span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ignored)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Main ended"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="t-interrupt-的问题">t.interrupt()的问题</h4>
<ul>
<li>
<p>only work when t is in block/waiting/timed waiting state</p>
<p>或者是循环状态（while或者for）</p>
<ul>
<li>
<p>join</p>
</li>
<li>
<p>sleep</p>
</li>
</ul>
</li>
<li>
<p>if the thread is in running state</p>
<ul>
<li>
<p>the InterruptedException will not be throwed</p>
</li>
<li>
<p>the thread will checked the interrupted state by itself</p>
<p><strong>需手动写出来     !Thread.interrupted()</strong></p>
<p><strong>如果没有判断是否被打断，则不会中断循环，不会自己检测</strong></p>
</li>
</ul>
</li>
</ul>
<p>中断while，for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">// 检查自己是否被打断，需要手动写</span></span><br><span class="line">        <span class="keyword">while</span>(!Thread.interrupted())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被打断后，接下来的语句仍然会执行</span></span><br><span class="line">        System.out.println(<span class="string">"while is broken, continue"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Runnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 等待1 ms，如果thread1仍然没有结束，则强行打断他</span></span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查自己是否被打断，需要手动写</span></span><br><span class="line">        <span class="keyword">long</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果没有判断是否被打断，则不会终端循环</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">1000000000</span> &amp;&amp; !Thread.interrupted();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(<span class="string">"continue"</span>);</span><br><span class="line">        <span class="comment">// 被打断后，接下来的语句仍然会执行</span></span><br><span class="line">        System.out.println(<span class="string">"for is broken, continue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-线程让步：yield">5.线程让步：yield()</h3>
<p>上一篇博文中已经讲到了yield()的基本作用，同时，yield()方法还与线程优先级有关，当某个线程调用yiled()方法从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread myThread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        Thread myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        myThread1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        myThread2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"main thread i = "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                myThread1.start();</span><br><span class="line">                myThread2.start();</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"myThread 1 --  i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"myThread 2 --  i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全">线程安全</h2>
<p><a href="https://www.cnblogs.com/lwbqqyumidi/p/3821389.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwbqqyumidi/p/3821389.html</a></p>
<p>讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。</p>
<h3 id="例子一">例子一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// station实现runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Station</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    TicketVault vault;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Station</span><span class="params">(<span class="keyword">int</span> id, TicketVault vault)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = <span class="string">"Station "</span> + id;</span><br><span class="line">        <span class="keyword">this</span>.vault = vault;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (vault.sell(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">// 这个线程sell完一张票之后睡一下 </span></span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// yield 的效果不好</span></span><br><span class="line">                <span class="comment">//Thread.currentThread().yield();</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread[] stationArray = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        TicketVault vault = <span class="keyword">new</span> TicketVault();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用runnable接口初始化Thread类</span></span><br><span class="line">            stationArray[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Station(i, vault));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stationArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                stationArray[i].join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"All of the stations sold Out!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketVault</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numTicket = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sell</span><span class="params">(String station)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= numTicket)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(station + <span class="string">" sell "</span> + id + <span class="string">" ticket"</span>);</span><br><span class="line">            id++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子二">例子二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StationRight2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将一个Object类型的对象作为同步锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StationRight2</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = <span class="string">"Station "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &lt; <span class="number">200</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(name + <span class="string">" sell ticket "</span> + tickets++);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (sell())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">"sold out"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread[] stationArray = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stationArray[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> StationRight2(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stationArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                stationArray[i].join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Sold Out!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二-同步方法">二.同步方法</h3>
<p>​	对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成<strong>对此方法进行了加锁</strong>，其<strong>锁对象为当前方法所在的对象自身</strong>。</p>
<p>🔒在哪里很关键！什么时候加锁</p>
<p>​	多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推…</p>
<p>​	在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在run()方法前加上synshronized关键字即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5C%E5%90%8C%E6%AD%A5%E9%94%81.png" alt="同步锁"></p>
<h3 id="三-同步代码块">三.同步代码块</h3>
<p>​	正如上面所分析的那样，解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现<strong>同步范围过大</strong>的情况。</p>
<p>于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。</p>
<p>同步代码块的格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)<span class="comment">// obj一般为this？</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是<strong>选择此共享资源对象作为锁对象</strong>。如上例中，最好选用account对象作为锁对象。</p>
<p>​	（当然，选用this也是可以的，那是因为创建线程使用了<strong>runnable</strong>方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…</p>
<p><img src="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%9D%971.png" alt="同步方法块1"></p>
<p><img src="/2018/12/21/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5Czhx%5CPictures%5CMD%E7%AC%94%E8%AE%B0%E5%9B%BE%5C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%9D%972.png" alt="同步方法块2"></p>
<p>不能对int等primitive加锁，但用Integer也不行。**改Integer、String的值，内容变化，reference也会变！**要抢同一把锁！</p>
<p>ps：如何加锁？类中设置static Object lock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成员变量中：</span></span><br><span class="line"><span class="keyword">static</span> Object lock;</span><br><span class="line"><span class="comment">// 方法中：</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五-wait-notify-notifyAll-线程通信">五.wait()/notify()/notifyAll()线程通信</h3>
<p>​	在博文<a href="http://www.cnblogs.com/lwbqqyumidi/p/3693015.html" target="_blank" rel="noopener">《Java总结篇系列：java.lang.Object》</a>中有提及到这三个方法，虽然这三个方法主要都是用于多线程中，但实际上都是Object类中的本地方法。</p>
<p>​	因此，理论上，任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信。</p>
<p>**wait()：**导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。</p>
<p>**notify()：**不会用，任意选择线程</p>
<p>唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p>
<p>**notifyAll()：**唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p>
<p>注意：用wait()部分用while</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">long</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(balance&lt;amount)<span class="comment">// 用wait()部分用while</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    balance -=amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试</title>
    <url>/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="类加载">类加载</h2>
<p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<ul>
<li>javac：将java源文件编译为.class字节码文件（javac是把你写的java代码编译成计算机能识别的内部代码）</li>
<li>java：把编译声称的.class文件交给Java虚拟机(JVM)执行（JVM初始化、加载.class、执行main()）</li>
</ul>
<p>而我们所说的类加载过程即是指<strong>JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程</strong>。</p>
<p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p>
<p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个<strong>需要运行的类时才会加载，且只加载一次</strong>。</p>
<a id="more"></a>
<h3 id="过程">过程</h3>
<p>类的生命周期：加载前还有编译</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/eaf81a4c510fd9f9a14099a4c13f2f2e2934a444.jpeg" alt="img"></p>
<p><strong>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段</strong>。</p>
<p>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。</p>
<p>另外注意这里的几个阶段是按顺序<strong>开始</strong>，而不是按顺序<strong>进行</strong>或<strong>完成</strong>，因为这些阶段通常都是<strong>互相交叉地混合进行</strong>的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h4 id="加载">加载</h4>
<p>简单来说，加载指的是把<strong>class字节码文件</strong>从各个来源通过类加载器<strong>装载入内存中</strong>。</p>
<p>这里有两个重点：</p>
<p><strong>字节码来源</strong>。</p>
<p>（1）本地磁盘（本地路径下编译生成的.class文件</p>
<p>（2）网上加载.class文件（Applet）</p>
<p>（3）从数据库中</p>
<p>（4）压缩文件中的.class文件（ZAR，jar等）</p>
<p>（5）从其他文件生成的（JSP应用）</p>
<p>（6）从远程网络，以及动态代理实时编译</p>
<p><strong>类加载器</strong>。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。</p>
<p>注：为什么会有自定义类加载器？</p>
<p>一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。</p>
<p>另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。</p>
<h4 id="验证">验证</h4>
<p>主要是为了保证<strong>加载进来的字节流符合虚拟机规范</strong>，不会造成安全错误。</p>
<ol>
<li>
<p>对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
</li>
<li>
<p>对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
</li>
<li>
<p>对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。</p>
</li>
<li>
<p>对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
</li>
</ol>
<h4 id="准备">准备</h4>
<p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。</p>
<p>特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的<strong>默认初始值</strong>。</p>
<p>比如8种基本类型的初值，默认为0；</p>
<p>引用类型的初值则为null；</p>
<p>常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456</p>
<h4 id="解析">解析</h4>
<p>将常量池内的符号引用替换为直接引用的过程。</p>
<p>两个重点：</p>
<p>符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</p>
<p>直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量</p>
<p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
<p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h4 id="初始化">初始化</h4>
<p>这个阶段主要是对类变量初始化，是执行类构造器的过程。</p>
<p>换句话说，只对static修饰的变量或语句进行初始化。</p>
<p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
<p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<h4 id="总结">总结</h4>
<p>类加载过程只是一个类生命周期的一部分，在其前，有<strong>编译</strong>的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的<strong>类使用</strong>过程，当使用完成之后，还会在方法区垃圾<strong>回收</strong>的过程中进行卸载。如果想要了解Java类整个生命周期的话，可以自行上网查阅相关资料，这里不再多做赘述。</p>
<h2 id="命令行参数args">命令行参数args</h2>
<p>String args[ ]或者String[ ] args表示给主方法传一个字符串数组。而args是一个字符串数组的变量名，不是关键字，是arguments的缩写，只是一个默认名，一般都习惯性照写，也可以用别的名字。</p>
<p>String[] args是main函数的形式参数，可以用来获取命令行用户输入进去的参数。如果你是java的初学者，编写一些简单的小程序是用不到它的，但是你在写程序的时候不管用的到用不到，声明main函数的时候一定要在括号里写上它，否则会报错。</p>
<p>命令行传参方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java helloworld arg0 arg1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面两个字符串随便写什么，它们作为实参传入main函数，arg0传入args[0]，arg1传入args[1]。</span></span><br></pre></td></tr></table></figure>
<p>这和在main函数里调用其他函数并且向被调用函数传递参数是一样的道理，只不过传给main函数罢了。</p>
<h2 id="JVM">JVM</h2>
<p>当我们调用 Java 命令运行<strong>某个 Java 程序</strong>时，该命令将会启动<strong>一条 Java 虚拟机进程</strong>，不管该 Java 程序有多么复杂，该程序启动了多少个线程，它们都处于该 Java 虚拟机进程里。同一个 JVM 的所有线程、所有变量都处于同一个进程里，它们都使用该 JVM 进程的内存区。</p>
<p>当系统出现以下几种情况时， JVM 进程将被终止：</p>
<ul>
<li>程序运行到最后正常接收；</li>
<li>程序运行到使用System.exit（）或Runtime.getRuntime（）.exit（）代码结束程序；</li>
<li>程序运行中遇到未捕获的异常或错误结束；</li>
<li>程序所在平台强制结束了JVM进程；</li>
</ul>
<h2 id="类加载机制">类加载机制</h2>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/37d12f2eb9389b50828b0dfd61271ed9e6116ec5.jpeg" alt="img"></p>
<p>java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。</p>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p>
<h2 id="面向对象的特征">面向对象的特征</h2>
<p><strong>抽象</strong>：</p>
<p>抽象是将一类对象的共同特征总结出来<strong>构造类的过程</strong>，包括<strong>数据抽象</strong>和<strong>行为抽象</strong>两方面。抽象只关注对象有哪些<strong>属性和行为</strong>，并不关注这些行为的细节是什么。</p>
<ol>
<li>研究事物的静态特征(属性)</li>
<li>研究事物的动态特征(方法/函数)</li>
<li>形成结果(类,class)</li>
<li>类和对象相互转变(new)</li>
</ol>
<p>举例说明：</p>
<p>学生有姓名，有年龄，有身份证号，这些都是静态特征，即属性</p>
<p>学生会吃饭，会睡觉，会学习，这些都是动态特征，即行为</p>
<p><strong>封装</strong>：</p>
<p>通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。</p>
<p>面向对象的本质就是将现实世界描绘成一系列<strong>完全自治、封闭的对象</strong>。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。封装给对象提供了隐藏内部特性和行为的能力，对象提供一些能被其它对象访问的方法来改变它内部的数据。</p>
<p><strong>继承</strong>：</p>
<p>继承是从已有类得到继承信息创建新类的过程。</p>
<p>提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。<strong>继承让变化中的软件系统有了一定的延续性</strong>，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</p>
<p><strong>多态性</strong>：</p>
<p>多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为<strong>编译时</strong>的多态性和<strong>运行时</strong>的多态性。如果将对象的方法视为对象向外界提供的服务，那么<strong>运行时</strong>的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p>
<p><strong>注意：运行时的多态是面向对象最精髓的东西，要实现多态需要的三个必要条件？</strong></p>
<ol>
<li>要有类的继承</li>
<li>要有方法的重写（子类继承父类并重写父类中已有的或抽象的方法）</li>
<li>对象造型（父类的引用指向子类的对象，这样同样的引用调用同样的方法会根据子类对象的不同而表现不同的行为）</li>
</ol>
<h4 id="构造方法">构造方法</h4>
<h2 id="类成员访问修饰符">类成员访问修饰符</h2>
<p>类的成员（方法、变量、<strong>包括内部类</strong>）的修饰符可以是以下四种：</p>
<ul>
<li>private则只有在当前类能访问。</li>
<li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。</li>
<li>protected 只能被本类、同一个包中的类访问；如果在其他包中被访问，则必须是该成员所属类的子类。</li>
<li>public则是在所有地方都能访问。</li>
</ul>
<p>外部类的修饰符只能是public或默认</p>
<h2 id="packge、import">packge、import</h2>
<p>1）代码中涉及的指令package cn.edu360;它的执行过程是：</p>
<p>在该源文件所在的目录（out/production）下，先创建一个cn文件夹，再在cn文件夹里创建一个edu360文件夹，然后将源文件编译后的class文件放入其中；</p>
<p>2）代码中涉及的另一条指令import cn.edu360.Farther;这个导包指令的执行过程是：</p>
<p>在该源文件所在目录中搜寻有没有一个叫cn文件夹的，再搜寻cn文件夹中是不是有edu360这个文件夹，进而再搜寻edu360文件夹中是否有Farther这个类，有的话才进行导入，否则会报错。</p>
<p>然后才想通了这句话：所说的同一个包或者不同包，指的是编译后的class文件是否在同一个文件夹里。</p>
<p>原文链接：<a href="https://blog.csdn.net/u013771764/article/details/81226908" target="_blank" rel="noopener">https://blog.csdn.net/u013771764/article/details/81226908</a></p>
<p>在某一个包中的类，无法调用</p>
<p><strong>java工程要建立良好的包结构，尽量不要在 package 根目录建类</strong></p>
<h2 id="原码补码反码移码">原码补码反码移码</h2>
<p><a href="https://blog.csdn.net/zl10086111/article/details/80907428" target="_blank" rel="noopener">https://blog.csdn.net/zl10086111/article/details/80907428</a></p>
<p><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">https://www.zhihu.com/question/20159860</a></p>
<h4 id="机器数">机器数</h4>
<p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1</p>
<p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p>
<p>那么，这里的 00000011 和 10000011 就是机器数。</p>
<h4 id="真数（真值）">真数（真值）</h4>
<p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。</p>
<p>例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。</p>
<p>所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>
<p>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p>
<h4 id="原码">原码</h4>
<p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式。</p>
<h4 id="反码">反码</h4>
<p>反码的表示方法是:</p>
<ul>
<li>正数的反码是其本身</li>
<li><strong>负数</strong>的反码是在其原码的基础上，符号位不变，其余各个位取反</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算</p>
<h4 id="补码">补码</h4>
<p>补码的表示方法是:</p>
<ul>
<li>正数的补码就是其本身</li>
<li><strong>负数</strong>的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。 (即在反码的基础上+1)</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码在计算其数值</p>
<h4 id="为什么要使用反码和补码">为什么要使用反码和补码</h4>
<p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
</blockquote>
<p>所以不需要过多解释. 但是对于负数:</p>
<blockquote>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>
<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别&quot;符号位&quot;显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了<strong>将符号位也参与运算</strong>的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>
<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403092524169" alt="img"></p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>如果用原码表示, 让符号位也参与计算, 显然对于某些加减来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p>
<p>从上面的原码表中可以看见<strong>左边每增加一个二进制单位对应的真数是递减的</strong>，而右边每增加一个二进制单位对应的真数是递增的，所以对于原码来说，能满足正数的加法，但无法满足负数的加法</p>
<p>为了满足负数对加法的需求，就必须让负数与他对应的二进制码是同步递增或者同步递减</p>
<p>于是就通过符号位不变，其余位取反来<strong>满足这个同步递增或者递减的要求</strong>，由于正数本来就满足它本身的加法，所以不需要做任何改变。这就是反码的定义由来。</p>
<p>为了解决原码做减法的问题, 出现了反码:</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403095015188" alt="img"></p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
</blockquote>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在&quot;0&quot;这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是<strong>0带符号是没有任何意义</strong>的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.这导致在实际计算中每当跨过0（溢出）一次，就有一个单位的误差。</p>
<p>要解决这个问题就必须<strong>让反码中的[1111_1111]和[0000_0000]合并</strong></p>
<p>由于[1111_1111]+[0000_0001]=[0000_0000]，所以在负数反码的基础上+1就可以解决反码中跨0的误差问题，同时不会对负数与它对应的二进制反码的同步递增产生影响，所以在反码的基础上+1就完美的解决了符号参与预算的问题，这就是补码为什么是在负数反码的基础上+1的由来。</p>
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<p><img src="/2018/12/21/Java/java%E9%9D%A2%E8%AF%95/20180403101055691" alt="img"></p>
<blockquote>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
</blockquote>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以**-128并没有原码和反码表示**.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p>
<p>使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理</p>
<p>==反码运算结果是反码，补码运算结果是补码==</p>
<h4 id="反码和补码的原理">反码和补码的原理</h4>
<p>（深入补码原码の原理，而不是表面上的求法）</p>
<p><strong>1. 原码</strong></p>
<p>所谓原码就是机器数，是==加了一位符号位的二进制数==，正数符号位为0，负数符号位为1，计算机中存储、处理、运算的数据通常是8位、16位、32位或64位的，这里以最简单的8位为例讲解。注意符号位是包含在8位中的其中1位，故可直观读出的数只有7位（只有后7位数可以按权展开）。有心人可能注意到原码是有缺陷的，它<strong>只能表示255种状态</strong>，因为0000_0000（＋0）和1000_0000（－0）其实是一个数，因此原码的表示范围成了－127到＋127，这个问题需要神奇的补码来解决，因为在补码中1000_0000被用来表示－128。</p>
<p><strong>2. 反码</strong></p>
<p>所谓反码，英语里又叫==ones’ complement（对1求补）==，这里的1，本质上是一个有限位计数系统里所能表示出的<strong>最大值</strong>，在8位二进制里就是1111_1111，在1位十进制里就是9，在3位十六进制里就是FFF（再大就要进位了）。</p>
<ul>
<li>反码原理：用最大数减去一个数就能得到它的反。很容易看出在二进制里1111_1111减去任何数结果都是把这个数按位取反，0变1，1变零，所以才称之为反码。</li>
<li>用原码求反码的方法：正数不变，负数保留符号位1不变，剩下位按位取反。</li>
</ul>
<p><strong>3. 补码</strong></p>
<p>所谓补码，英语里又叫==two’s complement（对2求补）==，这个2指的是计数系统的<strong>容量（模）</strong>，就是计数系统所能表示的状态数。对1位二进制数来说只有0和1两种状态，所以模是10也就是十进制的2，对7位二进制数来说就是1000_0000，这个模是不可能取到的，因为位数多一位。</p>
<ul>
<li>补码原理：用模减去一个数（无符号部分）就能得到这个数的补。比如1000_0000－101_0010=010_1110</li>
<li>用原码求补码的方法：事实上因为1000_0000 = 111_1111 + 1 = (111_1111－101_0010) + 1，所以又可以表述为<strong>先求反再加1</strong>。总结求补码的方法就是正数依旧不变，负数保留符号位不变，先求反码再加上1。</li>
</ul>
<p><strong>4. 如何运算？？？</strong></p>
<p>记住了怎么求补码，接下来讲讲运算。通过原码的符号位和数值，我们能迅速指出它代表的数，判断其正负并进行四则运算，相比而言反码和补码对于人则显得过于晦涩。如果说原码是给人看的数字语言，那么补码就是计算机的数字语言。<strong>计算机不需要知道什么是正负、大小</strong>，这些判断对它而言过于复杂。事实上它<strong>存储、处理、传输的数都只有补码一种形式</strong>，人所做的加减乘除，在计算机里只通过<strong>相加和移位</strong>就能解决，这都来自于补码系统的内在自洽和巧夺天工的神奇魔力，也是后文要阐述的重点。</p>
<p>对加法和减法，按上文的方法求得补码之后，直接相加就可以了，但相加的时候<strong>符号位一定要一起参与运算</strong>，有时候，两符号位相加或者接受来自低位的进位会发生溢出，就扔掉溢出的一位（稍后会解释为什么），由新的符号位决定结果的正负，如果是0表示正数，结果就是原码，如果是1表示负数，结果还要再求补数得到原码。</p>
<h4 id="模">模</h4>
<p>在介绍补码概念之前，先介绍一下“<a href="https://baike.baidu.com/item/%E6%A8%A1/13332718" target="_blank" rel="noopener">模</a>”的概念：“模”是指一个计量系统的计数范围，如过去计量粮食用的斗、时钟等。计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模”。如：时钟的计量范围是0~11，模=12。表示n位的计算机计量范围是0 ~ 2^n - 1，模= 2^n。“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。<strong>任何有模的计量器，均可化减法为加法运算</strong>。</p>
<p>假设当前时针指向8点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨2小时，即8-2=6；另一种是顺拨10小时，8+10=12+6=6，即8-2=8+10=8+(12-2)(mod 12)．在12为模的系统里，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。</p>
<p>若用一般公式可表示为：a-b=a-b+mod=a+(mod-b)。</p>
<p>对“模”而言，2和10互为补数。实际上，以12为模的系统中，11和1，8和4，9和3，7和5，6和6都有这个特性，共同的特点是两者相加等于模。</p>
<p>对于计算机，其概念和方法完全一样。计算机的逻辑运算单元中，只有加法运算器，用来对两个数进行相加，并没有减法器的电路。n位计算机，设n=8，所能表示的最大数是11111111，若再加1成100000000(9位)，但因只有8位，最高位1自然丢失。又回到了 00000000，所以8位系统的模为2^8。在这样的系统中<strong>减法问题也可以化成加法问题</strong>，只需把减数用相应的补数表示就可以了。把补数用到计算机对数的处理上，就是补码。</p>
<h2 id="数据类型">数据类型</h2>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>boolean</th>
<th>byte</th>
<th>char</th>
<th>short</th>
<th>Int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>void</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制位数</td>
<td>1</td>
<td>8</td>
<td>16</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
<td>–</td>
</tr>
<tr>
<td>封装器类</td>
<td>Boolean</td>
<td>Byte</td>
<td>Character</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
<td>Void</td>
</tr>
</tbody>
</table>
<p>整数默认都是int，小数默认都是float</p>
<p>可以在数值前用()进行显示类型转换（可能会有精度损失），或者加后缀来说明类型（不是转换）</p>
<p>整数的进制前缀、类型后缀可以共存</p>
<ul>
<li><strong>整数</strong>前面可以有0，0x开头，表示八进制，16进制</li>
<li>后缀L，表示long，不能作为小数的后缀</li>
<li>后缀F，表示float，后缀D，表示double，可以作为小数、整数后缀</li>
</ul>
<h3 id="大小、取值范围、精度">大小、取值范围、精度</h3>
<p>对于数值类型的基本类型的<strong>大小、取值范围</strong>，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p>
<ul>
<li>
<p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p>
</li>
<li>
<p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p>
</li>
<li>
<p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p>
<p>char本质就是整数，使用Unicode表示字符（0~65536）</p>
</li>
<li>
<p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p>
</li>
</ul>
<h3 id="float和double理解">float和double理解</h3>
<p>float、double两种类型的最小值与Float.MIN_VALUE、Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。</p>
<p>也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值<strong>超出了它们的精度范围</strong>。</p>
<p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的&quot;E+数字&quot;表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×10^3，3.14E-300就是3.14×10^-300=0.00314。</p>
<p>（把小数点移到最前面存储小数）</p>
<ul>
<li>float：1 位符号位，8 位指数，23 位有效尾数</li>
<li>double： 1 位符号位，11 位指数，52 位有效尾数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二进制浮点数（整数部分和小数部分都是二进制表示）</span><br><span class="line">1010100010 &#x3D; 101010001.0*2</span><br><span class="line">&#x3D; 10101000.10*2^10(2次方) &#x3D; 1010100.010*2^11(3次方) &#x3D; .1010100010*2^1010(10次方)</span><br><span class="line"></span><br><span class="line">尾数：.1010100010  指数：1010  基数：2</span><br></pre></td></tr></table></figure>
<p>范围？？？</p>
<p>float和double的范围是由指数的位数来决定的。<br>
float的指数位有8位，而double的指数位有11位，分布如下：<br>
float：<br>
1bit（符号位） 8bits（指数位） 23bits（尾数位）<br>
double：<br>
1bit（符号位） 11bits（指数位） 52bits（尾数位）<br>
于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。<br>
其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。<br>
float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。</p>
<p>精度？？？</p>
<p>float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。<br>
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；<br>
double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。</p>
<h4 id="浮点数的比较问题">浮点数的比较问题</h4>
<h3 id="简单类型及其封装">简单类型及其封装</h3>
<p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<p>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。简单类型主要分为3类：布尔、字符、数值</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>boolean</th>
<th>byte</th>
<th>char</th>
<th>short</th>
<th>Int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>void</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制位数</td>
<td>1</td>
<td>8</td>
<td>16</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
<td>–</td>
</tr>
<tr>
<td>封装器类</td>
<td>Boolean</td>
<td>Byte</td>
<td>Character</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
<td>Void</td>
</tr>
</tbody>
</table>
<p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机可以完成<strong>基本类型和它们对应包装类之间的自动转换</strong>。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，<strong>所有基本类型（包括void）的包装类都使用了final修饰</strong>，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p>
<ul>
<li>基本类型的优势：数据存储相对简单，运算效率比较高</li>
<li>包装类的优势：有的容易，比如<strong>集合的元素必须是对象类型</strong>，满足了java一切皆是对象的思想</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;                  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.out.println(a == b);     <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == c);     <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;        </span><br><span class="line">        System.out.println(f1 == f2);</span><br><span class="line">        System.out.println(f3 == f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntegerCache是Integer的内部类</p>
<p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1 == f2的结果是true，而f3 == f4的结果是false。</p>
<h3 id="类型转换">类型转换</h3>
<h4 id="简单类型-自动转换">简单类型-自动转换</h4>
<p>这些类型由&quot;小&quot;到&quot;大&quot;分别为 (byte，short，char) – int – long – float – double。</p>
<p>这里我们所说的&quot;大&quot;与&quot;小&quot;,并不是指占用字节的多少,而是指表示<strong>值的范围的大小</strong>。</p>
<ol>
<li>具体地讲，当一个较&quot;小&quot;数据与一个较&quot;大&quot;的数据<strong>一起运算时</strong>，系统将自动将&quot;小&quot;数据转换成&quot;大&quot;数据,再进行运算。</li>
<li>而在<strong>方法调用</strong>时,实际参数较&quot;小&quot;,而被调用的方法的形式参数数据又较&quot;大&quot;时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将&quot;小&quot;数据转换成&quot;大&quot;数据,再进行方法的调用。自然,对于多个同名的重载方法,会转换成最&quot;接近&quot;的&quot;大&quot;数据并进行调用？？？</li>
</ol>
<p>①下面的语句可以在Java中直接通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b;</span><br><span class="line"><span class="keyword">int</span> i=b;</span><br><span class="line"><span class="keyword">long</span> l=b;</span><br><span class="line"><span class="keyword">float</span> f=b;</span><br><span class="line"><span class="keyword">double</span> d=b;</span><br></pre></td></tr></table></figure>
<p>②如果低级类型为char型，向高级类型（整型）转换时，会转换为<strong>对应ASCII码值</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">int</span> i=c;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"output:"</span>+i); <span class="comment">// 输出：output:99;</span></span><br></pre></td></tr></table></figure>
<p>③对于byte,short,char三种类型而言，他们是<strong>平级的</strong>，因此不能相互自动转换，可以使用下述的强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> i=<span class="number">99</span> ;</span><br><span class="line"><span class="keyword">char</span> c=(<span class="keyword">char</span>)i;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"output:"</span>+c); <span class="comment">// 输出：output:c;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单类型-强制转换">简单类型-强制转换</h4>
<p>将&quot;大&quot;数据转换为&quot;小&quot;数据时，你可以使用强制类型转换。</p>
<p>即你必须采用下面这种语句格式： int n=(int)3.14159/2;</p>
<p>可以想象，这种转换肯定可能会<strong>导致溢出或精度的下降</strong>。</p>
<h4 id="表达式-数据类型自动提升">表达式-数据类型自动提升</h4>
<p>关于类型的自动提升，注意下面的规则。</p>
<p>①所有的byte,short,char型的值将被提升为int型；</p>
<p>②如果有一个操作数是long型，计算结果是long型；</p>
<p>③如果有一个操作数是float型，计算结果是float型；</p>
<p>④如果有一个操作数是double型，计算结果是double型；</p>
<p>例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b;</span><br><span class="line">b=<span class="number">3</span>;</span><br><span class="line">b=(<span class="keyword">byte</span>)(b*<span class="number">3</span>); <span class="comment">// 必须声明byte。</span></span><br></pre></td></tr></table></figure>
<h4 id="包装类过渡-类型转换">包装类过渡-类型转换</h4>
<p>一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。例如：</p>
<p>①当希望把float型转换为double型时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f1=<span class="number">100.00f</span>;</span><br><span class="line">Float F1=<span class="keyword">new</span> Float(f1);</span><br><span class="line"><span class="keyword">double</span> d1=F1.doubleValue(); <span class="comment">// F1.doubleValue()为Float类的返回double值型的方法</span></span><br></pre></td></tr></table></figure>
<p>②当希望把double型转换为int型时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d1=<span class="number">100.00</span>;</span><br><span class="line">Double D1=<span class="keyword">new</span> Double(d1);</span><br><span class="line"><span class="keyword">int</span> i1=D1.intValue();</span><br></pre></td></tr></table></figure>
<p>简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。</p>
<p>即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value)</p>
<p>而在各个包装类中，总有<strong>形为××Value()的方法</strong>，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。</p>
<h4 id="字符串与其它类型间的转换">字符串与其它类型间的转换</h4>
<p><strong>其它类型向字符串的转换</strong></p>
<p>①调用类的串转换方法:X.toString();</p>
<p>②自动转换:X+&quot;&quot;;</p>
<p>③使用String的方法:String.valueOf(X);</p>
<p><strong>字符串作为值,向其它类型的转换</strong></p>
<p>①先转换成相应的封装器实例,再调用对应的方法转换成其它类型</p>
<p>例如，字符中&quot;32.1&quot;转换double型的值的格式为:new Float(“32.1”).doubleValue()</p>
<p>也可以用:Double.valueOf(“32.1”).doubleValue()</p>
<p>②静态parseXXX方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">byte</span> b = Byte.parseByte( s );</span><br><span class="line"><span class="keyword">short</span> t = Short.parseShort( s );</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt( s );</span><br><span class="line"><span class="keyword">long</span> l = Long.parseLong( s );</span><br><span class="line">Float f = Float.parseFloat( s );</span><br><span class="line">Double d = Double.parseDouble( s );</span><br></pre></td></tr></table></figure>
<p>③Character的getNumericValue(char ch)方法</p>
<h4 id="Date类与其它数据类型的相互转换">Date类与其它数据类型的相互转换</h4>
<p>整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式：</p>
<p>①Date(int year, int month, int date)：以int型表示年、月、日</p>
<p>②Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分</p>
<p>③Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、分、秒</p>
<p>在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。</p>
<p>获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。</p>
<p>而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。</p>
<p>有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法，首先在文件开始引入，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果希望得到YYYYMMDD的格式</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sy1=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMDD"</span>);</span><br><span class="line">String dateFormat=sy1.format(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果希望分开得到年，月，日</span></span><br><span class="line">SimpleDateFormat sy=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy"</span>);</span><br><span class="line">SimpleDateFormat sm=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"MM"</span>);</span><br><span class="line">SimpleDateFormat sd=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd"</span>);</span><br><span class="line">String syear=sy.format(date);</span><br><span class="line">String smon=sm.format(date);</span><br><span class="line">String sday=sd.format(date);</span><br></pre></td></tr></table></figure>
<h4 id="总结-2">总结</h4>
<p>只有boolean不参与数据类型的转换</p>
<p>（1）.自动类型的转换：</p>
<ol>
<li>常数在表数范围内是能够自动类型转换的</li>
<li>数据范围小的能够自动数据类型大的转换（注意特例）int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度</li>
<li><strong>引用类型能够自动转换为父类的</strong></li>
<li>基本类型和它们包装类型是能够互相转换的</li>
<li>不能把对象类型转换成不相关类的对象。</li>
</ol>
<p>（2）强制类型转换：用圆括号括起来目标类型，置于变量前</p>
<p><strong>3、Java中的基本类型有哪些？String 是最基本的数据类型吗？</strong></p>
<ol>
<li>Java中的基本数据类型只有8个：byte（1）、short（2）、int（4）、long（8）、float（4）、double（8）、char（2）、boolean（1 bit）；其余单位都是byte</li>
<li>除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</li>
<li>String不是基本数据类型，它定义的为对象。</li>
</ol>
<p><strong>4、float f=3.4;是否正确？</strong></p>
<p>不正确。==3.4是双精度数==，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失。</p>
<p>因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F。3.4f也可</p>
<p><strong>5、short s1 = 1; s1 = s1 + 1;有错吗？short s1 = 1; s1 += 1;有错吗？</strong></p>
<p>short s1 = 1;</p>
<p>对于short s1 = 1; s1 = s1 + 1；由于==1是int类型==，因此==s1+1运算结果自动提升为int 型==，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1；+=操作符会进行<strong>隐式自动类型转换</strong>，是 <strong>Java 语言规定的运算符</strong>；Java编译器会对它进行特殊处理，因此可以正确编译。因为s1+= 1;相当于s1 = (short)(s1 + 1)</p>
<h2 id="equals、-、hashcode">equals、==、hashcode</h2>
<p>== 任何情况下都是判断两个对象在内存中的首地址是否相同</p>
<p>equals取决于所在的类是否重写了这个方法，如果不重写，则使用Object类的equals方法（用==实现的）</p>
<ul>
<li>String的重写了equals方法，作用和==相同</li>
<li>自定义类可以自行重写</li>
</ul>
<p><strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hashCode，这句话对不对？</strong></p>
<p>不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：（1）如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；（2）如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p>
<p>实现高质量的equals方法的诀窍包括：</p>
<ol>
<li>使用==操作符检查&quot;参数是否为这个对象的引用&quot;；</li>
<li>使用instanceof操作符检查&quot;参数是否为正确的类型&quot;；</li>
<li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li>
<li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li>
<li>重写equals时总是要重写hashCode；</li>
<li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</li>
</ol>
<h2 id="和-的区别">&amp;和&amp;&amp;的区别</h2>
<p>&amp;运算符有两种用法：</p>
<p>(1)按位与；</p>
<p>(2)逻辑与（不短路）</p>
<p>&amp;&amp;运算符是<strong>短路与运算</strong>。</p>
<p><strong>逻辑</strong>与跟<strong>短路</strong>与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。</p>
<p>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h2 id="Math类">Math类</h2>
<p>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</p>
<p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。</p>
<p><strong>四舍五入</strong>的原理是==在参数上加0.5然后进行下取整==。</p>
<h2 id="switch">switch</h2>
<p>可以switch的对象有：</p>
<ol>
<li>Java5以前：char、byte、short、int、以及他们的封装类</li>
<li>Java5：enum</li>
<li>Java7：String</li>
</ol>
<h2 id="有效率进行乘法：移位运算">有效率进行乘法：移位运算</h2>
<p><strong>用最有效率的方法计算2乘以8？</strong></p>
<p>2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）</p>
<h2 id="Java保留字-and-关键字">Java保留字 and 关键字</h2>
<p>Java有没有goto？</p>
<p>goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p>
<h2 id="方法的重载（overload）和重写（overwrite）">方法的重载（overload）和重写（overwrite）</h2>
<p>面试时，问：重载（Overload）和重写（Override）的区别？</p>
<p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<ol>
<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同、参数顺序不同）则视为重载；</li>
<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</li>
</ol>
<p>重载条件：</p>
<ul>
<li>有不同的参数列表（参数类型不同、参数个数不同或者二者都不同、参数顺序不同）</li>
<li>能否重载和返回类型无关，不能根据返回类型进行区分</li>
<li>不能重载的情况：仅仅参数变量名不同 或者 仅仅返回值类型不同</li>
</ul>
<p>重写条件：</p>
<p>在子类中可以使用super关键字调用父类方法</p>
<p><strong>1、重写规则之一：</strong></p>
<p>访问修饰符的限制一定要不小于被重写方法的访问修饰符</p>
<p>（public 、protected  、default  、private 权限依次增加）</p>
<pre><code>比如：Object类有个toString()方法, 开始重写这个方法的时候我们总容易忘记Public修饰符, 出错的原因就是：没有加任何访问修饰符的方法具有包访问权限, Default访问权限小于Public访问权限, 所以编译器出错。
</code></pre>
<p><strong>2、重写规则之二：</strong></p>
<p><strong>参数列表</strong>必须与被重写方法的相同。</p>
<p>区别于重载：重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。</p>
<p><strong>3、重写规则之三：</strong></p>
<p><strong>返回类型</strong>必须与被重写方法的返回类型相同（兼容也不行）。</p>
<p>父类方法A：void catch(){} 子类方法 B：int catch(){} 两者虽然参数相同, 返回类型不同, 所以不是重写。</p>
<p>父类方法A：int catch(){} 子类方法 B：long catch(){} 返回类型虽然兼容父类, 但是不同就是不同, 所以不是重写。</p>
<pre><code>ps1:
如果在没有加注@Override？？？的情况下, 方法名和参数列表完全相同,且满足规则A的情况下, 返回值类型必须完全一致的情况下、才不会出现编译错误（即为该方法为强制重写方法）。
如果以上条件中参数列表不同，且返回值类型不同这样编译并不会出现错误（这个方法为在子类的新方法，且不是重写方法）。

ps2:
当子类的方法重写或实现父类的方法时, 方法的后置条件（即方法的返回值）要比父类更严格。
即：如果重写方法的参数列表和方法名相同,且其他条件满足的情况下,方法的返回值为父类的子类,那么该方法也为重写方法
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Computer <span class="title">sale</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Computer(); &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HP <span class="title">make</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> HP(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBM</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBM <span class="title">sale</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> IBM(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HP</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Computer <span class="title">make</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Computer(); &#125; <span class="comment">// compilation error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、重写规则之四：</strong></p>
<p>重写方法不能抛出新的异常，或者比被重写方法声明的检查异常更广的检查异常。</p>
<p>但是可以抛出更少，更有限或者不抛出异常。</p>
<pre><code>举个简单的例子：父类异常好比父亲偷盗抢掠、那么儿子不能比父亲更坏、要学好、自然异常就要少。虽然举得例子与社会主义核心价值观有冲突、但是比较形象。// 2016/12/10 10:55 bluetata 追記 add
</code></pre>
<p><strong>5、重写规则之五：</strong></p>
<p>如果一个方法不能被继承, 则不能重写它。</p>
<p>比较典型的就是父类的private方法。因为private说明该方法对子类是不可见的, 子类再写一个同名的方法并不是对父类方法进行复写(Override), 而是<strong>重新生成一个新的方法</strong>, 也就不存在多态的问题了。</p>
<p>同理也可以解释final, 因为方法同样是不可覆盖的。</p>
<p><strong>6、重写规则之六：</strong></p>
<p>不能重写被标识为final的方法。</p>
<p>final方法可以被继承, 但是不能被重写, 一个方法如果被final修饰, 那么也就意味着, 这个方法不会被改动</p>
<p>（声明一个final方法的主要目的是<strong>防止方法的内容被修改</strong>）。</p>
<p><strong>7、重写规则之七：</strong></p>
<p>静态方法不能被重写。</p>
<p>《JAVA编程思想》中多次的提到：方法是静态的、他的行为就不具有多态性。</p>
<p>静态方法是与类、而非单个对象相关联的。</p>
<p>父类的普通方法可以被继承和重写，不多作解释，如果子类继承父类，而且子类没有重写父类的方法，但是子类会有从父类继承过来的方法。静态的方法可以被继承，但是不能重写。如果父类中有一个静态的方法，子类也有一个与其方法名，参数类型，参数个数都一样的方法，并且也有static关键字修饰，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。《JAVA编程思想》：只有普通的方法调用可以是多态的，静态方法是与类而不是与某个对象相关联。</p>
<pre><code>// 2016/11/22 16:45 bluetata 追記 add Start
</code></pre>
<h4 id="overwrite注解">@overwrite注解</h4>
<p>Java 中的覆盖@Override注解 写与不写的一点点理解</p>
<p>一般来说，写与不写没什么区别，JVM可以自识别</p>
<p><strong>写的情况下</strong>：即说明子类要覆盖基类的方法，基类必须存在方法（控制类型public,protected，返回值，参数列表类型）与子类方法完成一致的方法，否则会报错（找不到被Override的方法）。</p>
<p><strong>不写的情况下</strong>：当基类存在与子类各种条件都符合的方法是即实现覆盖； 如果条件不符合时，则是当成新定义的方法使用。</p>
<p>所以如果想覆盖基类方法时，最好还是写上@Override注解，这样有利于编译器帮助检查错误</p>
<p>发生在父类和子类之间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写equals方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">      		<span class="comment">// instanceof 已经处理了obj = null的情况</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Student stuObj = (Student) obj;</span><br><span class="line">	<span class="comment">// 地址相等，直接equal</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == stuObj) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果两个对象姓名、年龄、性别相等，我们认为两个对象相等</span></span><br><span class="line">	<span class="keyword">if</span> (stuObj.name.equals(<span class="keyword">this</span>.name) &amp;&amp; stuObj.sex.equals(<span class="keyword">this</span>.sex) &amp;&amp; stuObj.age.equals(<span class="keyword">this</span>.age)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法-2">构造方法</h2>
<p>不含返回值，概念不同于void，返回值的类型就是该类本身？</p>
<p>自定义构造函数override默认构造函数</p>
<p>因为构造器不能被继承，所以不能被重写？？？</p>
<h3 id="从一个构造方法调用另一个（private）构造方法">从一个构造方法调用另一个（private）构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    sout;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">private</span>) myClass(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    m_d = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Static">Static</h2>
<h3 id="static-method-field">static method/field</h3>
<ul>
<li>field/method未用static修饰，则称为<strong>实例成员</strong></li>
<li>static方法只能访问static方法或变量</li>
<li>静态<strong>变量</strong>（方法）的<strong>调用</strong>：类名.静态变量名（方法名）</li>
<li>static方法也可以用对象来调用</li>
<li>！static方法中<strong>不能有this和super</strong></li>
</ul>
<h4 id="Java虚拟机和main方法？P109">Java虚拟机和main方法？P109</h4>
<p>JVM需要在类外调用main方法，必须是public</p>
<p>又JVM运行时系统在开始执行一个程序前，并没有创建main所在类的对象，只能通过类名调用main()，必须是static</p>
<h3 id="static-初始化器（块）">static 初始化器（块）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对static field 进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="static初始化器和构造方法的差别">static初始化器和构造方法的差别</h4>
<ol>
<li>
<p>静态初始化器是对类本身进行初始化，构造方法是对每个新创建的对象初始化</p>
</li>
<li>
<p>前者不能由程序来调用，他是在所属类被加载入内存时由系统调用执行的（且仅在此执行一次）</p>
</li>
<li>
<p>前者不是方法，没有返回值等</p>
<p>ps：类是在第一次被使用的时候才被装载，不是在程序启动时就装载所有可能用到的类</p>
<p>​	如果有多个static初始化器，则顺序执行</p>
</li>
</ol>
<h4 id="执行顺序">执行顺序</h4>
<p><a href="https://blog.csdn.net/caomiao2006/article/details/51533382" target="_blank" rel="noopener">https://blog.csdn.net/caomiao2006/article/details/51533382</a></p>
<p>它们的初始化顺序以此是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器</p>
<h5 id="变量和初始化块之间的顺序">变量和初始化块之间的顺序</h5>
<p>静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。</p>
<h5 id="无继承：">无继承：</h5>
<p>静态变量<br>
静态初始化块<br>
变量<br>
初始化块<br>
构造器</p>
<h5 id="有继承：">有继承：</h5>
<p>父类–静态变量<br>
父类–静态初始化块<br>
<strong>子类–静态变量</strong><br>
<strong>子类–静态初始化块</strong><br>
父类–变量<br>
父类–初始化块<br>
父类–构造器<br>
子类–变量<br>
子类–初始化块<br>
子类–构造器</p>
<p>并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。</p>
<h2 id="对象的应用">对象的应用</h2>
<ul>
<li>
<p>对象也可以称为类类型的变量，实际为引用型</p>
</li>
<li>
<p>引用型的变量实际上保存的是对象在内存中的首地址（也称为对象的句柄）</p>
</li>
<li>
<p>引用变量可作为参数传递、作为方法的返回值</p>
</li>
</ul>
<h3 id="类类型的数组">类类型的数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] per;</span><br><span class="line">per = <span class="keyword">new</span> Person[<span class="number">3</span>];</span><br><span class="line">per[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">25</span>);</span><br><span class="line">per[<span class="number">1</span>] = <span class="keyword">new</span> Person(<span class="string">"B"</span>,<span class="number">25</span>);</span><br><span class="line">per[<span class="number">2</span>] = <span class="keyword">new</span> Person(<span class="string">"C"</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>ps数组类型的使用</p>
<p><a href="http://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-array.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明数组变量</span></span><br><span class="line"><span class="comment">// 首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</span></span><br><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line"><span class="comment">// Java语言使用new操作符来创建数组，语法如下：</span></span><br><span class="line"></span><br><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"><span class="comment">// 上面的语法语句做了两件事：</span></span><br><span class="line"><span class="comment">// 一、使用 dataType[arraySize] 创建了一个数组。</span></span><br><span class="line"><span class="comment">// 二、把新创建的数组的引用赋值给变量 arrayRefVar。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组变量的声明，和创建数组可以用一条语句完成，如下所示：</span></span><br><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，你还可以使用如下的方式创建数组。</span></span><br><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure>
<p>pps：foreach</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ppps：数组作为参数或者返回值，详见类与对象笔记</p>
<h2 id="hash系列">hash系列</h2>
<p>hashmap、hashset</p>
<h2 id="跳到特定的某一层循环">跳到特定的某一层循环</h2>
<p>直接在for之间加标签即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j)</span><br><span class="line">            <span class="keyword">break</span> A; <span class="comment">// 直接跳出最外层循环</span></span><br><span class="line">    &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java继承、抽象类和接口</title>
    <url>/2018/12/21/Java/%E7%BB%A7%E6%89%BF%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1>继承、抽象类和接口</h1>
<ul>
<li>？接口是实现Java中多重继承的重要方法</li>
<li>所有的类都是直接或间接继承java.lang.Object类得到的</li>
</ul>
<a id="more"></a>
<h2 id="继承">继承</h2>
<ul>
<li>
<p>？从父类继承非private成员</p>
</li>
<li>
<p>？继承性的“即是”性质：子类的每个对象也是其父类的对象</p>
<ul>
<li>sub即是super，任何可以使用super的地方都可以使用sub</li>
</ul>
</li>
<li>
<p>实例化子类对象前，先自动调用父类的无参构造方法</p>
<ul>
<li>用super() 来调用父类特定的有参（或无参）的构造方法</li>
<li><strong>super必须写在第一行</strong>（和this一样），因此无法存在于同一个构造方法内</li>
<li>super调用父类，this调用本类</li>
<li>this 和 super关键字都指对象，不能出现在static方法中</li>
<li>用super. 访问父类的成员，成员函数调用谁的？P122
<ul>
<li>子类没有覆盖，调用父类版本的函数，对父类里的成员变量修改？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="覆盖">覆盖</h3>
<ul>
<li>
<p>应保持与父类完全相同的头声明（方法名，返回类型，参数列表）</p>
<ul>
<li>如果不符合，则意味着子类定义了与父类无关的方法，父类的方法依然存在</li>
</ul>
</li>
<li>
<p>不能覆盖父类的final和static</p>
</li>
<li>
<p>覆盖时可以扩大权限，或权限不变，但不能缩小权限</p>
</li>
</ul>
<h4 id="用父类的对象访问子类的成员">用父类的对象访问子类的成员</h4>
<ul>
<li>仅限于覆盖的函数，父类无法访问子类新添加的函数，即使是public也不行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Son();<span class="comment">// 向上转型</span></span><br><span class="line">f.show();</span><br><span class="line"><span class="comment">// 假设show（）方法存在重写</span></span><br><span class="line"><span class="comment">// 父类的引用指向子类对象</span></span><br><span class="line"><span class="comment">// 子类重写版本被调用，此时“覆盖”依然发生</span></span><br></pre></td></tr></table></figure>
<ul>
<li>向上转型：<strong>父类的引用指向子类对象</strong>，将子类对象看做父类对象，从较具体的转换为较抽象的类，安全？</li>
<li>？向下转型：将父类对象强制转换为子类对象，然后赋给子类。必须采用显示转换？</li>
</ul>
<h3 id="不可被继承的成员与最终类">不可被继承的成员与最终类</h3>
<ul>
<li>
<p>比较重要且不希望子类进行覆盖的成员：用final修饰</p>
</li>
<li>
<p>final只能被赋值一次，static final只能在定义时就被赋好值</p>
<ul>
<li>final数据成员赋值方式：定义时，或者构造方法中</li>
</ul>
</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<ul>
<li>abstract不能和final、public等一起修饰同一个方法？</li>
<li>抽象类中不一定要有抽象方法，但包含抽象方法的一定是抽象类</li>
<li>抽象类的子类必须覆盖（实现）父类中的所有抽象方法，否则自己也要声明为抽象</li>
</ul>
<h2 id="接口">接口</h2>
<h3 id="与抽象类的不同">与抽象类的不同</h3>
<p>一种特殊的抽象类</p>
<ol>
<li>接口的数据成员必须都是static且必须初始化</li>
<li>方法全部为abstract
<ul>
<li>方法系统默认为public abstract</li>
<li>变量默认为public static final</li>
</ul>
</li>
</ol>
<h3 id="实现与引用">实现与引用</h3>
<ul>
<li>
<p>class xxxx implements  接口名</p>
</li>
<li>
<p><strong>方法头</strong>要完全一致，否则认为是定义新方法</p>
</li>
<li>
<p>实现时必须显式地说明public，否则将认为是缩小权限</p>
</li>
</ul>
<h3 id="接口的继承">接口的继承</h3>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类与对象</title>
    <url>/2018/12/21/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>类与对象</h1>
<h2 id="类的基本概念">类的基本概念</h2>
<ul>
<li>Java把类内的数据成员称为 域（field），封装于类内的函数称为方法(method)
<ul>
<li>main()也是方法</li>
</ul>
</li>
<li>“类”就是把事物的数据与相关功能封装（Encapsulate）在一起，形成一种特殊的数据结构</li>
</ul>
<a id="more"></a>
<h2 id="定义类">定义类</h2>
<ul>
<li>定义类又称为声明类</li>
</ul>
<h3 id="class修饰符">class修饰符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">任何对象都可以访问</td>
</tr>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">抽象类需要子类提供方法实现，不能实例化</td>
</tr>
<tr>
<td style="text-align:center">final</td>
<td style="text-align:center">最终类，或非继承类，不能被其他的类继承</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">位于相同包的对象可以使用</td>
</tr>
</tbody>
</table>
<p>ps：一个类可以有多个修饰符，无先后顺序</p>
<p>​	abstract和final对立，不能放在一起</p>
<h3 id="field修饰符">field修饰符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">能访问的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">任何对象的方法</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">只允许本类的方法访问，其他类（包括子类）的方法不能访问</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">本类、子类（子类可以覆盖此变量）、相同包内</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">相同包</td>
</tr>
</tbody>
</table>
<p>ps：transient&amp;volatile？</p>
<p>​	定义类的成员变量时可以同时赋初值</p>
<h3 id="method修饰符">method修饰符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">能访问的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">任何对象的方法</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">只允许本类的方法访问，其他类（包括子类）的方法不能访问</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">本类、子类（子类可以覆盖此变量）、相同包内</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">相同包</td>
</tr>
<tr>
<td style="text-align:center">final</td>
<td style="text-align:center">方法不能被重载</td>
</tr>
<tr>
<td style="text-align:center">static</td>
<td style="text-align:center">不需要实例化一个对象就可以调用的方法</td>
</tr>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">抽象方法，需要在子类中实现</td>
</tr>
</tbody>
</table>
<p>ps：成员变量和局部变量的区别</p>
<ol>
<li>局部变量不能被访问控制修饰符和static所修饰</li>
<li>成员变量是对象的一部分，对象存在于堆内存中，局部变量存在于栈内存（课本P84）</li>
<li>生命周期不同</li>
<li>成员变量会以类型的默认值赋初值（例外：final且非static，必须显式地赋初值）
<ul>
<li>long类型：0L</li>
<li>float类型：0.0F</li>
<li>double类型：0.0D</li>
<li>char类型：’\u0000’（表示为空）</li>
<li>boolean类型：false</li>
<li>所有引用类型：null</li>
</ul>
</li>
</ol>
<h2 id="对象的创建与使用">对象的创建与使用</h2>
<ul>
<li>
<p>创建的对象实体存在于堆内存中，引用变量存在于栈内</p>
<p>引用变量指向：存在于堆空间的对象的首地址</p>
</li>
<li>
<p>public：定义公共类</p>
<p>psvm：程序执行的起始点</p>
</li>
<li>
<p>程序运行到调用方法语句后，程序会暂时跳到该方法中运行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">pi = <span class="number">3</span>;<span class="comment">// 程序自动将pi设置为3.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果要强调是 对象本身的成员，可以在成员名前加 this.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.a = a;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参数传递">参数传递</h2>
<h3 id="以数组作为参数或返回值的方法调用">以数组作为参数或返回值的方法调用</h3>
<p>一位数组的传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 调用参数列表写数组名</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">least(a);</span><br></pre></td></tr></table></figure>
<p>二维数组的传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;<span class="comment">// 定义一个二维数组</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 返回值和参数均为二维数组的方法</span></span><br><span class="line"><span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] array)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = array[i][j];</span><br><span class="line">            array[i][j] = array[j][i];</span><br><span class="line">            array[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line">transpose(a);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/21/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/D:%5CDocuments%5C0%E9%87%8D%E8%A6%81%E5%9B%BE%EF%BC%81%EF%BC%81%EF%BC%81%5C1.PNG" alt="1"></p>
<h3 id="按值传参or按址传参？">按值传参or按址传参？</h3>
<p><a href="https://blog.csdn.net/xiaosha009/article/details/50680199" target="_blank" rel="noopener">https://blog.csdn.net/xiaosha009/article/details/50680199</a></p>
<p>基本数据类型为值传递</p>
<p>引用数据类型传递的，也是这个引用变量的值本身</p>
<h4 id="实例">实例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行的结果如下：main a=[100, 101]</p>
<p>这时候，很多人会说，看，java中的基本类型是值传递，对象类型是引用传递。如果这样认为的话，那就大错特错了。再来看看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下：main a=[100]</p>
<h4 id="分析">分析</h4>
<p><code>List&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();</code></p>
<p>语句执行完毕后：</p>
<p><img src="/2018/12/21/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/D:%5CDocuments%5C0%E9%87%8D%E8%A6%81%E5%9B%BE%EF%BC%81%EF%BC%81%EF%BC%81%5C20160217151806391.png" alt="20160217151806391"></p>
<p>当调用methodTwo方法时，模型变如下：</p>
<p>这时候应该就清晰很多了，对象引用a被复制了一份出来使用，methodTwo拿到的是a的复制品。</p>
<p><img src="/2018/12/21/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/D:%5CDocuments%5C0%E9%87%8D%E8%A6%81%E5%9B%BE%EF%BC%81%EF%BC%81%EF%BC%81%5C20160217151831438.png" alt="20160217151831438"></p>
<p>调用完method2中的</p>
<p>a = new ArrayList<Integer>();</Integer></p>
<p>后，模型变化如下：</p>
<p><img src="/2018/12/21/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/D:%5CDocuments%5C0%E9%87%8D%E8%A6%81%E5%9B%BE%EF%BC%81%EF%BC%81%EF%BC%81%5C20160217152321440.png" alt="20160217152321440"></p>
<p>​	在new一个新的对象出来之后，methodTwo方法的a指向了新的对象实例，所以怎么改变都不会改变main方法中a的对象。同时也可以证明，<strong>java中只有值传递没有引用传递，在传递对象时，是传递对象的引用的副本，不是直接传递对象的引用本体。</strong></p>
<h2 id="匿名对象">匿名对象</h2>
<h3 id="例子">例子</h3>
<p><code>new Cylinder().set(1,2,3);</code></p>
<p>不定义对象的引用变量</p>
<p>new Cylinder() 即为匿名对象，语句执行完后，该对象成为垃圾</p>
<h3 id="使用情况">使用情况</h3>
<ol>
<li>对一个对象只需要进行一次方法调用</li>
<li>匿名对象作为实参传递给一个方法调用？？</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>svg学习笔记</title>
    <url>/2019/01/25/HTML/svg/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>什么是SVG？</p>
<ul>
<li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
<li>SVG 用来定义用于网络的基于矢量的图形</li>
<li>SVG 使用 XML 格式定义图形（纯粹的xml）</li>
<li>SVG 图像在放大或改变尺寸的情况下其<strong>图形质量不会有所损失</strong></li>
<li>SVG 是万维网联盟的标准</li>
<li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li>
</ul>
<p>与其他图像格式相比，使用 SVG 的优势在于：</p>
<ul>
<li>SVG 可被非常多的工具读取和修改（比如记事本）</li>
<li>SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。</li>
<li>SVG 是可伸缩的</li>
<li>SVG 图像可在任何的分辨率下被高质量地打印</li>
<li>SVG 可在图像质量不下降的情况下被放大</li>
<li>SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）</li>
<li>SVG 可以与 Java 技术一起运行</li>
<li>SVG 是开放的标准</li>
<li>SVG 文件是纯粹的 XML</li>
</ul>
<p>SVG 的主要竞争者是 Flash。</p>
<p>与 Flash 相比，SVG 最大的优势是与其他标准（比如 XSL 和 DOM）相兼容。而 Flash 则是未开源的私有技术。</p>
<h2 id="例子">例子</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; standalone&#x3D;&quot;no&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD SVG 1.1&#x2F;&#x2F;EN&quot; </span><br><span class="line">&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;Graphics&#x2F;SVG&#x2F;1.1&#x2F;DTD&#x2F;svg11.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg width&#x3D;&quot;100%&quot; height&#x3D;&quot;100%&quot; version&#x3D;&quot;1.1&quot;</span><br><span class="line">xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;circle cx&#x3D;&quot;100&quot; cy&#x3D;&quot;50&quot; r&#x3D;&quot;40&quot; stroke&#x3D;&quot;black&quot;</span><br><span class="line">stroke-width&#x3D;&quot;2&quot; fill&#x3D;&quot;blue&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure>
<img src="/2019/01/25/HTML/svg/image-20200408211835100.png" alt="image-20200408211835100" style="zoom:80%;">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行包含了 XML 声明。</span><br><span class="line">注意 standalone 属性！该属性规定此 SVG 文件是否是“独立的”，或含有对外部文件的引用。</span><br><span class="line">standalone&#x3D;&quot;no&quot; 意味着【不独立】 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。</span><br><span class="line"></span><br><span class="line">第二和第三行引用了这个外部的 SVG DTD。该 DTD 位于“http:&#x2F;&#x2F;www.w3.org&#x2F;Graphics&#x2F;SVG&#x2F;1.1&#x2F;DTD&#x2F;svg11.dtd”。</span><br><span class="line">该 DTD 位于 W3C，含有所有允许的 SVG 元素。</span><br><span class="line"></span><br><span class="line">SVG 代码以 &lt;svg&gt; 元素开始，包括开启标签 &lt;svg&gt; 和关闭标签 &lt;&#x2F;svg&gt; 。</span><br><span class="line">&lt;svg&gt; 是根元素。</span><br><span class="line">width 和 height 属性可设置此 SVG 文档的宽度和高度。</span><br><span class="line">version 属性可定义所使用的 SVG 版本。</span><br><span class="line">xmlns 属性定义 SVG 命名空间。</span><br><span class="line"></span><br><span class="line">关闭标签的作用是关闭 SVG 元素和文档本身。</span><br></pre></td></tr></table></figure>
<p>SVG 的 <code>&lt;circle&gt;</code> 用来创建一个圆。</p>
<ul>
<li>
<p>cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。</p>
</li>
<li>
<p>r 属性定义圆的半径。</p>
</li>
<li>
<p>stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。</p>
</li>
<li>
<p>fill 属性设置形状内的颜色。我们把填充颜色设置为红色。</p>
</li>
</ul>
<p>**注释：**所有的开启标签必须有关闭标签！</p>
<h2 id="svg如何嵌入html">svg如何嵌入html</h2>
<p>SVG 文件可通过以下标签嵌入 HTML 文档：embed、object或者iframe。</p>
<p>embed</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"rect.svg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"100"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">"image/svg+xml"</span></span></span><br><span class="line"><span class="tag"><span class="attr">codebase</span>=<span class="string">"http://www.adobe.com/svg/viewer/install/"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>iframe</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"rect.svg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux C network programming</title>
    <url>/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>n大多数网络应用系统可分为两个部分：客户端©和服务器端(S) 。</p>
<p>一个server经常同时和多个client建立连接</p>
<p><img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426101748109.png" alt="image-20200426101748109"></p>
<p><img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426101803094.png" alt="image-20200426101803094"></p>
<h2 id="TCP-套接字通信工作流程">TCP 套接字通信工作流程</h2>
<p>面向连接的套接字Socket通信工作流程</p>
<p>为了实现服务器与客户机的通信,服务器和客户机都必须建立套接字。服务器与客户机的工作原理可以用下面的过程来描述。</p>
<p>1.服务器先用 socket 函数来建立一个套接字,<strong>用这个套接字完成通信的监听</strong>。</p>
<p>2.用 bind 函数来绑定一个端口号和 IP 地址。因为本地计算机可能有多个网址和 IP,每一个 IP 和端口有多个端口。需要指定一个 IP 和端口进行监听。</p>
<p>3.服务器调用 listen 函数,使服务器的这个端口和 IP 处于监听状态,等待客户机的连接。</p>
<p>4.客户机用 socket 函数建立一个套接字,设定远程 IP 和端口。</p>
<p>5.客户机调用 connect 函数连接远程计算机指定的端口。</p>
<p>6.服务器用 accept 函数来接受远程计算机的连接,建立起与客户机之间的通信。</p>
<p>7.建立连接以后,客户机用 write 函数向 socket 中写入数据。也可以用 read 函数读取服务器发送来的数据。</p>
<p>8.服务器用 read 函数读取客户机发送来的数据,也可以用 write 函数来发送数据。</p>
<p>9.完成通信以后,用 close 函数关闭 socket 连接。</p>
<h3 id="基础概念">基础概念</h3>
<h4 id="socket套接口">socket套接口</h4>
<p>套接口是应用层到传输层的接口；类似于Unix管道，可以向/从“套接口”中写/读数据</p>
<h4 id="sockfd套接字">sockfd套接字</h4>
<p>套接口的描述字</p>
<h3 id="报文格式">报文格式</h3>
<h4 id="封装过程">封装过程</h4>
<p><img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426113810817.png" alt="image-20200426113810817"></p>
<h4 id="TCP报文格式">TCP报文格式</h4>
<p><img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426113855858.png" alt="image-20200426113855858"></p>
<p><img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/64380cd7912397ddb480a4110c5c4ab2d1a28709.jpeg" alt="img"></p>
<p>其中比较重要的字段有：</p>
<p>注意区分两个ACK：ACK确认Ack是否有效（大写的单词表示标志位）</p>
<p>（1）序号（sequence number）：Seq序号，占32位</p>
<p>TCP连接中传送的<strong>字节流中的每个字节都按顺序编号</strong>，第一个字节的编号由本地随机产生</p>
<p>seq其实就是这个报文段中的第一个字节的数据编号。</p>
<p>例如，一段报文的seq字段值是 200 ，而携带的数据共有100字节，显然下一个报文段（如果还有的话）的数据序号应该从300开始；</p>
<p>（2）确认号（acknowledgement number）：Ack序号，占32位</p>
<p>只有ACK标志位为1时，确认序号字段才有效</p>
<p>Ack=Seq+1。期待收到对方下一个报文段的seq（第一个数据字节的序号）；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p>
<p>（3）==标志位（Flags）==：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p>
<ul>
<li>URG：紧急指针（urgent pointer）有效。</li>
<li>ACK：确认序号有效。占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
</ul>
<h3 id="状态转换图">状态转换图</h3>
<p>==实线：client==的正常状态转换</p>
<p>==虚线：server==的正常状态转换</p>
<p>app：应用？？？</p>
<img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426104739547.png" alt="image-20200426104739547" style="zoom:150%;">
<h3 id="TCP连接的建立（三次握手）">TCP连接的建立（三次握手）</h3>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<p><em>SYN</em>：同步序列编号（<em>Syn</em>chronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。</p>
<h4 id="为什么需要三次握手">为什么需要三次握手</h4>
<p>首先非常明确的是两次握手是最基本的。第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。</p>
<p>客户端只有确定了自己能与服务端连接上才能开始发数据。所以两次握手肯定是最基本的。</p>
<p>看到这里，你或许会问，那么为什么需要第三次握手呢？我们来看一下，假设一下如果没有第三次握手，而是两次握手后我们就认为连接成功了，那么会发生什么？</p>
<p>第三次握手是为了<strong>防止已经失效的连接请求报文段突然又传到服务端，因而产生错误</strong>。</p>
<p>譬如发起请求遇到类似这样的情况：客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但是此时服务端仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手。</p>
<p>如果只有两次握手，那么到这里，连接就建立了，但是此时客户端并没有任何数据要发送，而服务端还在傻傻的等候佳音，造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。</p>
<h4 id="三次握手过程">三次握手过程</h4>
<img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426105615672.png" alt="image-20200426105615672" style="zoom:150%;">
<p>服务器必须准备好接受外来的连接。这通过调用socket、 bind和listen函数来完成，称为被动打开(passive open)。</p>
<p>第一次握手：客户通过调用connect进行主动打开(active open)。这引起客户TCP发送一个SYN(表示同步)分节(SYN=J)，它告诉服务器客户将<strong>在连接中发送到数据的初始序列号</strong>。并进入SYN_SEND状态，等待服务器的确认。</p>
<p>第二次握手：服务器必须确认客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器以单个字节向客户发送SYN和对客户SYN的<strong>ACK(表示确认)</strong>，此时服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户收到服务器的SYN+ACK。向服务器发送确认分节，此分节发送完毕，客户服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>客户端的初始序列号为J，而服务器的初始序列号为K。在ACK里的确认号为发送这个ACK的一端所期待的下一个序列号。因为SYN只占一个字节的序列号空间，所以每一个SYN的ACK中的确认号都是相应的初始序列号加1.类似地，每一个**FIN(表示结束)**的ACK中的确认号为FIN的序列号加1.</p>
<h3 id="TCP连接的终止">TCP连接的终止</h3>
<p><img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426104628587.png" alt="image-20200426104628587"></p>
<p>Step 1.应用首先调用close，主动关闭，发送一个FIN，表示数据发送完毕。</p>
<p>Step 2.另一端执行被动关闭，FIN由TCP确认，接收也作为文件结束符传递给接收方，在此连接上再也收不到数据</p>
<p>Step 3.收到文件结束的应用将调用close关闭它的套接口，它的TCP也发送一个FIN。</p>
<p>Step 4.接收到这个FIN的发送方TCP对之确认。</p>
<p>图中是客户执行主动关闭，而实际上，不管客户还是服务器都可以执行主动关闭，通常是由客户主动关闭，然而，如HTTP是客户端/服务器执行主动关闭？</p>
<p>第一次握手：某个应用进程首先调用close，我们称这一端执行主动关闭。这一端的TCP于是发送一个FIN分节，表示数据发送完毕。</p>
<p>第二次握手：接收到FIN的另一端执行被动关闭(passive close)。这个FIN由TCP确认。它的接收也作为文件结束符传递给接收端应用进程(放在已排队等候应用进程接收到任何其他数据之后)</p>
<p>第三次握手：一段时间后，接收到文件结束符的应用进程将调用close关闭它的套接口。这导致它的TCP也发送一个FIN。</p>
<p>第四次握手：接收到这个FIN的原发送端TCP对它进行确认。</p>
<p>面向字节的数据传送流(如TCP字节流、Unix管道等)也使用EOF表示在某个方向上不再有数据待传送。在TCP字节流中，EOF的读或写通过收发一个特殊的FIN分节来实现。</p>
<img src="/2018/12/21/Network/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200426105449109.png" alt="image-20200426105449109" style="zoom:150%;">
<p>如何计算时延，抖动？？？时延一会小一会大</p>
<h3 id="datetimes-c">datetimes.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************/</span></span><br><span class="line"><span class="comment">/************* datetime Example Server **************/</span></span><br><span class="line"><span class="comment">/****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"datetime.h"</span></span></span><br><span class="line"><span class="comment">// #include &lt;sys/time.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd; <span class="comment">// file discripter</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">	<span class="keyword">time_t</span> ticks;</span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">50000</span>);</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	<span class="built_in">listen</span>(listenfd, <span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">char</span>* str = <span class="string">"Start listening"</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">	<span class="comment">// fflush(stdout); // printf如果没有换行符，则不会立即输出，需要调用fflush</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		connfd = accept(listenfd, (struct sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"client: %s:%d\n"</span>,servaddr.sin_addr,servaddr.sin_port);</span><br><span class="line">		<span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">"%.24s\r\n"</span>, ctime(&amp;ticks));</span><br><span class="line">		<span class="built_in">write</span>(connfd, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">		<span class="built_in">close</span>(connfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关函数</p>
<h2 id="不清楚的概念">不清楚的概念</h2>
<p>TCP/IP</p>
<p>FTP/Telnet</p>
<p>API</p>
<p>网络编程API有两种：sockets和XTI？？？</p>
<p>协议族</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>network programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上用VMware创建虚拟机</title>
    <url>/2019/03/21/OS&amp;VM/linux_vmware/</url>
    <content><![CDATA[<h2 id="1-vmware">1.vmware</h2>
<p>发现隐藏的虚拟机</p>
<p>隐藏 – 只是选择移除，没有删除磁盘文件</p>
<a id="more"></a>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200222225503607.png" alt="image-20200222225503607"></p>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200222225448804.png" alt="image-20200222225448804"></p>
<p>*.vmdk是虚拟硬盘文件</p>
<p>*.vmsn是快照文件</p>
<p>*.vmx是虚拟机的配置文件</p>
<p>如果在虚拟机开机状态下保存快照，还会有*.vmem的快照内存文件（很大！）。</p>
<p>VMware的快照其实就是一个新的vmdk文件。<br>
其原理就是创建快照的那个时间点开始，新的数据的记录在新的vmdk文件中了。<br>
存储位置就是当前虚拟机的存储目录。</p>
<h3 id="设置虚拟网络">设置虚拟网络</h3>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200228122708097.png" alt="image-20200228122708097"></p>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200228122724909.png" alt="image-20200228122724909"></p>
<p>双击</p>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200228122808065.png" alt="image-20200228122808065"></p>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200228122915193.png" alt="image-20200228122915193"></p>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200228122934833.png" alt="image-20200228122934833"></p>
<p><img src="/2019/03/21/OS&VM/linux_vmware/image-20200228123029079.png" alt="image-20200228123029079"></p>
<h2 id="2-linux">2. linux</h2>
<h3 id="vim">vim</h3>
<p>i：插入模式，可以正常编辑</p>
<p>想要退出：先按esc，再输入:wq，即可保存退出</p>
<p>vim撤销操作：u</p>
<p>vim恢复操作：ctrl+r</p>
<h3 id="防火墙">防火墙</h3>
<p>禁用防火墙和SELNUX<br>
systemctl stop firewalld.service #停止firewall<br>
systemctl disable firewalld.service #禁止firewall开机启动<br>
firewall-cmd --state #查看默认防火墙状态（关闭后显示not running，开启后显示running）</p>
<p>设置vim /etc/selinux/config 文件，将SELINUX设置为disabled<br>
vim /etc/selinux/config</p>
<ul>
<li>
<p>切换登录用户</p>
<p>su - oracle</p>
</li>
<li>
<p>编辑文件</p>
<p>vim 绝对路径</p>
<p>vim 相对路径，默认为当前目录（得先cd到这个目录下面）</p>
</li>
<li>
<p>进入目录</p>
<p>cd</p>
</li>
<li>
<p>显示当前目录文件</p>
<p>ll：罗列出当前文件或目录的<strong>详细信息</strong>，含有时间、读写权限、大小、时间等信息 ，像Windows显示的详细信息。ll是“ls -l&quot;的别名。相当于Windows里的快捷方式。可以理解为 ll 和 ls -l 的功能是相同的， ll 是 ls -l 的别名。</p>
<p>ls：仅罗列出当前<strong>文件名或目录名</strong> 就像Windows里的文件列表。</p>
</li>
<li>
<p>（命令）别名查看</p>
<p>ll 是 ls -l 的别名查看方法，使用:（alias）查看别名情况</p>
</li>
<li>
<p>.bashrc</p>
<p>位置：在~目录下</p>
<p>为了加载你的配置，bash 在每次启动时都会加载 <code>.bashrc</code> 文件的内容。每个用户的 home 目录都有这个 shell 脚本。它用来存储并加载你的终端配置和环境变量。</p>
<p>终端配置可以包含很多不同的东西。最常见的，<code>.bashrc</code> 文件包含<strong>用户想要用的别名</strong>。别名允许用户通过更短的名字或替代的名字来指向命令，对于经常在终端下工作的人来说这可是一个省时利器。</p>
<p>alias sqlplus=‘rlwrap sqlplus’<br>
alias rman=‘rlwrap rman’</p>
</li>
<li>
<p>后台图形界面</p>
<p>gedit</p>
<p>环境变量</p>
<p>export DISPLAY=192.168.11.1:0.0</p>
</li>
<li>
<p>mkdir</p>
<p>创建目录</p>
</li>
<li>
<p>chown</p>
<p>改变owner</p>
</li>
<li>
<p>chmod</p>
<p>改变模式</p>
</li>
<li>
<p>groupadd</p>
<p>添加组和用户</p>
</li>
</ul>
<h3 id="引号">引号</h3>
<p>所有字符都是在英文输入状态下输入。如果现在的工作目录是/home/user，环境变量PATH=/bin:/usr/bin，当前shell的环境变量中没有VAR_NAME</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#输出pwd</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#输出/home/user</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="comment">#输出/bin:/usr/bin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$PATH'</span></span><br><span class="line"><span class="comment">#输出$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR_NAME</span>/lib:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="comment">#输出/lib:/bin:/usr/bin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$VAR_NAME/lib:$PATH'</span></span><br><span class="line"><span class="comment">#输出$VAR_NAME/lib:$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$VAR_NAME/lib:'</span><span class="string">"<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="comment">#输出$VAR_NAME/lib:/bin:/usr/bin</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">倒单引号&#96;</span><br><span class="line">&#96;要执行的名&#96;</span><br><span class="line">&#96;是键盘上TAB键上方的那个键。</span><br><span class="line"></span><br><span class="line">双引号&quot;</span><br><span class="line">&quot;对变量会解析的字符串&quot;</span><br><span class="line">如果字符串中包含$VAR_NAME之类的串，这个串将会被环境变量中的相应值取代，如果环境变量中没有相应的变量则用空字符串替代。</span><br><span class="line"></span><br><span class="line">单引号&#39;</span><br><span class="line">&#39;常量字符串&#39;串中的所有字符原样保持不变</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS&amp;VM</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>如何合并分区</title>
    <url>/2019/03/21/OS&amp;VM/%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<p>先把D盘的软件卸载、数据备份</p>
<p>直接删除卷（系统帮你格式化、清除数据）</p>
<p>如果待合并的盘使系统盘，则不能直接合并</p>
<a id="more"></a>
<p><a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="noopener">https://www.microsoft.com/zh-cn/software-download/windows10</a></p>
<p>然后选择为另一台电脑创建安装介质</p>
<p>需要将电脑从U盘启动（进入BIOS）</p>
<p>然后会提示为该电脑安装windows，但不要把流程走完</p>
<p><img src="/2019/03/21/OS&VM/%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA/1.jpg" alt="1"></p>
<p><img src="/2019/03/21/OS&VM/%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA/2.jpg" alt="2"></p>
<p><img src="/2019/03/21/OS&VM/%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA/3-1627108580891.jpg" alt="3"></p>
<p>中间有一个自定义</p>
<p><img src="/2019/03/21/OS&VM/%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA/4.jpg" alt="4"></p>
<p><img src="/2019/03/21/OS&VM/%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA/5.jpg" alt="5"></p>
<p><img src="/2019/03/21/OS&VM/%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA/7.jpg" alt="7"></p>
<p>遇到的问题</p>
<p>windows 无法安装到这个磁盘。选中的磁盘具有MBR分区表。在EFI系统上,windows 只能安装到GPT磁盘</p>
<p><a href="http://www.lotpc.com/dngz/8844.html" target="_blank" rel="noopener">http://www.lotpc.com/dngz/8844.html</a></p>
<p>解决方法：U盘启动方式不对，用legacy first，而不是UEFI first</p>
]]></content>
      <categories>
        <category>OS&amp;VM</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>合并分区</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 12c中的c</title>
    <url>/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/</url>
    <content><![CDATA[<h2 id="创建容器数据库（cdb）">创建容器数据库（cdb）</h2>
<p>test - 20210405</p>
<p>不建议手工创建，否则一堆问题</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DISPLAY&#x3D;192.168.11.1:0.0</span><br><span class="line">dbca</span><br></pre></td></tr></table></figure>
<ul>
<li>创建模式 - 高级配置</li>
<li>全局数据库名 - cdb</li>
<li>创建为容器数据库</li>
<li>取消将本地还原表空间用于PDB（Oracle认证考试时取消）</li>
<li>pdb名称 - pdb1</li>
<li>将下列用于数据库存储属性（文件系统）</li>
<li>指定快速恢复区</li>
<li>启用归档</li>
<li>配置选项 - 实例方案 - 将实例方案添加到数据库</li>
<li>创建选项 - 所有用户使用同一口令（admin）</li>
<li>开始创建就好了</li>
</ul>
<h2 id="cdb和non-cdb">cdb和non-cdb</h2>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417083351622.png" alt="image-20200417083351622" style="zoom:67%;">
<p>==cdb == 一个例程接多个数据库==</p>
<p>dba管好cdb，分部门管好自己的数据</p>
<p>重要</p>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417083517069.png" alt="image-20200417083517069" style="zoom:67%;">
<p>可插拔数据库（PDB）pluggable</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> pdbs</span><br><span class="line"></span><br><span class="line">    CON_ID CON_NAME                       <span class="keyword">OPEN</span> <span class="keyword">MODE</span>  <span class="keyword">RESTRICTED</span></span><br><span class="line"><span class="comment">---------- ------------------------------ ---------- ----------</span></span><br><span class="line">         <span class="number">2</span> PDB$<span class="keyword">SEED</span>                       <span class="keyword">READ</span> <span class="keyword">ONLY</span>  <span class="keyword">NO</span></span><br><span class="line">         <span class="number">3</span> PDB1                           <span class="keyword">READ</span> WRITE <span class="keyword">NO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> con_name</span><br><span class="line"><span class="comment">-- CDB$ROOT</span></span><br><span class="line"><span class="keyword">show</span> con_id</span><br><span class="line"><span class="comment">-- 1</span></span><br></pre></td></tr></table></figure>
<p>第一个是总的，pdb1是新建的哪个</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> con_id,<span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">tablespace</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    CON_ID NAME</span><br><span class="line"><span class="comment">---------- ------------------------------------------------------------</span></span><br><span class="line">         1 SYSAUX</span><br><span class="line">         1 SYSTEM</span><br><span class="line">         1 UNDOTBS1</span><br><span class="line">         1 USERS</span><br><span class="line">         1 TEMP</span><br><span class="line">         2 SYSTEM</span><br><span class="line">         2 TEMP</span><br><span class="line">         2 SYSAUX</span><br><span class="line">         3 TEMP</span><br><span class="line">         3 SYSTEM</span><br><span class="line">         3 SYSAUX</span><br><span class="line">         3 USERS</span><br><span class="line"></span><br><span class="line">12 rows selected.</span><br></pre></td></tr></table></figure>
<p>系统数据共享？</p>
<p>cdb下，系统数据分两部分</p>
<ul>
<li>Oracle系统数据：放在cdb_root里</li>
<li>用户的系统数据：放在每个用户的system表空间里。用户表的定义（表的创建者等信息）</li>
</ul>
<p>非cdb时，两部分混在一起</p>
<p>物理结构（查看哪些是共享的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 初始化文件只有一个（因为instance只有一个）</span></span><br><span class="line"><span class="keyword">show</span> parameter <span class="keyword">spfile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">NAME</span>                                 <span class="keyword">TYPE</span>                   <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line"><span class="keyword">spfile</span>                               <span class="keyword">string</span>                 /u01/app/<span class="keyword">oracle</span>/product/<span class="number">12.2</span><span class="number">.0</span></span><br><span class="line">                                                            /dbhome_1/dbs/spfilecdb.ora</span><br><span class="line"><span class="comment">-- 控制文件、日志文件共享，只在根下</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">controlfile</span>;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">/u01/app/oracle/oradata/cdb/control01.ctl</span><br><span class="line">/u01/app/oracle/fast_recovery_area/cdb/control02.ctl</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">group</span><span class="comment">#,con_id from v$logfile;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">GROUP</span><span class="comment">#     CON_ID</span></span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         <span class="number">3</span>          <span class="number">0</span></span><br><span class="line">         <span class="number">2</span>          <span class="number">0</span></span><br><span class="line">         <span class="number">1</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据文件无法共享（根 + 总支 + pdb）</span></span><br><span class="line"><span class="comment">-- pdb中只有数据文件了</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;</span><br></pre></td></tr></table></figure>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417084723162.png" alt="image-20200417084723162" style="zoom:80%;">
<p>术语发生变化</p>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417084820564.png" alt="image-20200417084820564" style="zoom:67%;">
<p>数据字典视图结构发生变化</p>
<p><code>dba_外面又有一层cdb_</code></p>
<p>abc都对</p>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417084953390.png" alt="image-20200417084953390" style="zoom:67%;">
<p>架构图，考试，和非cdb的不同点</p>
<p><img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417085120398.png" alt="image-20200417085120398"></p>
<ul>
<li>一对一，多对一</li>
<li>共享不同</li>
</ul>
<p>初始化参数文件不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter enable_pluggable_database</span><br></pre></td></tr></table></figure>
<p>考试a（实际上可以修改？？？）</p>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417085718644.png" alt="image-20200417085718644" style="zoom:67%;">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> pdbs</span><br><span class="line"><span class="comment">-- 看是不是容器数据库</span></span><br><span class="line"><span class="keyword">desc</span> v$<span class="keyword">database</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, cdb <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- cdb下yes</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, cdb <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- sales下no</span></span><br><span class="line"></span><br><span class="line">col username for a20</span><br><span class="line"><span class="keyword">select</span> username,con_id <span class="keyword">from</span> cdb_users <span class="keyword">where</span> username=<span class="string">'HR'</span>;</span><br><span class="line"><span class="comment">-- 1原来就有hr，3克隆1，顺便把用户也带上了</span></span><br><span class="line">USERNAME                 CON_ID</span><br><span class="line"><span class="comment">-------------------- ----------</span></span><br><span class="line">HR                            3</span><br><span class="line">HR                            5</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> pdbs</span><br><span class="line">    CON_ID CON_NAME                       <span class="keyword">OPEN</span> <span class="keyword">MODE</span>  <span class="keyword">RESTRICTED</span></span><br><span class="line"><span class="comment">---------- ------------------------------ ---------- ----------</span></span><br><span class="line">         <span class="number">2</span> PDB$<span class="keyword">SEED</span>                       <span class="keyword">READ</span> <span class="keyword">ONLY</span>  <span class="keyword">NO</span></span><br><span class="line">         <span class="number">3</span> PDB1                           <span class="keyword">READ</span> <span class="keyword">ONLY</span>  <span class="keyword">NO</span></span><br><span class="line">         <span class="number">4</span> PDB2                           <span class="keyword">READ</span> WRITE <span class="keyword">NO</span></span><br><span class="line">         <span class="number">5</span> PDB3                           <span class="keyword">READ</span> WRITE <span class="keyword">NO</span></span><br></pre></td></tr></table></figure>
<h2 id="创建pdb">创建pdb</h2>
<h3 id="1-基于pdb种子数据库创建pdb">1. 基于pdb种子数据库创建pdb</h3>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417085928678.png" alt="image-20200417085928678" style="zoom:67%;">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col name for a50</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span> <span class="keyword">where</span> con_id=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span> <span class="keyword">where</span> con_id=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span> <span class="keyword">where</span> con_id=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- os</span></span><br><span class="line">mkdir -p /u01/app/oracle/oradata/cdb/pdbseed/</span><br><span class="line">mkdir -p /u01/app/oracle/oradata/cdb/pdb2/</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> pdb_file_name_convert=<span class="string">'/u01/app/oracle/oradata/cdb/pdbseed/'</span>,<span class="string">'/u01/app/oracle/oradata/cdb/pdb2/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb2 <span class="keyword">admin</span> <span class="keyword">user</span> pdb2admin <span class="keyword">identified</span> <span class="keyword">by</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb2 <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-克隆本地pdb">2.克隆本地pdb</h3>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417090536311.png" alt="image-20200417090536311" style="zoom:67%;">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb1 <span class="keyword">close</span>;</span><br><span class="line"><span class="keyword">show</span> pdbs</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb1 <span class="keyword">open</span> <span class="keyword">read</span> <span class="keyword">only</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- os</span></span><br><span class="line">mkdir -p /u01/app/oracle/oradata/cdb/pdb3/</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb3 <span class="keyword">from</span> pdb1 <span class="keyword">file_name_convert</span>=(<span class="string">'/u01/app/oracle/oradata/cdb/pdb1/'</span>,<span class="string">'/u01/app/oracle/oradata/cdb/pdb3/'</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb3 <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-把非pdb插入cdb">3.把非pdb插入cdb</h3>
<p><img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417092430038.png" alt="image-20200417092430038"></p>
<p><img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417093150625.png" alt="image-20200417093150625"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SYS@sales&gt;</span></span><br><span class="line">shutdown immediate</span><br><span class="line">startup open read only</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,open_mode <span class="keyword">from</span> v$<span class="keyword">database</span>;</span><br><span class="line"></span><br><span class="line">NAME               OPEN_MODE</span><br><span class="line"><span class="comment">------------------ ----------------------------------------</span></span><br><span class="line">SALES              READ ONLY</span><br><span class="line"></span><br><span class="line">exec dbms_pdb.describe(PDB_DESCR_FILE=&gt;<span class="string">'/u01/app/oracle/oradata/sales/sales.xml'</span>);</span><br><span class="line"><span class="comment">-- 查看是否产生，用来描述数据库信息</span></span><br><span class="line">shutdown immediate</span><br><span class="line"><span class="comment">-- drop pluggable database db12c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- cdb下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> sales <span class="keyword">using</span> <span class="string">'/u01/app/oracle/oradata/sales/sales.xml'</span></span><br><span class="line">copy</span><br><span class="line"><span class="keyword">FILE_NAME_CONVERT</span>=(<span class="string">'/u01/app/oracle/oradata/sales/'</span>,<span class="string">'/u01/app/oracle/oradata/cdb/sales/'</span>);</span><br><span class="line"></span><br><span class="line">col name for a20</span><br><span class="line">col restricted for a16</span><br><span class="line"><span class="keyword">select</span> con_id,<span class="keyword">name</span>,open_mode,<span class="keyword">restricted</span> <span class="keyword">from</span> v$pdbs;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 千万别打开</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> <span class="keyword">container</span>=sales;</span><br><span class="line"><span class="comment">-- 执行脚本，去除不需要的元数据</span></span><br><span class="line">@?/rdbms/admin/noncdb_to_pdb</span><br><span class="line">conn / as sysdba</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> con_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> <span class="keyword">container</span>=sales; <span class="comment">-- 记得换容器</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> sales <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-pdb的拔插和删除">4. pdb的拔插和删除</h3>
<p><img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417095135258.png" alt="image-20200417095135258"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 换回cdb</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> <span class="keyword">container</span>=cdb$root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb1 <span class="keyword">close</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb1 unplug <span class="keyword">into</span> <span class="string">'/u01/app/oracle/oradata/cdb/pdb1.xml'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> pdb1 <span class="keyword">keep</span> <span class="keyword">datafiles</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,open_mode <span class="keyword">from</span> v$pdbs;</span><br></pre></td></tr></table></figure>
<h2 id="使用pdb">使用pdb</h2>
<h3 id="连接和切换">连接和切换</h3>
<p>连接到pdb</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn sys/admin@192.168.11.200:1521/pdb1 as sysdba</span><br><span class="line">conn sys/admin@192.168.11.200/sales as sysdba</span><br><span class="line"><span class="comment">-- 默认端口1521可以不写</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure>
<p>为pdb做服务名（服务名都写pdb1，主机名192.168.11.200）</p>
<p>之后就可以这样登录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn system/admin@pdb1</span><br><span class="line"><span class="comment">-- 或者sqlplus</span></span><br></pre></td></tr></table></figure>
<p>连接到cdb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conn sys&#x2F;admin@cdb as sysdba</span><br></pre></td></tr></table></figure>
<p>切换cdb和pdb</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 换回cdb</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> <span class="keyword">container</span>=cdb$root;</span><br><span class="line"><span class="comment">-- 切换到pdb</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> <span class="keyword">container</span>=pdb1;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417095612499.png" alt="image-20200417095612499"></p>
<p><img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417095655521.png" alt="image-20200417095655521"></p>
<p>关cdb之后，再起，发现所有pdb都是mounted，需要手动</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- cdb下</span></span><br><span class="line">shutdown immediate</span><br><span class="line">startup</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> <span class="keyword">all</span> <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>
<p>自动怎么办</p>
<ul>
<li>
<p>触发器</p>
</li>
<li>
<p>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> <span class="keyword">all</span> <span class="keyword">save</span> state;</span><br><span class="line"><span class="comment">-- 保留关闭时的状态</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">pluggable</span> <span class="keyword">database</span> <span class="keyword">all</span> discard state;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>之后没听</p>
<p>==pdb，只能看到数据文件==</p>
<p>改初始化参数对pdb的影响</p>
<p>有的参数不能在pdb里改，只能在cdb上改</p>
<p>能改的一般都只影响自己的pdb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter target_pdbs</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE                   VALUE</span><br><span class="line">------------------------------------ ---------------------- ------------------------------</span><br><span class="line">target_pdbs                          integer                3</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417101300271.png" alt="image-20200417101300271"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter session_max_open_files</span><br><span class="line">show parameter circuits</span><br></pre></td></tr></table></figure>
<p>有的命令只能在cdb上做（切换日志文件）</p>
<p>能在pdb上做的：做检查点，但是影响了整个cdb</p>
<h3 id="公共用户-本地用户">公共用户&amp;本地用户</h3>
<p>考试（互相指派能不能，多选题</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="comment">-- cdb下</span></span><br><span class="line"> <span class="comment">-- 只能建公共用户</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> dba_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- create user test identified by 123123; -- 不能</span></span><br><span class="line"><span class="keyword">show</span> parameter prefix</span><br><span class="line"><span class="comment">-- 公共用户前缀必须是C##</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> C<span class="comment">##test identified by 123123;</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">session</span> <span class="keyword">to</span> C<span class="comment">##test; -- 默认本地权限</span></span><br><span class="line"><span class="keyword">conn</span> C<span class="comment">##test/123123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果公共用户要登到pdb</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">session</span> <span class="keyword">to</span> C<span class="comment">##test container=all; -- sys给了公共权限</span></span><br><span class="line"><span class="keyword">conn</span> C<span class="comment">##test/123123@pdb1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不能将公共权限给本地用户，别的都可以</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- pdb下</span></span><br><span class="line"><span class="comment">-- 本地用户只在pdb可见，cdb不可见？？？</span></span><br></pre></td></tr></table></figure>
<img src="/2020/04/17/Oracle/Oracle12c%E4%B8%AD%E7%9A%84c/image-20200417104917764.png" alt="image-20200417104917764" style="zoom:67%;">
<h2 id="考试">考试</h2>
<p>架构：区分是cdb还是非cdb（20分）</p>
<p>SQL：只靠QL</p>
<p>查询、条件、排序（top n功能、连接、子查询、函数）</p>
<p>例程管理（启动的过程）</p>
<p>控制文件（包含内容、出了问题怎么复用）</p>
<p>日志文件（联机 重做日志文件 + 归档日志文件）</p>
<p>表空间和数据文件（结构，基本管理）</p>
<p>Oracle安全3a？？？</p>
<p>数据移动 logmnr步骤！！！</p>
<p>备份和恢复 完全恢复和不完全恢复</p>
<p>闪回技术</p>
<p>多租户架构</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle SQL_part2</title>
    <url>/2020/03/10/Oracle/OracleSQL_part2/</url>
    <content><![CDATA[<h2 id="2-DML">2 DML</h2>
<h3 id="insert">insert</h3>
<p><img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200313103122536.png" alt="image-20200313103122536"></p>
<p>如果全部字段都有值，则可以不写列名</p>
<p>如果部分字段为null，两种方法（显式/隐式）</p>
<a id="more"></a>
<p><img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415122923453.png" alt="image-20200415122923453"></p>
<p>没听到？？？</p>
<p>插入日期类型时，注意用to_date</p>
<p>插入数据和用户交互，用&amp;</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415123218099.png" alt="image-20200415123218099" style="zoom:80%;">
<p>嵌入子查询，可以同时插入很多条记录</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415123136515.png" alt="image-20200415123136515" style="zoom:80%;">
<h3 id="update">update</h3>
<p>注意写where条件，否则全部更新</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415123421013.png" alt="image-20200415123421013" style="zoom:80%;">
<p>如果更新多个字段，set后用逗号隔开</p>
<p>子查询嵌入set部分，提高效率（省的取两次数据）</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200317140650155.png" alt="image-20200317140650155" style="zoom:67%;">
<p>子查询嵌入where部分</p>
<p><img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415123918356.png" alt="image-20200415123918356"></p>
<h3 id="delete">delete</h3>
<p>不加条件则全部删除</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415123612794.png" alt="image-20200415123612794" style="zoom:80%;">
<p>嵌入子查询</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415123713405.png" alt="image-20200415123713405" style="zoom: 80%;">
<p>truncate</p>
<p>不是DML语句</p>
<h3 id="merge">merge</h3>
<p>表的合并（没有的就insert，有的就update）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- db12c下的scott中</span></span><br><span class="line"><span class="comment">-- 汇总hz、工作gz</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.emp_hz <span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">where</span> deptno = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.emp_gz <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz <span class="keyword">where</span> <span class="number">1</span>=<span class="number">2</span>; <span class="comment">-- 空表，数据模式相同</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_gz <span class="keyword">values</span>(<span class="number">1234</span>,<span class="string">'Tom'</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_gz <span class="keyword">values</span>(<span class="number">7900</span>,<span class="string">'JAMES'</span>,<span class="number">1900</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz;</span><br><span class="line">     EMPNO ENAME                       SAL</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">      7499 ALLEN                      1600</span><br><span class="line">      7521 WARD                       1250</span><br><span class="line">      7654 MARTIN                     1250</span><br><span class="line">      7698 BLAKE                      2850</span><br><span class="line">      7844 TURNER                     1500</span><br><span class="line">      7900 JAMES                      1900</span><br><span class="line">      1234 Tom                        3000</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_gz;</span><br><span class="line">     EMPNO ENAME                       SAL</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">      1234 Tom                        3000</span><br><span class="line">      7900 JAMES                      1900</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将gz表合并到hz表中</span></span><br><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> scott.emp_hz hz</span><br><span class="line"><span class="keyword">using</span> scott.emp_gz gz</span><br><span class="line"><span class="keyword">on</span> (hz.empno=gz.empno)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> hz.ename = gz.ename, hz.sal = gz.sal</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">not</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">values</span>(gz.empno,gz.ename,gz.sal);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 实际操作为更新Tom，插入James</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz;</span><br><span class="line">     EMPNO ENAME                       SAL</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">      7499 ALLEN                      1600</span><br><span class="line">      7521 WARD                       1250</span><br><span class="line">      7654 MARTIN                     1250</span><br><span class="line">      7698 BLAKE                      2850</span><br><span class="line">      7844 TURNER                     1500</span><br><span class="line">      7900 JAMES                      1900</span><br><span class="line">      1234 Tom                        3000</span><br></pre></td></tr></table></figure>
<h2 id="3-TCL">3 TCL</h2>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200415125047943.png" alt="image-20200415125047943" style="zoom:80%;">
<h3 id="commit-rollback-savepoint">commit rollback savepoint</h3>
<p>commit和rollback只是显式提交、显式回滚</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 全部回滚</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_hz <span class="keyword">values</span>(<span class="number">1111</span>,<span class="string">'aaa'</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz;</span><br><span class="line"><span class="keyword">savepoint</span> aaa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> scott.emp_hz <span class="keyword">where</span> empno=<span class="number">7900</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 发现删错了James，rollback</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回滚事务的所有操作（会连insert一起回滚）</span></span><br></pre></td></tr></table></figure>
<p>只要事务结束（commit / rollback），则savepoints都会被擦除，不能rollback to savepoint aaa;了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 回滚到记录点</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_hz <span class="keyword">values</span>(<span class="number">1111</span>,<span class="string">'aaa'</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz;</span><br><span class="line"><span class="keyword">savepoint</span> aaa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> scott.emp_hz <span class="keyword">where</span> empno=<span class="number">7900</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 发现删错了James，rollback</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> <span class="keyword">savepoint</span> aaa; <span class="comment">-- 回滚到某一个记录点，insert没有被回滚</span></span><br></pre></td></tr></table></figure>
<h3 id="alter">alter</h3>
<p>修改表的默认值</p>
<p>有坑！！！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 本来有7条记录</span></span><br><span class="line">     EMPNO ENAME                       SAL</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">      7499 ALLEN                      1600</span><br><span class="line">      7521 WARD                       1250</span><br><span class="line">      7654 MARTIN                     1250</span><br><span class="line">      7698 BLAKE                      2850</span><br><span class="line">      7844 TURNER                     1500</span><br><span class="line">      7900 JAMES                      1900</span><br><span class="line">      1111 aaa                        2000</span><br><span class="line">      </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_hz (empno) <span class="keyword">values</span>(<span class="number">2222</span>);</span><br><span class="line"><span class="comment">-- 实际8，外部看7</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.emp_hz <span class="keyword">modify</span> ename <span class="keyword">default</span> <span class="string">'zhangsan'</span>; <span class="comment">-- 此时隐式提交了</span></span><br><span class="line"><span class="comment">-- 实际8，外部看8</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_hz (empno) <span class="keyword">values</span>(<span class="number">3333</span>);</span><br><span class="line"><span class="comment">-- 实际9，外部看还是8，因为新的事务未提交</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp_hz <span class="keyword">to</span> hr; <span class="comment">-- sys或者scott下赋权限，此时也会隐式提交</span></span><br><span class="line"><span class="comment">-- 实际9，外部看9</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_hz (empno) <span class="keyword">values</span>(<span class="number">4444</span>);</span><br><span class="line"><span class="comment">-- 实际10，外部看9</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 实际10，外部看10</span></span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                       SAL</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">      7499 ALLEN                      1600</span><br><span class="line">      7521 WARD                       1250</span><br><span class="line">      7654 MARTIN                     1250</span><br><span class="line">      7698 BLAKE                      2850</span><br><span class="line">      7844 TURNER                     1500</span><br><span class="line">      7900 JAMES                      1900</span><br><span class="line">      1111 aaa                        2000</span><br><span class="line">      2222</span><br><span class="line">      3333 zhangsan</span><br><span class="line">      4444 zhangsan</span><br></pre></td></tr></table></figure>
<p>事务未结束时，别的用户看不到（ACID中的I）</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200313110349993.png" alt="image-20200313110349993" style="zoom:67%;">
<h3 id="显示提交-隐式提交">显示提交&amp;隐式提交</h3>
<h4 id="显式提交">显式提交</h4>
<p>用COMMIT命令直接完成的提交为显式提交</p>
<h4 id="隐式提交">隐式提交</h4>
<p>用SQL命令间接完成的提交为隐式提交，==隐式提交==的情形</p>
<ul>
<li>正常执行完DDL：create，alter，drop，truncate，rename。</li>
<li>正常执行完DCL：grant，revoke</li>
<li>正常退出：exit，没有明确发出commit或者rollback</li>
<li>异常退出：点x退出，会==回滚==。</li>
</ul>
<p>（此隐式提交是在自己的session，如果在其他人的session(如用户a)中正在修改相同的数据，则引起隐式提交的语句（用户a的k另一个session)则必需等待）</p>
<p><strong>隐式提交的注意事项</strong></p>
<p>1、执行ddl语句时，前面的dml操作也会被提交到数据库中</p>
<p>因为是在一个session里，那执行ddl语句的时候前面的dml语句肯定也会“不可幸免”的被提交到库中。</p>
<p>2、即使ddl语句执行失败，前面的dml操作也会被提交到数据库中</p>
<p>这就有点儿让人奇怪了，ddl都执行失败了，怎么还会提交呢？这就需要探究一下隐式提交的本质了（下文有叙述）。</p>
<p>3、在前面1和2的基础上总结</p>
<p>为了避免隐式提交或者回滚，尽量保证一条或者几条DML操作完成后有显示的提交或者回滚，防止后续执行的DCL或者DDL自动提交前期的DML操作。</p>
<p><strong>隐式提交的本质</strong></p>
<p>1、一条ddl语句执行了两次commit<br>
commit;<br>
ddl statement;<br>
commit;<br>
第一个commit将当前session中未提交的事务隐式提交，以保证ddl语句失败时的回滚位置。<br>
第二个commit将ddl提交</p>
<p>2、为什么需要隐式提交？</p>
<p>为了保证事务的一致性。我们在执行ddl语句的时候，oracle需要在它的系统表中进行元数据的记录操作（即：除了建表还会进行不少insert操作），如果它不隐式提交就无法保证一致性；从内部运行机制来看ddl语句和dml语句还是有很大区别的，dml会对每个语句的每条记录都做日志记录以便于回滚，而ddl往往没必要搞这么复杂，从功能和易用性上看隐式提交都是最好的选择。</p>
<h4 id="自动提交">自动提交</h4>
<p>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT ON;</span><br></pre></td></tr></table></figure>
<p>查看当前是否是自动提交：show autocommit</p>
<h3 id="读的一致性">读的一致性</h3>
<p>（重要）（考试？？？）</p>
<p>概念：事务开始前和事务开始后，别的事务看到的数据都是一样的</p>
<ul>
<li>没有事务的时候，“当前读”？？？</li>
<li>事务开始后，别的事务都从回滚段内访问数据，一样</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Scott下</span></span><br><span class="line"><span class="keyword">update</span> scott.emp_hz <span class="keyword">set</span> ename=<span class="string">'BBB'</span> <span class="keyword">where</span> empno=<span class="number">1111</span>; <span class="comment">-- 在这一行加锁</span></span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">update</span> scott.emp_hz <span class="keyword">set</span> ename=<span class="string">'CCC'</span> <span class="keyword">where</span> empno=<span class="number">1111</span>; <span class="comment">-- 上面如果不提交，这里会阻塞</span></span><br><span class="line"><span class="comment">-- scott下commit或者rollback，可以解除等待</span></span><br><span class="line"><span class="comment">-- sys下commit或者rollback</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz;</span><br><span class="line"><span class="comment">-- 别的数据库：事务未结束时，给表加锁，别的用户不能访问</span></span><br><span class="line"><span class="comment">-- oracle：读一致性。读不用等写，写不用等读，写需要等写</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200313111635286.png" alt="image-20200313111635286"></p>
<ul>
<li>
<p>当事务t1进行数据修改（删除）的时候，会将旧数据复制一份到回滚带上</p>
<p>（其他事务不允许修改，被锁住？？？）</p>
</li>
<li>
<p>脏数据在高速缓存中，别的事务不能访问</p>
</li>
<li>
<p>如果另外的事务前来查询发现这条记录被锁，不用等事务结束，会到回滚带上查询（查到的是旧数据）</p>
</li>
</ul>
<h3 id="回滚段的三个作用">回滚段的三个作用</h3>
<p>（考试）</p>
<p>A. 读一致性：</p>
<p>见上</p>
<p>B. 回滚：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 都删掉</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 无</span></span><br><span class="line"><span class="comment">-- 此时所有数据都在回滚段</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 自动把在回滚段的都拿回来（对冲操作？？？）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 回来了</span></span><br></pre></td></tr></table></figure>
<p>C. 闪回恢复？？？：已提交后也数据不怕丢掉，还可以从回滚段里把数据捞出来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 都删掉</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 无</span></span><br><span class="line"><span class="comment">-- rollback自动回滚回不来，但数据仍在回滚段？？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找回滚带（as of）上，3min之前，某个表的数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz <span class="keyword">as</span> <span class="keyword">of</span> <span class="built_in">timestamp</span>(systimestamp-<span class="built_in">interval</span> <span class="string">'3'</span> <span class="keyword">minute</span>);</span><br><span class="line"><span class="comment">-- 将这些数据插进去</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.emp_hz <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz <span class="keyword">as</span> <span class="keyword">of</span> <span class="built_in">timestamp</span>(systimestamp-<span class="built_in">interval</span> <span class="string">'3'</span> <span class="keyword">minute</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz; <span class="comment">-- 有</span></span><br></pre></td></tr></table></figure>
<h3 id="锁">锁</h3>
<p>两个会话的事务都有脏数据，两边update一行数据时，会有锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 会话A，改1111</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">update</span> scott.emp_hz <span class="keyword">set</span> sal=<span class="number">2500</span> <span class="keyword">where</span> empno=<span class="number">1111</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话B，改2222</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">update</span> scott.emp_hz <span class="keyword">set</span> ename=<span class="string">'CCCC'</span> <span class="keyword">where</span> empno=<span class="number">2222</span>;</span><br><span class="line"><span class="comment">-- 可以更新，说明加的不是表锁</span></span><br><span class="line"><span class="comment">-- AB此时互相看不到对方的脏数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话A，改2222，卡死</span></span><br><span class="line"><span class="keyword">update</span> scott.emp_hz <span class="keyword">set</span> sal=<span class="number">3500</span> <span class="keyword">where</span> empno=<span class="number">2222</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话B，改1111，卡死</span></span><br><span class="line"><span class="keyword">update</span> scott.emp_hz <span class="keyword">set</span> ename=<span class="string">'DDD'</span> <span class="keyword">where</span> empno=<span class="number">1111</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 死锁产生~</span></span><br><span class="line"><span class="comment">-- 会话A提示这条语句会产生死锁，自动回滚</span></span><br><span class="line"><span class="keyword">update</span> scott.emp_hz <span class="keyword">set</span> sal=<span class="number">3500</span> <span class="keyword">where</span> empno=<span class="number">2222</span></span><br><span class="line">                        *</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-00060</span>: deadlock detected <span class="keyword">while</span> waiting <span class="keyword">for</span> <span class="keyword">resource</span></span><br><span class="line"><span class="comment">-- 现在B还因为1111锁着，需要A commit或者rollback</span></span><br></pre></td></tr></table></figure>
<p>现在死锁变成锁了，如何解决</p>
<p>dba如何解决锁的问题，一般是杀进程，委婉一点就是通知那个会话的用户结束你的事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- dba上线（再开一个会话）</span></span><br><span class="line">desc v$<span class="keyword">lock</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> v$<span class="keyword">lock</span> <span class="keyword">where</span> <span class="keyword">block</span>=<span class="number">1</span>; <span class="comment">-- （1阻住，0未阻住）135，会话A造成的阻塞？？？</span></span><br><span class="line"></span><br><span class="line">desc v$session</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,<span class="built_in">serial</span><span class="comment"># from v$session where sid=135; -- 查找干掉这个进程的参数serial#</span></span><br><span class="line"><span class="comment">-- session == 会话</span></span><br><span class="line"><span class="comment">-- A被杀了，更新1111的sal的语句也被回滚</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">kill</span> <span class="keyword">session</span> <span class="string">'135,2022'</span>;</span><br><span class="line"><span class="comment">-- B解锁了，1111 name更新为DDD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- A被杀了，提示会话被杀</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp_hz</span><br><span class="line">*</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-00028</span>: your <span class="keyword">session</span> has been killed</span><br></pre></td></tr></table></figure>
<h2 id="4-DCL">4 DCL</h2>
<p>grant</p>
<p>revoke</p>
<h2 id="5-DDL">5 DDL</h2>
<ol>
<li>DML（增删改）只能改用户数据，不能不能直接操作系统数据（不能insert user_tables）</li>
<li>系统数据对用户来说是只读的，但对dba可以用DDL修改（增删改系统数据）</li>
</ol>
<p>数据定义语言</p>
<ul>
<li>增删改【对象】create、alter、drop</li>
<li>清空表truncate</li>
<li>给表rename</li>
<li>加注释comment</li>
</ul>
<h3 id="oracle常见对象">oracle常见对象</h3>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200317141638218.png" alt="image-20200317141638218" style="zoom:67%;">
<ol>
<li>
<p>表：</p>
</li>
<li>
<p>视图：指向表</p>
</li>
<li>
<p>序列：自动产生？？？</p>
</li>
<li>
<p>索引：无索引 / 有索引【一页一页翻 / 看目录】</p>
</li>
<li>
<p>同义词synonym，用于缩短名字？</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc user_objects</span><br><span class="line">col object_name for a20</span><br><span class="line">col object_type for a20</span><br><span class="line"><span class="keyword">select</span> object_name,object_type,namespace <span class="keyword">from</span> user_objects <span class="keyword">fetch</span> <span class="keyword">first</span> <span class="number">20</span> <span class="keyword">rows</span> <span class="keyword">only</span>;</span><br><span class="line"><span class="comment">-- 查找同一个namespace下会放哪些类型的对象</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">unique</span> object_type <span class="keyword">from</span> user_objects <span class="keyword">where</span> namespace=<span class="string">'1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查同一类型对象是不是会位于两个namespace</span></span><br><span class="line"><span class="comment">-- 除了undefined这个奇怪的对象类型，还有一个对象类型没有表空间</span></span><br><span class="line"><span class="keyword">select</span> a.object_type <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">unique</span> object_type, namespace <span class="keyword">from</span> user_objects) a</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> object_type</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 各种对象</span></span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> user_tables;</span><br><span class="line"><span class="keyword">select</span> view_name <span class="keyword">from</span> user_views;</span><br><span class="line"><span class="keyword">select</span> sequence_name <span class="keyword">from</span> user_sequences;</span><br><span class="line"><span class="keyword">select</span> index_name <span class="keyword">from</span> user_indexes; <span class="comment">-- user_indexes同义词ind</span></span><br><span class="line"><span class="keyword">select</span> synonym_name <span class="keyword">from</span> user_synonyms;</span><br><span class="line"><span class="keyword">select</span> trigger_name <span class="keyword">from</span> user_triggers;</span><br></pre></td></tr></table></figure>
<p>任何对象不可和同一用户下==相同名称空间namespace==的对象同名</p>
<p>表名不能为Oracle保留关键字：为procedure可以，trigger不行，function行</p>
<h3 id="表">表</h3>
<h4 id="建表">建表</h4>
<p>表名要合法</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200416220506116.png" alt="image-20200416220506116" style="zoom:50%;">
<p>建表的两个必须条件：</p>
<p>A、<strong>有创建的权限</strong></p>
<p>先创建一个用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> demo1 <span class="keyword">identified</span> <span class="keyword">by</span> abc;</span><br><span class="line"><span class="keyword">select</span> username,<span class="keyword">password</span>,ACCOUNT_STATUS <span class="keyword">from</span> dba_users <span class="keyword">where</span> username=<span class="string">'DEMO1'</span>;</span><br><span class="line"><span class="comment">-- 密码不显示？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时demo1没有create session的权限</span></span><br><span class="line">conn demo1/abc</span><br><span class="line">ERROR:</span><br><span class="line">ORA-01045: ▒û▒ DEMO1 û▒▒ <span class="keyword">CREATE</span> <span class="keyword">SESSION</span> Ȩ▒▒; ▒▒¼▒▒▒ܾ▒</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用oerr ora 01045查错误</span></span><br><span class="line"><span class="comment">-- sys下授权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">session</span> <span class="keyword">to</span> demo1;</span><br><span class="line">conn demo1/abc</span><br></pre></td></tr></table></figure>
<p>开始建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo1下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span>);</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01031: insufficient privileges</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下授权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> demo1;</span><br></pre></td></tr></table></figure>
<p>B、<strong>必须在一个表空间</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo1下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span>);</span><br><span class="line"><span class="comment">-- 创建到用户的默认表空间</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>; <span class="comment">-- users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">select</span> default_tablespace <span class="keyword">from</span> dba_users <span class="keyword">where</span> username=<span class="string">'DEMO1'</span>; <span class="comment">-- users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- demo1下</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01950: no privileges on tablespace 'USERS'</span><br></pre></td></tr></table></figure>
<p>能建表不能插入？没有对表空间的权限，为什么能建表？</p>
<p>靠参数控制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter defer</span><br><span class="line"></span><br><span class="line"><span class="keyword">NAME</span>                                 <span class="keyword">TYPE</span>                   <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line">deferred_segment_creation            <span class="built_in">boolean</span>                <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<p>建好了表，但没有分配空间，第一次使用的时候才分配</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys下（demo1下无法alter system）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> deferred_segment_creation=<span class="literal">false</span>; <span class="comment">--不允许延时，创建时就要分配表空间</span></span><br><span class="line"><span class="comment">-- demo1下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(<span class="keyword">id</span> <span class="built_in">int</span>); <span class="comment">-- 直接报错，没有user表空间的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> demo1 <span class="keyword">quota</span> <span class="number">5</span>m <span class="keyword">on</span> <span class="keyword">users</span>; <span class="comment">-- demo1可以使用user用户空间5兆空间</span></span><br><span class="line"><span class="comment">--alter user demo1 quota unlimited on users; -- demo1可以无限制使用user用户空间</span></span><br><span class="line"><span class="comment">-- 此时可以建表，插值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 没讲</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.t1(<span class="keyword">id</span> <span class="built_in">int</span>);             <span class="comment">--不可以create仅可对自己建表</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">any</span> <span class="keyword">table</span> <span class="keyword">to</span> scott;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.t1(<span class="keyword">id</span> <span class="built_in">int</span>);             <span class="comment">--demo对scott建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;<span class="comment">--基于其他表select要有权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> demo;</span><br></pre></td></tr></table></figure>
<h4 id="ps：伪列">ps：伪列</h4>
<p>eg level、rowid、rownum</p>
<p>伪列 == 独立于表存在【伪军，编制外】</p>
<p>由Oracle管理，不能进行增删改操作，只能查</p>
<ul>
<li>表的字段不能重名</li>
<li>字段不能和伪列重名</li>
</ul>
<h5 id="rowid的组成">rowid的组成</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,<span class="keyword">rowid</span>,<span class="keyword">rownum</span> <span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure>
<p>rowid ==  行的具体物理地址（Base64 code，数字字母和±一共64个字符，调用包解析为能看懂的信息）</p>
<ol>
<li>
<p>文件号</p>
</li>
<li>
<p>块号</p>
</li>
<li>
<p>行号</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc dbms_rowid <span class="comment">-- 这是一个包，里面有函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> empno,</span><br><span class="line">dbms_rowid.ROWID_RELATIVE_FNO(<span class="keyword">rowid</span>) <span class="keyword">File</span><span class="comment">#,</span></span><br><span class="line">dbms_rowid.ROWID_BLOCK_NUMBER(<span class="keyword">rowid</span>) <span class="keyword">BLOCK</span><span class="comment">#,</span></span><br><span class="line">dbms_rowid.ROWID_ROW_NUMBER(<span class="keyword">rowid</span>) <span class="keyword">ROW</span><span class="comment">#</span></span><br><span class="line"><span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span> <span class="keyword">where</span> <span class="keyword">file</span><span class="comment">#=7;</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name,file_name <span class="keyword">from</span> dba_data_files;</span><br></pre></td></tr></table></figure>
<p>==rowid“独立于表存在”，表空间存在，行号就有了==【造居民楼，为每间屋子编号，和人是否入住入关】</p>
<p>表删了之后，列就没有了</p>
<ul>
<li>创建表空间时，指定数据文件，Oracle给这个数据文件编号</li>
<li>把这个数据文件格式化为很多块，分配块号</li>
<li>将每个块格式化为很多行，每个行已经有rowid了</li>
<li>创建表的时候，指定表空间，将原来表空间的rowid分配给这个表</li>
</ul>
<h4 id="ps：数据类型">ps：数据类型</h4>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200317150747877.png" alt="image-20200317150747877" style="zoom:67%;">
<ol>
<li>
<p>char(20)：定长，真正字符不够10Byte时，剩下的用空格填满（字符串比较时，性能好）</p>
</li>
<li>
<p>varchar(20)：变长，最多20，已用10个，剩下的就空着（变长的，节省存储空间）–明确知道多长就用char，要是变化，就用varchar</p>
<p>【学号】之类的长度基本不变，就可以用定长；【居住地址】长度不定，最好变长</p>
</li>
<li>
<p>nchar()和nvarchar() 中的n表示国建。</p>
<p>建库的时候要选字符集，表示以后的符号就是来自于你选的字符集；和国家字符集</p>
<p>national，可以理解为第二字符集，补充字符集（一般来说第二字符集的范围比原来的大）</p>
<p>nchar、nvarchar会到第二字符集中找</p>
<p>如果第一字符集就选utf，则不需要第二字符集了</p>
<p>eg 中文常用【员工都是中国人】，就用GBK；用utf16作为补充字符集【可能有外国员工】</p>
</li>
<li>
<p>NUMBER：该数据类型能存储精度最多达38位的数字。每个数存储在一个变长字段中，其长度在0～22字节之间。Oracle的NUMBER类型精度很高， 远远高于许多编程语言中常规的FLOAT和DOUBLE类型。</p>
<p>NUMBER( p,s ) p表示精度（总长度） s表示小数位数（四舍五入），s不写表示没有小数</p>
<p>插入数据时。总长度不能超的前提下，小数位数超过则四舍五入</p>
<p>ps：int、float、real是number的子集</p>
</li>
<li>
<p>date：一个7字节的定宽日期/时间数据类型。</p>
<p>其中总包含7个属性：世纪、世纪中哪一年、月份、月中的哪一天、小时、分钟和秒。</p>
</li>
</ol>
<p>不常用的</p>
<ol>
<li>
<p>long - 变长字符数据（不是整数），一张表只能有一个字段是long类型，<strong>使用clob代替</strong>。</p>
</li>
<li>
<p>BLOB： (binary large object)</p>
<p>在Oracle9i及以前的版本中， 这种数据类型允许存储最多4GB的数据， 在Oracle 10g及以后的版本中允许存储最多（4GB）×（数据库块大小）字节的数据。</p>
<p>BLOB包含不需要进行字符集转换的“二进制“数据，如果要存储==电子表格、字处理文档、图像文件==等就很适合采用。</p>
</li>
<li>
<p>CLOB：（Character Large Object）</p>
<p>在Oracle9i及以前的版本中， 这种数据类型允许存储最多4GB的数据， 在Oracle 10g及以后的版本中允许存储最多（4GB）×（数据库块大小）字节的数据。</p>
<p>CLOB包含<strong>要进行字符集转换的信息</strong>。这种数据类型很适合存储==纯文本==信息。</p>
</li>
<li>
<p>BFILE：存放指向操作系统文件的==指针，指向外部的二进制文件==</p>
</li>
<li>
<p>rowid：字段保存的是一个==物理地址==</p>
</li>
<li>
<p>raw：计算机中原始的 == 二进制</p>
<p>固定长度的二进制数据，可存放多媒体图象声音等</p>
<p>信息给谁看。给CPU看的，则效率高</p>
</li>
<li>
<p>long raw： <strong>可变长度的二进制数据</strong></p>
</li>
</ol>
<p><strong>unicode和utf</strong></p>
<p>字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。</p>
<p>有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情</p>
<p><a href="https://blog.csdn.net/guxiaonuan/article/details/78678043" target="_blank" rel="noopener">https://blog.csdn.net/guxiaonuan/article/details/78678043</a></p>
<p>16^4 = 2^16 = 65536</p>
<p>2^32 = 4,294,967,296‬</p>
<ul>
<li>
<p>unicode - 字符集（65536个字符？？？，每个字符分配一个唯一编码）</p>
</li>
<li>
<p>utf -  Unicode Transformation Format 编码方式，unicode字符集中的字符如何存储</p>
<p>放入内存中的仅仅是字符的编号，而不是真正的字符实体</p>
<p>UTF-8、UTF-16、UTF-32 都是 Unicode 的一种实现。</p>
<p>utf也分为定长和变长编码</p>
</li>
</ul>
<p>乱码 == 编码解码标准不一致</p>
<p>UTF-8 是兼容 ASCII 的，16和32都不兼容</p>
<p>ASCII（7位，128个字符，但实际用一个byte）中A（65）编码01000001</p>
<h4 id="查询表">查询表</h4>
<p>全表扫描</p>
<p>索引查找</p>
<p>直接物理地址查找（通过rowid）</p>
<h4 id="修改表">修改表</h4>
<h5 id="修改表名">修改表名</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- db12c的demo1下</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo1.t1 <span class="keyword">rename</span> <span class="keyword">to</span> t11;</span><br><span class="line"><span class="comment">-- rename to 不能加所有者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 简单方法</span></span><br><span class="line"><span class="keyword">rename</span> t11 <span class="keyword">to</span> t1;</span><br></pre></td></tr></table></figure>
<h5 id="增加字段">增加字段</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- scott下</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">add</span> birthdate <span class="built_in">date</span>;</span><br><span class="line">desc scott.buyers</span><br><span class="line"></span><br><span class="line"><span class="comment">--alter table 表名 add(userName varchar(30) default'空' not null);</span></span><br></pre></td></tr></table></figure>
<h5 id="修改字段">修改字段</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- scott下</span></span><br><span class="line"><span class="comment">-- 1）修改字段名称</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">RENAME</span> <span class="keyword">column</span> birthdate <span class="keyword">to</span> birth_date;</span><br><span class="line">desc scott.buyers</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2）修改字段类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> birth_date <span class="built_in">char</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">-- birth_date这个字段是新加的，里面还没有数据</span></span><br><span class="line"><span class="comment">-- 字段如果原来有数据，不为null，则可能由于数据类型不兼容出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3）修改宽度（和2）一致），原来是10</span></span><br><span class="line"><span class="comment">-- 一旦改到char之后，空格会一直保留！！！且空格只增不减！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- A. varchar - varchar</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">varchar</span>(<span class="number">30</span>);<span class="comment">-- 改大，可</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">varchar</span>(<span class="number">28</span>); <span class="comment">-- 改小，看数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- B. varchar - char后，用空格填充</span></span><br><span class="line"><span class="comment">-- 不变，可</span></span><br><span class="line"><span class="comment">-- 变大，可</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">char</span>(<span class="number">25</span>); <span class="comment">-- 改小，看数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- C. char - char</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">char</span>(<span class="number">20</span>); <span class="comment">-- 改小，不可！！！</span></span><br><span class="line"><span class="comment">-- cannot decrease column length because some value is too big</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">char</span>(<span class="number">28</span>); <span class="comment">-- 改大，可，也会用空格填充</span></span><br><span class="line"><span class="comment">-- 注意此时所有数据已经变成28位（带空格）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- D. char - varchar，空格不会消失！！！</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">varchar</span>(<span class="number">28</span>); <span class="comment">-- 不变，可</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">varchar</span>(<span class="number">30</span>); <span class="comment">-- 变大，可</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">varchar</span>(<span class="number">27</span>); <span class="comment">-- 变小，不可！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> scott.buyers <span class="keyword">set</span> buyer_name = <span class="keyword">trim</span>(buyer_name); <span class="comment">-- 去除两端的空格</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">modify</span> BUYER_NAME <span class="built_in">varchar</span>(<span class="number">10</span>); <span class="comment">-- 又可了</span></span><br></pre></td></tr></table></figure>
<h5 id="删除字段（列）">删除字段（列）</h5>
<p>使用第一种，删除大表开销较大，不能在生产时间使用</p>
<p>生产时间应该用第二种，数据没有真正删除</p>
<p>为什么不直接drop，会放在回收站，可以flashback</p>
<p>最后加purge，彻底drop</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="comment">-- 1）直接删除，注意不要忘了column 或括号</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">drop</span> <span class="keyword">column</span> birth_date;</span><br><span class="line"><span class="comment">--alter table scott.buyers add birth_date date;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">drop</span> (birth_date);</span><br><span class="line"><span class="comment">--alter table scott.buyers add birth_date date;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- alter table 表名 drop (列名1, 列名2等);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2）先标记为未使用，然后再删除标记为未使用的列</span></span><br><span class="line"> <span class="comment">-- 标记为未使用，desc就查不到这一列了，但数据还在表里</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">set</span> <span class="keyword">unused</span> <span class="keyword">column</span> birth_date;</span><br><span class="line"><span class="comment">-- 查总表，看看哪些列打了标记</span></span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> dict <span class="keyword">where</span> table_name <span class="keyword">like</span> <span class="string">'%UNUSED%'</span>; <span class="comment">-- ALL_UNUSED_COL_TABS</span></span><br><span class="line">desc ALL_UNUSED_COL_TABS</span><br><span class="line">col owner for a10</span><br><span class="line">col TABLE_NAME for a20</span><br><span class="line">col COUNT for '99999'</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ALL_UNUSED_COL_TABS; <span class="comment">-- 对同一个列名，反复add，标记未使用，count会增加</span></span><br><span class="line"><span class="comment">-- 标记过的，不可以取消标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将所有未使用的列删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.buyers <span class="keyword">drop</span> <span class="keyword">unused</span> <span class="keyword">column</span>;</span><br></pre></td></tr></table></figure>
<h5 id="将表改为只读">将表改为只读</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- scott下</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.emp <span class="keyword">read</span> <span class="keyword">only</span>;    <span class="comment">--只读不可删/加数据</span></span><br><span class="line"></span><br><span class="line">col table_name for a20</span><br><span class="line">col read_only for a10</span><br><span class="line"><span class="keyword">select</span> table_name,read_only <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'EMP'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.emp <span class="keyword">read</span> write;</span><br></pre></td></tr></table></figure>
<h5 id="给表添加注释">给表添加注释</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- scott下</span></span><br><span class="line"><span class="keyword">select</span> comments <span class="keyword">from</span> user_tab_comments <span class="keyword">where</span> table_name=<span class="string">'BUYERS'</span>; <span class="comment">-- 注释为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">table</span> buyers <span class="keyword">is</span> <span class="string">'this is a demo table'</span>;</span><br><span class="line">desc user_tab_comments</span><br><span class="line"><span class="keyword">select</span> comments <span class="keyword">from</span> user_tab_comments <span class="keyword">where</span> table_name=<span class="string">'BUYERS'</span>;</span><br><span class="line">COMMENTS</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">this is a demo table</span><br></pre></td></tr></table></figure>
<h5 id="给表的列加注释">给表的列加注释</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> product.prod_id <span class="keyword">is</span> <span class="string">'this is product id'</span>;</span><br><span class="line">desc user_col_comments</span><br><span class="line">col COLUMN_NAME for a80</span><br><span class="line">col COMMENTS for a80</span><br><span class="line"><span class="keyword">select</span> COLUMN_NAME,COMMENTS <span class="keyword">from</span> user_col_comments <span class="keyword">where</span> TABLE_NAME=<span class="string">'PRODUCT'</span>;</span><br><span class="line"></span><br><span class="line">COLUMN_NAME</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">COMMENTS</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">PROD_ID</span><br><span class="line">this is product id</span><br><span class="line"></span><br><span class="line">PROD_NAME</span><br></pre></td></tr></table></figure>
<h4 id="截断表">截断表</h4>
<p>删除表中所有记录，和delete from不加where的区别</p>
<ul>
<li>delete属于DML语句，truncate属于DDL</li>
<li>delete from [表名]，速度慢，会将数据放到回滚段，可以rollback；truncate直接删除，无法rollback</li>
<li>delete不释放存储空间，truncate释放存储空间</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> c; <span class="comment">--将表清空</span></span><br></pre></td></tr></table></figure>
<h5 id="hwm">hwm</h5>
<p><strong>high water marker 高水位标记（高端水印）</strong></p>
<p>【水印之上，水没有到达】hwm之上没有数据，所以Oracle扫描数据只扫到hwm</p>
<p>Oracle计算空余时间，只计算高端水印之上的</p>
<p>插一条数据，hwm向上移动</p>
<ul>
<li>delete后，hwm不会下移</li>
<li>truncate，hwm下移到初始值？？？，相当于改了表的定义</li>
</ul>
<p>DDL，truncate会将hwm下移，相当于修改了表的定义？？？</p>
<p>演示见3.17录像</p>
<p>user_tables中为静态的统计数据，insert之后不会更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.t1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.t1 <span class="keyword">select</span> * <span class="keyword">from</span> scott.t1; <span class="comment">-- 复制一份记录</span></span><br><span class="line">/</span><br><span class="line">/</span><br><span class="line">/</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">917504 rows created.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换scott</span></span><br><span class="line"><span class="keyword">select</span> num_rows, blocks <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>;</span><br><span class="line">  NUM_ROWS     BLOCKS</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">   1835008      11120</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.t1 <span class="keyword">select</span> * <span class="keyword">from</span> scott.t1;</span><br><span class="line"><span class="keyword">select</span> num_rows, blocks <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>; <span class="comment">-- 没变</span></span><br><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> t1 <span class="keyword">compute</span> <span class="keyword">statistics</span>;</span><br><span class="line"><span class="keyword">select</span> num_rows, blocks <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>; <span class="comment">-- 变了</span></span><br><span class="line">  NUM_ROWS     BLOCKS</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">   3670016      22212</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1; <span class="comment">-- 3670016 rows deleted.</span></span><br><span class="line"><span class="keyword">select</span> num_rows, blocks <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>; <span class="comment">-- 行数没清零</span></span><br><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> t1 <span class="keyword">compute</span> <span class="keyword">statistics</span>;</span><br><span class="line"><span class="keyword">select</span> num_rows, blocks <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>;</span><br><span class="line"><span class="comment">-- 行数已清零，没有释放空间，高端水印没有下移</span></span><br><span class="line">  NUM_ROWS     BLOCKS</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         0      22212</span><br><span class="line"></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> t1;</span><br><span class="line"><span class="keyword">select</span> num_rows, blocks <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>; <span class="comment">-- 没变</span></span><br><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> t1 <span class="keyword">compute</span> <span class="keyword">statistics</span>;</span><br><span class="line"><span class="keyword">select</span> num_rows, blocks <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'T1'</span>;</span><br><span class="line"><span class="comment">-- 空间已释放</span></span><br><span class="line">  NUM_ROWS     BLOCKS</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         0          0</span><br></pre></td></tr></table></figure>
<h4 id="删除表">删除表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> scott.buyers; <span class="comment">-- 其实没有删除</span></span><br><span class="line"><span class="keyword">show</span> recyclebin <span class="comment">-- 只能在Scott下查！还在回收站</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.recyclebin; <span class="comment">-- 或者查scott下的回收站表</span></span><br><span class="line"></span><br><span class="line">ORIGINAL NAME    RECYCLEBIN NAME                OBJECT TYPE  <span class="keyword">DROP</span> <span class="built_in">TIME</span></span><br><span class="line"><span class="comment">---------------- ------------------------------ ------------ -------------------</span></span><br><span class="line">BUYERS           <span class="keyword">BIN</span>$o45ytf5UHK7gU8gLqMDbRQ==$<span class="number">0</span> <span class="keyword">TABLE</span>        <span class="number">2020</span><span class="number">-04</span><span class="number">-18</span>:<span class="number">17</span>:<span class="number">39</span>:<span class="number">53</span></span><br><span class="line">EMP              <span class="keyword">BIN</span>$olpkxjbOISngU8gLqMBTLQ==$<span class="number">0</span> <span class="keyword">TABLE</span>        <span class="number">2020</span><span class="number">-04</span><span class="number">-03</span>:<span class="number">10</span>:<span class="number">08</span>:<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据仍然可以查到，表只是换了个名字</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">"BIN$o45ytf5UHK7gU8gLqMDbRQ==$0"</span>;</span><br><span class="line">  BUYER_ID BUYER_NAME</span><br><span class="line"><span class="comment">---------- --------------------</span></span><br><span class="line">         1 Adam Barr</span><br><span class="line">         2 Sean Chai</span><br><span class="line">         3 Eva Coret</span><br><span class="line">         4 Erin Melia</span><br><span class="line"></span><br><span class="line">flashback table scott.buyers to before <span class="keyword">drop</span>; <span class="comment">--闪回</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.buyers; <span class="comment">-- 回来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--删的连回收站都没了，无法闪回</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> scott.buyers <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> recyclebin; <span class="comment">-- 没了</span></span><br></pre></td></tr></table></figure>
<h3 id="视图">视图</h3>
<p>访问视图时，先产生访问基表的sql语句，去查询相应的基表，再返回给视图</p>
<p>虚表：不是存储结构，是语句的定义</p>
<p>表：一种具体的存储结构</p>
<h4 id="视图的作用"><strong>视图的作用</strong></h4>
<ol>
<li>收集感兴趣的数据</li>
<li>屏蔽敏感数据【工资奖金】</li>
<li>简化查询</li>
<li>简化权限的管理</li>
</ol>
<h4 id="视图的分类"><strong>视图的分类</strong></h4>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200419101522747.png" alt="image-20200419101522747" style="zoom:67%;">
<ul>
<li>简单视图：基表不能超过一张，不能分组、函数</li>
<li>复杂视图</li>
</ul>
<h4 id="查询视图数据字典">查询视图数据字典</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> owner, view_name,read_only <span class="keyword">from</span> dba_views <span class="keyword">where</span> view_name <span class="keyword">like</span> <span class="string">'EMP%'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="创建视图">创建视图</h4>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200419102910947.png" alt="image-20200419102910947" style="zoom:67%;">
<p>基于存在的表创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">view</span> <span class="keyword">to</span> scott;</span><br><span class="line"><span class="comment">-- 以下关于视图的操作均在scott下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_info <span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br></pre></td></tr></table></figure>
<p>基于不存在的表创建视图可以吗？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不可以</span></span><br><span class="line"><span class="comment">-- 但是可以强制创建视图，使用force</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">force</span> <span class="keyword">view</span> emp_info <span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal,deptno <span class="keyword">from</span> scott.abc;</span><br><span class="line"><span class="comment">-- 覆盖原来的emp_info视图</span></span><br><span class="line">Warning: View created <span class="keyword">with</span> compilation errors.</span><br><span class="line"><span class="comment">-- 视图虽然创建，但是编译错误，也查询不到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-04063: view "SCOTT.EMP_INFO" has errors</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 什么时候这个不存在的表被创建了，这些视图就可以使用了</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.abc <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info; <span class="comment">-- 有了</span></span><br></pre></td></tr></table></figure>
<h4 id="修改视图结构">修改视图结构</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 为视图增加一个字段部门号</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> emp_info <span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal,deptno <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="comment">-- 保留权限</span></span><br></pre></td></tr></table></figure>
<p>修改视图通过删除重建可以吗？</p>
<p>这样做不好，删除之前有些用户已经拥有了这些<strong>视图的权限</strong>，删除之后权限就没了</p>
<p>drop create，之后就是一个新的对象了，object_id不同</p>
<h4 id="通过视图修改基表">通过视图修改基表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改视图，表中数据会变化！</span></span><br><span class="line"><span class="keyword">update</span> emp_info <span class="keyword">set</span> sal = <span class="number">1800</span> <span class="keyword">where</span> empno = <span class="number">7369</span>;  <span class="comment">--修改视图就是修改基表</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp_info <span class="keyword">where</span> empno=<span class="number">7369</span>;</span><br><span class="line">       SAL</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">      1800</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> scott.abc <span class="keyword">where</span> empno=<span class="number">7369</span>;</span><br><span class="line">       SAL</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">      1800</span><br></pre></td></tr></table></figure>
<p>限制修改某个字段（相当于加了约束？？？）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">force</span> <span class="keyword">view</span> emp_info</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal,deptno <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">where</span> deptno = <span class="number">30</span>;</span><br><span class="line"><span class="comment">-- 此时所有数据都可以修改</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                       SAL     DEPTNO</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">      7499 ALLEN                      1600         30</span><br><span class="line">      7521 WARD                       1250         30</span><br><span class="line">      7654 MARTIN                     1250         30</span><br><span class="line">      7698 BLAKE                      2850         30</span><br><span class="line">      7844 TURNER                     1500         30</span><br><span class="line">      7900 JAMES                       950         30</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> emp_info <span class="keyword">set</span> deptno=<span class="number">20</span> <span class="keyword">where</span> empno=<span class="number">7900</span>; <span class="comment">-- 从30部门调走了</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                       SAL     DEPTNO</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">      7499 ALLEN                      1600         30</span><br><span class="line">      7521 WARD                       1250         30</span><br><span class="line">      7654 MARTIN                     1250         30</span><br><span class="line">      7698 BLAKE                      2850         30</span><br><span class="line">      7844 TURNER                     1500         30</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不允许修改某个字段</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">force</span> <span class="keyword">view</span> emp_info</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal,deptno <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>;</span><br><span class="line"><span class="comment">-- 可以加约束名</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">force</span> <span class="keyword">view</span> emp_info</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal,deptno <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span> <span class="keyword">constraint</span> emp_info_ck;</span><br><span class="line"><span class="comment">-- 查找刚建的约束（第一种方法查不到视图上的约束）</span></span><br><span class="line"><span class="keyword">select</span> a.owner,a.table_name,b.column_name,a.constraint_name,a.constraint_type</span><br><span class="line"><span class="keyword">from</span> user_constraints a, user_cons_columns b</span><br><span class="line"><span class="keyword">where</span> a.constraint_name=b.constraint_name </span><br><span class="line"><span class="keyword">and</span> a.owner=<span class="string">'SCOTT'</span>;</span><br><span class="line"><span class="keyword">select</span> owner, constraint_name, constraint_type <span class="keyword">from</span> user_constraints <span class="keyword">where</span> owner=<span class="string">'SCOTT'</span>;</span><br><span class="line"><span class="comment">-- 视图删除，约束也就没了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个时候部门号就不可以修改了，只有部门号不能修改</span></span><br><span class="line"><span class="keyword">update</span> emp_info <span class="keyword">set</span> deptno=<span class="number">20</span> <span class="keyword">where</span> empno=<span class="number">7844</span>;</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01402: view <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> <span class="keyword">where</span>-clause violation</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 仍然可以涨工资</span></span><br><span class="line"><span class="keyword">update</span> emp_info <span class="keyword">set</span> sal=<span class="number">2000</span> <span class="keyword">where</span> empno=<span class="number">7844</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                       SAL     DEPTNO</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">      7499 ALLEN                      1600         30</span><br><span class="line">      7521 WARD                       1250         30</span><br><span class="line">      7654 MARTIN                     1250         30</span><br><span class="line">      7698 BLAKE                      2850         30</span><br><span class="line">      7844 TURNER                     2000         30</span><br></pre></td></tr></table></figure>
<p>只读视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只允许读，不可以修改</span></span><br><span class="line"><span class="comment">-- 对只读视图不允许DML</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">force</span> <span class="keyword">view</span> emp_info</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal,deptno <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">only</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> emp_info <span class="keyword">set</span> sal=<span class="number">2000</span> <span class="keyword">where</span> empno=<span class="number">7844</span>;</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-42399: cannot perform a DML operation on a read-only view</span><br></pre></td></tr></table></figure>
<p>创建视图时，select sal * 12 表达式需要取别名（列名不能是一个表达式）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> emp_info</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal*<span class="number">12</span>,deptno <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">only</span>;</span><br><span class="line"></span><br><span class="line">ORA-00998: must name this expression <span class="keyword">with</span> a <span class="keyword">column</span> <span class="keyword">alias</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> emp_info</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> empno,ename,sal*<span class="number">12</span> ann_sal,deptno <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">only</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                   ANN_SAL     DEPTNO</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">      7499 ALLEN                     19200         30</span><br><span class="line">      7521 WARD                      15000         30</span><br><span class="line">      7654 MARTIN                    15000         30</span><br><span class="line">      7698 BLAKE                     34200         30</span><br><span class="line">      7844 TURNER                    24000         30</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--复杂视图不总是可以被修改</span></span><br><span class="line"><span class="comment">--行号rownum</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,ename <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">rownum</span> &gt;= <span class="number">10</span>; <span class="comment">--rownum是查询之后再根据结果进行编号</span></span><br><span class="line"><span class="comment">--把查出来的结果，再进行筛选</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>，ename <span class="keyword">from</span>（<span class="keyword">select</span> <span class="keyword">rownum</span> aa,emp.* <span class="keyword">from</span> emp）<span class="keyword">where</span> aa&gt;=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="对视图DML的限制">对视图DML的限制</h4>
<p>删 - 改 - 增：条件越来越多</p>
<h5 id="1-不允许删">1. 不允许删</h5>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200419111526695.png" alt="image-20200419111526695" style="zoom: 67%;">
<h5 id="2-不能改">2. 不能改</h5>
<p>【年薪 = sal*12】</p>
<p>【金额 = 单价*数量】</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200419112145101.png" alt="image-20200419112145101" style="zoom:80%;">
<h5 id="3-不能增">3. 不能增</h5>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200419112119386.png" alt="image-20200419112119386" style="zoom:80%;">
<p>原表中有一个not null 没有被视图包括，则不能插</p>
<p>eg</p>
<p><img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200419112417920.png" alt="image-20200419112417920"></p>
<p>t1为原表，v1为对应的视图</p>
<p>向视图中插数据就是向表中插数据</p>
<p>此时向视图插只能AB，c必为null；但原表不允许c为null，所以不允许插入数据</p>
<h4 id="表的not-null属性">表的not null属性</h4>
<p>能不能继承（继承即为用一张表数据创建新表）</p>
<p>not null分显示/隐式</p>
<ul>
<li>
<p>emp和emp1，将empno设置为主键</p>
<p>主键显然不能为空，为隐式规定not null，但主键不继承</p>
</li>
<li>
<p>e1和e2，将empno显示规定not null，会继承</p>
</li>
</ul>
<p>scott下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc emp</span><br><span class="line"> Name                                                  Null?    Type</span><br><span class="line"> <span class="comment">----------------------------------------------------- -------- ---------------------------</span></span><br><span class="line"> EMPNO                                                 NOT NULL NUMBER(4)</span><br><span class="line"> ENAME                                                          VARCHAR2(10)</span><br><span class="line"> JOB                                                            VARCHAR2(9)</span><br><span class="line"> MGR                                                            NUMBER(4)</span><br><span class="line"> HIREDATE                                                       DATE</span><br><span class="line"> SAL                                                            NUMBER(7,2)</span><br><span class="line"> COMM                                                           NUMBER(7,2)</span><br><span class="line"> DEPTNO                                                         NUMBER(2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 能不能继承（ocm ocp考试）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="comment">-- not null 没了</span></span><br><span class="line">desc emp1</span><br><span class="line"> Name                                                  Null?    Type</span><br><span class="line"> <span class="comment">----------------------------------------------------- -------- ---------------------------</span></span><br><span class="line"> EMPNO                                                          NUMBER(4)</span><br><span class="line"> ENAME                                                          VARCHAR2(10)</span><br><span class="line"> JOB                                                            VARCHAR2(9)</span><br><span class="line"> MGR                                                            NUMBER(4)</span><br><span class="line"> HIREDATE                                                       DATE</span><br><span class="line"> SAL                                                            NUMBER(7,2)</span><br><span class="line"> COMM                                                           NUMBER(7,2)</span><br><span class="line"> DEPTNO                                                         NUMBER(2)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> e1(<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>);</span><br><span class="line">desc e1</span><br><span class="line"> Name                                                  Null?    Type</span><br><span class="line"> <span class="comment">----------------------------------------------------- -------- ---------------------------</span></span><br><span class="line"> ID                                                             NUMBER(38)</span><br><span class="line"> NAME                                                  NOT NULL VARCHAR2(20)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> e2 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> e1;</span><br><span class="line"><span class="comment">-- not null还有</span></span><br><span class="line">desc e2</span><br><span class="line"> Name                                                  Null?    Type</span><br><span class="line"> <span class="comment">----------------------------------------------------- -------- ---------------------------</span></span><br><span class="line"> ID                                                             NUMBER(38)</span><br><span class="line"> NAME                                                  NOT NULL VARCHAR2(20)</span><br></pre></td></tr></table></figure>
<h4 id="内嵌视图">内嵌视图</h4>
<p>12c之前没有fetch子句，用内嵌视图实现</p>
<p>先按工资从大到小排好，再取rownum小于等于多少的人（前几名）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,empno,ename <span class="keyword">from</span> scott.emp;</span><br><span class="line">    ROWNUM      EMPNO ENAME</span><br><span class="line"><span class="comment">---------- ---------- --------------------</span></span><br><span class="line">         1       7369 SMITH</span><br><span class="line">         2       7499 ALLEN</span><br><span class="line">         3       7521 WARD</span><br><span class="line">         4       7566 JONES</span><br><span class="line">         5       7654 MARTIN</span><br><span class="line">         6       7698 BLAKE</span><br><span class="line">         7       7782 CLARK</span><br><span class="line">         8       7788 SCOTT</span><br><span class="line">         9       7839 KING</span><br><span class="line">        10       7844 TURNER</span><br><span class="line">        11       7876 ADAMS</span><br><span class="line">        12       7900 JAMES</span><br><span class="line">        13       7902 FORD</span><br><span class="line">        14       7934 MILLER</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 工资最多的前5个人</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,empno,ename,sal <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">rownum</span>,empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>)</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rownum</span>&lt;=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>rownum是结果集的编号</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 取前三个人</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,empno,ename <span class="keyword">from</span> scott.emp <span class="keyword">where</span> <span class="keyword">rownum</span>&lt;=<span class="number">3</span>;</span><br><span class="line">    ROWNUM      EMPNO ENAME</span><br><span class="line"><span class="comment">---------- ---------- --------------------</span></span><br><span class="line">         1       7369 SMITH</span><br><span class="line">         2       7499 ALLEN</span><br><span class="line">         3       7521 WARD</span><br><span class="line"><span class="comment">-- 取12以后的人</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,empno,ename <span class="keyword">from</span> scott.emp <span class="keyword">where</span> <span class="keyword">rownum</span>&gt;=<span class="number">12</span>;</span><br><span class="line">no rows selected</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不是rownum不支持大于号</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,empno,ename <span class="keyword">from</span> scott.emp <span class="keyword">where</span> <span class="keyword">rownum</span>&gt;<span class="number">0</span>; <span class="comment">-- 这个还是有的</span></span><br></pre></td></tr></table></figure>
<p>起始时，结果集为空，对下一条可能符合条件的记录，rownum暂时赋值为1</p>
<p>第一条语句，rownum是1，小于12，过滤掉了</p>
<p>第二条语句，结果集为空，rownun还是1，小于12，又被过滤了</p>
<p>。。。</p>
<p>被过滤掉的行，rownum不会增加，rownum永远都是1，所以没有记录</p>
<p>处理一下，勉强可以实现。。。但没有fetch + offset香啊</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">rownum</span>,empno,ename <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">rownum</span> aa, emp.* <span class="keyword">from</span> emp)</span><br><span class="line"><span class="keyword">where</span> aa&gt;=<span class="number">12</span>;</span><br><span class="line"><span class="comment">-- emp.*代表emp的所有字段</span></span><br><span class="line">    ROWNUM      EMPNO ENAME</span><br><span class="line"><span class="comment">---------- ---------- --------------------</span></span><br><span class="line">         1       7900 JAMES</span><br><span class="line">         2       7902 FORD</span><br><span class="line">         3       7934 MILLER</span><br></pre></td></tr></table></figure>
<h3 id="同义词">同义词</h3>
<h4 id="同义词-2">同义词</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- hr下</span></span><br><span class="line">desc emp</span><br><span class="line">ERROR:</span><br><span class="line">ORA-04043: object emp does not exist</span><br><span class="line">   </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">synonym</span> emp <span class="keyword">for</span> scott.emp;</span><br><span class="line">desc emp</span><br><span class="line">ERROR:</span><br><span class="line">ORA-04043: object "SCOTT"."EMP" does not exist</span><br><span class="line">   </span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> hr; <span class="comment">-- 无权限还是不能访问</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">-- hr下</span></span><br><span class="line">desc emp <span class="comment">-- 可以看到表结构了</span></span><br></pre></td></tr></table></figure>
<h2 id="5’-数据完整性-约束">5’ 数据完整性 - 约束</h2>
<p>数据 + 规则 ----&gt; 保证数据的有效性、合理性</p>
<p>无效数据【salary为-1000，成绩为855分，学生在烹饪系】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> hr.employees</span><br><span class="line"><span class="keyword">set</span> department_id=<span class="number">55</span></span><br><span class="line"><span class="keyword">where</span> department_id=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-02291: integrity constraint (HR.EMP_DEPT_FK) violated - parent key not found</span><br></pre></td></tr></table></figure>
<p>数据完整性实现方法，开销从高到低，尽量使用约束实现</p>
<ol>
<li>代码</li>
<li>触发器</li>
<li>约束</li>
</ol>
<p>约束要起名字，不起系统会自动起【sys_cn】</p>
<p>除非创建了之后就不会再去管理的那些约束</p>
<p>可以创建表的时候定义约束，也可以在之后使用alter添加</p>
<p>表级别的约束 =&gt; 列定义好了在定义约束列级别的约束 =&gt; 列写好了就紧接着定义约束</p>
<h3 id="约束类型">约束类型</h3>
<ol>
<li>
<p>not null</p>
</li>
<li>
<p>unique</p>
</li>
<li>
<p>primary key == pk（1+2）</p>
</li>
<li>
<p>foreign key == fk【员工在的部门必须是存在的部门】</p>
</li>
<li>
<p>check</p>
</li>
</ol>
<h3 id="查询有关约束的信息">查询有关约束的信息</h3>
<p>两个数据字典：</p>
<p>user_constraints    --定义<strong>表级别</strong>的约束：关键字，约束名称，约束类型，字段</p>
<p>user_cons_columns   --定义<strong>字段级别</strong>的约束：关键字，约束名称，约束类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> owner, constraint_name, constraint_type <span class="keyword">from</span> user_constraints;</span><br><span class="line"><span class="keyword">select</span> owner, constraint_name, TABLE_NAME, COLUMN_NAME, <span class="keyword">POSITION</span> <span class="keyword">from</span> user_cons_columns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.owner,a.table_name,b.column_name,a.constraint_name,a.constraint_type</span><br><span class="line"><span class="keyword">from</span> user_constraints a, user_cons_columns b</span><br><span class="line"><span class="keyword">where</span> a.constraint_name=b.constraint_name </span><br><span class="line"><span class="keyword">and</span> a.owner=<span class="string">'HR'</span> <span class="keyword">and</span> a.table_name=<span class="string">'TEST'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建约束">创建约束</h3>
<h4 id="定义约束书写格式">定义约束书写格式</h4>
<p>列级别的约束：constraint，约束名称，约束类型</p>
<p>表级别的约束：constraint，约束名称，约束类型，<strong>字段名</strong></p>
<p>系统定义写约束类型就好了</p>
<p>建表后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> <span class="keyword">constraint</span> [约束信息];</span><br></pre></td></tr></table></figure>
<p>建表时</p>
<h4 id="定义非空">定义非空</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(</span><br><span class="line">        a <span class="built_in">VARCHAR2</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">        b <span class="built_in">VARCHAR2</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="定义主键">定义主键</h4>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200317162230483.png" alt="image-20200317162230483" style="zoom:67%;">
<h4 id="定义唯一性约束">定义唯一性约束</h4>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200418185519693.png" alt="image-20200418185519693" style="zoom:80%;">
<h4 id="定义外键">定义外键</h4>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200418185610756.png" alt="image-20200418185610756" style="zoom:80%;">
<p>删除部门的时候，查看是否有员工在这个部门，有的话删不了，除非：</p>
<ul>
<li>取消约束</li>
<li>on delete cascade：连着这个部门的员工一起删除</li>
<li>on delete set null：将在这个部门的员工部门号清空（null）</li>
</ul>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200317162547204.png" alt="image-20200317162547204" style="zoom:67%;">
<h4 id="check约束">check约束</h4>
<p>约束不满足，不允许插入</p>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200418185946648.png" alt="image-20200418185946648" style="zoom: 80%;">
<h4 id="混合例子">混合例子</h4>
<img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200418190532268.png" alt="image-20200418190532268" style="zoom:80%;">
<h3 id="禁用-启用约束">禁用 / 启用约束</h3>
<p>使用禁用的条件</p>
<ul>
<li>
<p>有数据违反约束会报错，如果不禁用，则一个不满足，作为一个事务整体全部都失败</p>
<p>先把这些数据导进来，再用异常表，把违反约束的修改或者删除</p>
</li>
<li>
<p>大批数据导入表中，每条数据检查约束，降低效率</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> cons_test <span class="keyword">disable</span> <span class="keyword">constraint</span> MIN_SAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> cons_test <span class="keyword">enable</span> <span class="keyword">constraint</span> MIN_SAL;</span><br></pre></td></tr></table></figure>
<h4 id="异常表实验">异常表实验</h4>
<p><img src="/2020/03/10/Oracle/OracleSQL_part2/image-20200418193318378.png" alt="image-20200418193318378"></p>
<p>模拟有一批数据插进来，但其中有一个坏数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> hr.test(<span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">5</span>),<span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hr.test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'aaa'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hr.test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'bbb'</span>);</span><br><span class="line"><span class="comment">-- 添加约束（删表不会删除约束？？？）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> hr.test <span class="keyword">add</span> <span class="keyword">constraint</span> uni_name <span class="keyword">unique</span>(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hr.test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'aaa'</span>); <span class="comment">-- 名字一样，插不进来</span></span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-00001: unique constraint (HR.UNI_NAME) violated</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> hr.test <span class="keyword">disable</span> <span class="keyword">constraint</span> uni_name; <span class="comment">-- 禁用约束</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hr.test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'aaa'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>使用exceptions表（记录异常情况）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc exceptions</span><br><span class="line"><span class="comment">-- 如果这个表不存在，使用脚本产生这个表</span></span><br><span class="line">@?/rdbms/admin/utlexcpt</span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">desc exceptions</span><br><span class="line"> Name                                                  Null?    Type</span><br><span class="line"> <span class="comment">----------------------------------------------------- -------- --------------------------</span></span><br><span class="line"> ROW_ID                                                         ROWID</span><br><span class="line"> OWNER                                                          VARCHAR2(128)</span><br><span class="line"> TABLE_NAME                                                     VARCHAR2(128)</span><br><span class="line"> CONSTRAINT                                                     VARCHAR2(128)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> hr.test <span class="keyword">enable</span> <span class="keyword">constraint</span> uni_name <span class="keyword">exceptions</span> <span class="keyword">into</span> <span class="keyword">exceptions</span>; <span class="comment">-- 起不来</span></span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-02299: cannot validate (HR.UNI_NAME) - duplicate keys found</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rowid</span>,<span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> hr.test <span class="keyword">where</span> <span class="keyword">rowid</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> row_id <span class="keyword">from</span> hr.exceptions);</span><br><span class="line">ROWID                      ID NAME</span><br><span class="line"><span class="comment">------------------ ---------- --------------------</span></span><br><span class="line">AAASg8AADAAAPoGAAA          1 aaa</span><br><span class="line">AAASg8AADAAAPoGAAC          2 aaa</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将重复的改名</span></span><br><span class="line"><span class="keyword">update</span> hr.test <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'ccc'</span> <span class="keyword">where</span> <span class="keyword">rowid</span>=<span class="string">'AAASg8AADAAAPoGAAC'</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> hr.test <span class="keyword">enable</span> <span class="keyword">constraint</span> uni_name <span class="keyword">exceptions</span> <span class="keyword">into</span> <span class="keyword">exceptions</span>; <span class="comment">-- 起来了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hr.test;</span><br><span class="line">        ID NAME</span><br><span class="line"><span class="comment">---------- --------------------</span></span><br><span class="line">         1 aaa</span><br><span class="line">         3 bbb</span><br><span class="line">         2 ccc</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空这个表，以后用的时候不会有之前的数据</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> <span class="keyword">exceptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查某个人的某张表，所有字段下的约束名称和类型</span></span><br><span class="line"><span class="keyword">select</span> a.owner,a.table_name,b.column_name,a.constraint_name,a.constraint_type</span><br><span class="line"><span class="keyword">from</span> user_constraints a, user_cons_columns b</span><br><span class="line"><span class="keyword">where</span> a.constraint_name=b.constraint_name </span><br><span class="line"><span class="keyword">and</span> a.owner=<span class="string">'HR'</span> <span class="keyword">and</span> a.table_name=<span class="string">'TEST'</span>;</span><br><span class="line">OWNER</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">CONSTRAINT_NAME</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------</span></span><br><span class="line">CO TABLE_NAME</span><br><span class="line"><span class="comment">-- ----------</span></span><br><span class="line">COLUMN_NAME</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------</span></span><br><span class="line">HR</span><br><span class="line">UNI_NAME</span><br><span class="line">U  TEST</span><br><span class="line">NAME</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1.创建hr.test表：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">5</span>),<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">2.插入数据：</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'aaa'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'bbb'</span>);</span><br><span class="line">   </span><br><span class="line">3.添加约束：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">add</span> <span class="keyword">constraint</span> uni_name <span class="keyword">unique</span>(<span class="keyword">name</span>);<span class="comment">--name字段添加唯一性约束</span></span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'aaa'</span>);  <span class="comment">--报错，违反唯一性约束</span></span><br><span class="line"></span><br><span class="line">4.禁用约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">disable</span> <span class="keyword">constraint</span> uni_name;<span class="comment">--禁用约束</span></span><br><span class="line"></span><br><span class="line">5.使用exceptions表（找表中违反约束的lowid放入exception表中）</span><br><span class="line">desc exceptions <span class="comment">-- 不存在</span></span><br><span class="line"></span><br><span class="line">6.app/oracle/product/18.3.0/rdbms/admin中的脚本utlexcept.sql</span><br><span class="line">@?/rdbms/admin/utlexcpt.sql <span class="comment">--调用脚本创建excptions表</span></span><br><span class="line"><span class="comment">--斜线方向不能反</span></span><br><span class="line"><span class="comment">--?为oracle home，即F:\app\oracle\product\18.3.0</span></span><br><span class="line"></span><br><span class="line">7.启用约束，找表中违反约束的lowid放入exception表中：</span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">enable</span> <span class="keyword">constraint</span> uni_name <span class="keyword">exceptions</span> <span class="keyword">into</span> <span class="keyword">exceptions</span>;</span><br><span class="line">  <span class="comment">-- ORA-02299: 无法验证(HR.UNI_NAME) - 找到重复关键字</span></span><br><span class="line">   <span class="keyword">select</span> row_id,table_name <span class="keyword">from</span> <span class="keyword">exceptions</span>;</span><br><span class="line">   <span class="keyword">select</span> <span class="keyword">rowid</span>,<span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">rowid</span> <span class="keyword">in</span>(<span class="keyword">select</span> row_id <span class="keyword">from</span> <span class="keyword">exceptions</span>);</span><br><span class="line"></span><br><span class="line">8.update hr.test <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'ccc'</span> <span class="keyword">where</span> <span class="keyword">rowid</span>=<span class="string">'AAASBdAADAAAPoFAAC'</span>; <span class="comment">-- rowid不同</span></span><br><span class="line"></span><br><span class="line">9.再次启用约束<span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">enable</span> <span class="keyword">constraint</span> uni_name;</span><br><span class="line"></span><br><span class="line">10.truncate <span class="keyword">table</span> <span class="keyword">exceptions</span>; <span class="comment">-- 截断表，清空异常表供以后使用</span></span><br><span class="line"></span><br><span class="line">11.在数据字典汇总查询约束信息(user_constraints,user_cons_columns)</span><br><span class="line"><span class="keyword">select</span> CONSTRAINT_NAME <span class="keyword">from</span> user_constraints;</span><br><span class="line"><span class="keyword">select</span> CONSTRAINT_NAME,TABLE_NAME, COLUMN_NAME <span class="keyword">from</span> user_cons_columns <span class="keyword">where</span> table_name=<span class="string">'TEST'</span>; <span class="comment">-- 区分大小写</span></span><br></pre></td></tr></table></figure>
<h3 id="删除约束">删除约束</h3>
<p>约束是依赖于表的，不能直接drop constraint</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> cons_test <span class="keyword">drop</span> <span class="keyword">constraint</span> SAL_MIN;  <span class="comment">--删除约束</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle SQL</title>
    <url>/2020/03/10/Oracle/OracleSQL/</url>
    <content><![CDATA[<h2 id="0-SQL">0 SQL</h2>
<h3 id="sql简介">sql简介</h3>
<ul>
<li>结构化查询语言</li>
<li>任何关系型数据库都支持</li>
<li>第四代 4GL</li>
<li>描述性语言，只说做什么，不说怎么做</li>
</ul>
<a id="more"></a>
<h3 id="sql分类">sql分类</h3>
<ol>
<li>
<p>QL：</p>
</li>
<li>
<p>DML针对用户数据：insert update delete merge</p>
</li>
<li>
<p>DDL针对系统数据：create alter drop truncate rename comment</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc user_tables; <span class="comment">-- 这个表不能insert改，数据字典属于系统数据，但可以通过DDL修改系统数据</span></span><br><span class="line"><span class="comment">-- insert into user_tables(table_name) values('aaa'); 不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- db12c scott下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> aaa(<span class="keyword">id</span> <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>DCL权限控制：grant revoke</p>
<p>表不存在，可能是无权限访问，在sys下修改权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> hr.departments <span class="keyword">to</span> scott;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> hr.departments <span class="keyword">from</span> scott;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TCL事务控制：commit rollback savepoint</p>
</li>
</ol>
<h3 id="语句解析过程">语句解析过程</h3>
<ul>
<li>
<p>语法分析</p>
</li>
<li>
<p>语义分析</p>
</li>
<li>
<p>权限管理 select * from scott.emp, 没有权限视为这个表不存在</p>
</li>
<li>
<p>生成执行计划 set autot on（可以显示执行过程）</p>
<p>可能形成多个执行计划，评估代价之后，选择最优的计划，生成CPU可以执行的代码</p>
</li>
</ul>
<p>每次解析SQL效率太低，在内存（共享池）中保存已经解析好的代码，避免重复解析</p>
<h3 id="sql语法注意">sql语法注意</h3>
<ul>
<li>关键字不能缩写（和sqlplus命令区分）和跨行</li>
<li>以分号结尾</li>
</ul>
<h3 id="“大小写不敏感”">“大小写不敏感”</h3>
<p>==针对结果，过程不同==</p>
<p>eg</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200413001053865.png" alt="image-20200413001053865" style="zoom: 80%;">
<p>select 中，i不同，数据库就认为是1000条不同的语句，解析1000次</p>
<p>需要绑定变量，使执行速度加快</p>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200306095000479.png" alt="image-20200306095000479"></p>
<p>数据库怎么知道一条语句有没有执行过？</p>
<p>不是一个字母一个字母比较，而是比较语句的hash值</p>
<p>字符串不是完全相同时，语句的hash值不同，重新解析？？？：</p>
<ul>
<li>大小写不一样时</li>
<li>多空格少空格</li>
<li>换行不同时（不一定能在查询结果中看出来）（分号另起一行）</li>
<li><strong>要遵循写sql语句的规范</strong>（关键字大写，从句另起一行？？？）</li>
</ul>
<p>sql语句的hash值就不同，但执行计划的hash值相同</p>
<p>如何查看已经缓存的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc v$sql <span class="comment">-- sql_text, hash_value</span></span><br><span class="line"><span class="comment">-- shutdown，startup之后清空</span></span><br><span class="line"> SQL_TEXT                                                       VARCHAR2(1000)</span><br><span class="line"> SQL_FULLTEXT                                                   CLOB</span><br><span class="line"> SQL_ID                                                         VARCHAR2(13)</span><br><span class="line"> HASH_VALUE                                                     NUMBER</span><br><span class="line"> OLD_HASH_VALUE                                                 NUMBER</span><br><span class="line"> PLAN_HASH_VALUE                                                NUMBER</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sql_text, hash_value, plan_hash_value <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> sql_text <span class="keyword">like</span> <span class="string">'%scott.emp%'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200407113342237.png" alt="image-20200407113342237"></p>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200407113448904.png" alt="image-20200407113448904"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter <span class="keyword">cursor</span></span><br><span class="line"><span class="keyword">NAME</span>                                 <span class="keyword">TYPE</span>                   <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line">cursor_bind_capture_destination      <span class="keyword">string</span>                 <span class="keyword">memory</span>+disk</span><br><span class="line">cursor_invalidation                  <span class="keyword">string</span>                 <span class="keyword">IMMEDIATE</span></span><br><span class="line">cursor_sharing                       <span class="keyword">string</span>                 EXACT</span><br><span class="line">cursor_space_for_time                <span class="built_in">boolean</span>                <span class="literal">FALSE</span></span><br><span class="line">open_cursors                         <span class="built_in">integer</span>                <span class="number">300</span></span><br><span class="line">session_cached_cursors               <span class="built_in">integer</span>                <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>cursor_sharing取值，用于判断两条sql语句是不是视为同一条语句，不同则需要重新解析</p>
<ul>
<li>
<p>similar – 检查plan_hash_value，一样则视为同一条语句</p>
<p>两条语句可以表面不一样，只要不造成执行计划的不同</p>
</li>
<li>
<p>exact – 检查hash_value，一样则视为同一条语句</p>
<p>两条语句必须完全一致</p>
</li>
</ul>
<p>根据业务选择模板（数据库类型），不能选错，参数都是根据类型变化的：</p>
<p>处理系统（存放当前经常变化的数据，经常重复做一样的事情？？？）</p>
<p>数据仓库（存放历史数据，一般只查询，用作决策支持）</p>
<ul>
<li>环境中语句如果不重复用，用exact加速语句老化？？？，适用于数据仓库</li>
<li>重用语句的话，similar比较合适，适用于处理系统</li>
</ul>
<h2 id="1-QL">1 QL</h2>
<ol>
<li>选择：横向的子集</li>
<li>投影：纵向的子集</li>
<li>连接：一张表的来源可能是两张表</li>
</ol>
<p><strong>dual表</strong></p>
<p>系统保证任何时候都是单行单列（里面的值没有限制）</p>
<p>查询一些和表没有关系的信息（时间）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dual;</span><br><span class="line">DU</span><br><span class="line"><span class="comment">--</span></span><br><span class="line">X</span><br><span class="line"></span><br><span class="line">SYS@db12c&gt;desc dual</span><br><span class="line"> Name         Null?    Type</span><br><span class="line"> <span class="comment">------------ -------- ------------------------------------</span></span><br><span class="line"> DUMMY                 VARCHAR2(1)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> <span class="number">3</span>+<span class="number">4</span> <span class="keyword">from</span> dual;</span><br><span class="line">       3+4</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">         7</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="number">3</span>+<span class="number">4</span> <span class="keyword">as</span> he <span class="keyword">from</span> dual;</span><br><span class="line">        HE</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">         7</span><br><span class="line">         </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> <span class="keyword">from</span> dual;</span><br><span class="line">SYSDATE</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">12-APR-20</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dual <span class="keyword">values</span>(<span class="string">'Y'</span>); <span class="comment">-- 插不进去记录</span></span><br><span class="line"><span class="keyword">update</span> dual <span class="keyword">set</span> dummy=<span class="string">'Z'</span>; <span class="comment">-- 但是可以改</span></span><br></pre></td></tr></table></figure>
<p>表设计原则</p>
<ul>
<li>不允许一张表孤零零（外键）</li>
<li>从一张表要能访问到其他表</li>
</ul>
<p>查询结果显示格式，可以改的</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200413004334644.png" alt="image-20200413004334644" style="zoom:67%;">
<h3 id="null的三值现象">null的三值现象</h3>
<p>null 相当于未定义的变量，不能说等于或者不等于</p>
<ul>
<li>null == 1 为false</li>
<li>null !=1 为false</li>
<li>判断是不是null ，使用is null</li>
</ul>
<p>eg1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,mgr <span class="keyword">from</span> scott.emp <span class="keyword">where</span> mgr&lt;&gt;<span class="number">7698</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> empno,ename,mgr <span class="keyword">from</span> scott.emp <span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> empno,ename,mgr <span class="keyword">from</span> scott.emp <span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>eg2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal,comm,comm+<span class="number">500</span> <span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200413005310401.png" alt="image-20200413005310401" style="zoom:67%;">
<ul>
<li>null：不配拿奖金</li>
<li>0：有资格拿奖金，但奖金数位0</li>
</ul>
<p>涨奖金时，只有配拿奖金的人才会涨，null的不会加</p>
<p>order by comm时，null不参加排序，null相当于无穷大</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal,comm <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> comm;</span><br><span class="line"><span class="keyword">select</span> empno,ename,sal,comm <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> comm <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Oracle中引号、字符串连接">Oracle中引号、字符串连接</h3>
<ul>
<li>字符和字符串都使用单引号</li>
<li>双引号用于名字：表的名称、别名、列的名称使用双引号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'a'</span> <span class="keyword">from</span> dual; <span class="comment">-- 列名默认大写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'a'</span> a <span class="keyword">from</span> dual; <span class="comment">-- 默认别名大写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'a'</span> <span class="string">"a"</span> <span class="keyword">from</span> dual; <span class="comment">-- 双引号内的原样输出，别名变为小写</span></span><br></pre></td></tr></table></figure>
<p>Oracle中 + 就是算术运算，不能用于字符串连接</p>
<p>字符串连接使用双竖线表示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">3</span>+<span class="string">'4'</span> <span class="keyword">from</span> dual; <span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'3'</span>+<span class="string">'4'</span> <span class="keyword">from</span> dual; <span class="comment">-- 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'3'</span> || <span class="string">'4'</span> <span class="keyword">from</span> dual; <span class="comment">-- 34</span></span><br></pre></td></tr></table></figure>
<p>嵌套引号方法（考试里有这些东西）</p>
<ul>
<li>连续两个单引号表示转义</li>
<li>定界符q，不一定是方括号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'I''m a student'</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> q<span class="string">'[I'</span>m a student]<span class="string">' from dual;</span></span><br></pre></td></tr></table></figure>
<h3 id="去重-distinct-unique">去重 distinct == unique</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">unique</span> department_id <span class="keyword">from</span> hr.employees <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>考试选择题</p>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200306103700984.png" alt="image-20200306103700984"></p>
<p>key：bc</p>
<h3 id="order-by">order by</h3>
<h4 id="根据数字排序">根据数字排序</h4>
<p>order by 1 按照<strong>select字段中的</strong>第一列排序（不是原表？？？）</p>
<p>order by 2 按照第二列排序</p>
<h4 id="根据别名排序">根据别名排序</h4>
<p>（别名的原名是一个表达式时，很好用）</p>
<h4 id="复合排序">复合排序</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order by aa, bb desc</span><br></pre></td></tr></table></figure>
<p>复合的两个，可以一升一降</p>
<h3 id="having和where的区别">having和where的区别</h3>
<p>where对记录筛选</p>
<p>having对组筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 筛选工资大于2000的个人</span></span><br><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">where</span> sal&gt;<span class="number">2000</span>;</span><br><span class="line"><span class="comment">-- 筛选平均工资大于2000的部门</span></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">avg</span>(sal) <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(sal)&gt;<span class="number">2000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="比较符">比较符</h3>
<ul>
<li>between and 含两端的值</li>
<li>不等于是 &lt;&gt;</li>
<li>in (set)</li>
<li>like</li>
<li>is null</li>
</ul>
<p>后三个都可以加not</p>
<h4 id="like">like</h4>
<p>%匹配任意多个</p>
<p>_匹配一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where xx like &#39;%sga%&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="转义-escape">转义 - escape</h4>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200306104453200.png" alt="image-20200306104453200"></p>
<p>匹配AB__开头的记录</p>
<p>每个\只转移后面的一个字符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> demo1 <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'AB\_\_%'</span> escape <span class="string">'\'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现top-n功能">==实现top n功能==</h3>
<p>考试必考</p>
<p>eg 选择scott.emp表中，sal前两名的记录</p>
<p>错误做法：这样是先选出3条记录，再进行的排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">where</span> <span class="keyword">rownum</span>&lt;=<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<h4 id="第一种方法">第一种方法</h4>
<p>12c之前，内嵌视图（子查询）</p>
<p>这个表是乱的，先排好序，再取前三行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) <span class="keyword">where</span> <span class="keyword">rownum</span>&lt;=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="第二种方法（行限制子句，必考）">第二种方法（行限制子句，必考）</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> <span class="keyword">fetch</span> <span class="keyword">first</span> <span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200413094939969.png" alt="image-20200413094939969"></p>
<p>如果要把<strong>并列</strong>的全部选出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> <span class="keyword">fetch</span> <span class="keyword">first</span> <span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">with</span> <span class="keyword">ties</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200413095048179.png" alt="image-20200413095048179"></p>
<p>想要第4、5工资大的记录，offset 3 rows，先将前三个去掉，<strong>偏移</strong>过之后再取前两行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> </span><br><span class="line"><span class="keyword">offset</span> <span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">fetch</span> <span class="keyword">first</span> <span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200413095110819.png" alt="image-20200413095110819" style="zoom:67%;">
<h3 id="查询时和用户交互">查询时和用户交互</h3>
<ol>
<li>&amp; 接受用户的输入</li>
<li>define</li>
<li>&amp;&amp; 接受用户输入，并define，以后就不用输了，需要时可以undefine</li>
</ol>
<h4 id="1">1. &amp;</h4>
<p>使用提交变量实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> empno=&amp;工号;</span><br><span class="line">Enter value for 工号: 7369</span><br><span class="line">old   1: <span class="keyword">select</span> ename,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> empno=&amp;工号</span><br><span class="line"><span class="keyword">new</span>   <span class="number">1</span>: <span class="keyword">select</span> ename,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> empno=<span class="number">7369</span></span><br><span class="line"></span><br><span class="line">ENAME                JOB</span><br><span class="line"><span class="comment">-------------------- ----------</span></span><br><span class="line">SMITH                CLERK</span><br></pre></td></tr></table></figure>
<p>练习</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不恰当的例子</span></span><br><span class="line"><span class="keyword">select</span> empno,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> ename=&amp;姓名; <span class="comment">-- 用户需要输入'SMITH'才能查找成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> empno,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> ename=<span class="keyword">UPPER</span>(<span class="string">'&amp;姓名'</span>);</span><br><span class="line">Enter value for 姓名: james</span><br><span class="line">old   1: <span class="keyword">select</span> empno,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> ename=<span class="keyword">UPPER</span>(<span class="string">'&amp;姓名'</span>)</span><br><span class="line"><span class="keyword">new</span>   <span class="number">1</span>: <span class="keyword">select</span> empno,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> ename=<span class="keyword">UPPER</span>(<span class="string">'james'</span>)</span><br><span class="line"></span><br><span class="line">     EMPNO JOB</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">      <span class="number">7900</span> CLERK</span><br></pre></td></tr></table></figure>
<h4 id="2-变量">2. 变量</h4>
<p>意义：程序中可能会使用多次，事先定义好，并且修改方便</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS@db12c&gt;define gh</span><br><span class="line">SP2-0135: symbol gh is UNDEFINED</span><br><span class="line">SYS@db12c&gt;define gh=7369</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时用户就不需要输入了</span></span><br><span class="line">SYS@db12c&gt;select ename,job from scott.emp where empno=&amp;gh;</span><br><span class="line">old   1: <span class="keyword">select</span> ename,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> empno=&amp;gh</span><br><span class="line"><span class="keyword">new</span>   <span class="number">1</span>: <span class="keyword">select</span> ename,job <span class="keyword">from</span> scott.emp <span class="keyword">where</span> empno=<span class="number">7369</span></span><br><span class="line"></span><br><span class="line">ENAME                JOB</span><br><span class="line"><span class="comment">-------------------- ----------</span></span><br><span class="line">SMITH                CLERK</span><br></pre></td></tr></table></figure>
<p>对变量复制之后之后，再次使用define，会显示这个变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS@db12c&gt;define gh</span><br><span class="line">DEFINE GH              = "7369" (CHAR)</span><br><span class="line"><span class="comment">-- 取消定义</span></span><br><span class="line">SYS@db12c&gt;undefine gh</span><br><span class="line">SYS@db12c&gt;define gh</span><br><span class="line">SP2-0135: symbol gh is UNDEFINED</span><br><span class="line"><span class="comment">-- 此时再使用&amp;gh，则还需要用户输入值</span></span><br></pre></td></tr></table></figure>
<h4 id="3">3. &amp;&amp;</h4>
<p>同一变量多次出现在一条语句中，只需要让用户输入一次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 此时用户需要输入两次一样的值</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,&amp;c3 <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> &amp;c3;</span><br><span class="line"></span><br><span class="line">Enter value for c3: sal</span><br><span class="line">Enter value for c3: sal</span><br><span class="line">old   1: <span class="keyword">select</span> empno,ename,&amp;c3 <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> &amp;c3</span><br><span class="line"><span class="keyword">new</span>   <span class="number">1</span>: <span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> sal</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                       SAL</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">      <span class="number">7369</span> SMITH                       <span class="number">800</span></span><br><span class="line">      <span class="number">7900</span> JAMES                       <span class="number">950</span></span><br><span class="line">      <span class="number">7876</span> ADAMS                      <span class="number">1100</span></span><br><span class="line">      <span class="number">7521</span> WARD                       <span class="number">1250</span></span><br><span class="line">      <span class="number">7654</span> MARTIN                     <span class="number">1250</span></span><br><span class="line">      <span class="number">7934</span> MILLER                     <span class="number">1300</span></span><br><span class="line">      <span class="number">7844</span> TURNER                     <span class="number">1500</span></span><br><span class="line">      <span class="number">7499</span> ALLEN                      <span class="number">1600</span></span><br><span class="line">      <span class="number">7782</span> CLARK                      <span class="number">2450</span></span><br><span class="line">      <span class="number">7698</span> BLAKE                      <span class="number">2850</span></span><br><span class="line">      <span class="number">7566</span> JONES                      <span class="number">2975</span></span><br><span class="line">      <span class="number">7788</span> SCOTT                      <span class="number">3000</span></span><br><span class="line">      <span class="number">7902</span> FORD                       <span class="number">3000</span></span><br><span class="line">      <span class="number">7839</span> KING                       <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> selected.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时用户只需要输入一次</span></span><br><span class="line"><span class="comment">-- &amp;&amp;意思是，接受用户输入并define</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,&amp;&amp;c3 <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> &amp;c3;</span><br><span class="line"></span><br><span class="line">Enter value for c3: sal</span><br><span class="line">old   1: <span class="keyword">select</span> empno,ename,&amp;&amp;c3 <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> &amp;c3</span><br><span class="line"><span class="keyword">new</span>   <span class="number">1</span>: <span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp <span class="keyword">order</span> <span class="keyword">by</span> sal</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                       SAL</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">      <span class="number">7369</span> SMITH                       <span class="number">800</span></span><br><span class="line">      <span class="number">7900</span> JAMES                       <span class="number">950</span></span><br><span class="line">      <span class="number">7876</span> ADAMS                      <span class="number">1100</span></span><br><span class="line">      <span class="number">7521</span> WARD                       <span class="number">1250</span></span><br><span class="line">      <span class="number">7654</span> MARTIN                     <span class="number">1250</span></span><br><span class="line">      <span class="number">7934</span> MILLER                     <span class="number">1300</span></span><br><span class="line">      <span class="number">7844</span> TURNER                     <span class="number">1500</span></span><br><span class="line">      <span class="number">7499</span> ALLEN                      <span class="number">1600</span></span><br><span class="line">      <span class="number">7782</span> CLARK                      <span class="number">2450</span></span><br><span class="line">      <span class="number">7698</span> BLAKE                      <span class="number">2850</span></span><br><span class="line">      <span class="number">7566</span> JONES                      <span class="number">2975</span></span><br><span class="line">      <span class="number">7788</span> SCOTT                      <span class="number">3000</span></span><br><span class="line">      <span class="number">7902</span> FORD                       <span class="number">3000</span></span><br><span class="line">      <span class="number">7839</span> KING                       <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> selected.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- &amp;相当于解引用</span></span><br><span class="line"><span class="keyword">SYS</span>@db12c&gt;<span class="keyword">define</span> &amp;c3</span><br><span class="line">SP2<span class="number">-0135</span>: symbol sal <span class="keyword">is</span> UNDEFINED</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 系统自动define，永久</span></span><br><span class="line"><span class="keyword">SYS</span>@db12c&gt;<span class="keyword">define</span> c3</span><br><span class="line"><span class="keyword">DEFINE</span> C3              = <span class="string">"sal"</span> (<span class="built_in">CHAR</span>)</span><br></pre></td></tr></table></figure>
<h3 id="访问多张表方法1-–-连接">访问多张表方法1 – 连接</h3>
<p>nested loop 嵌套循环</p>
<p>基准表、驱动表</p>
<h4 id="内部连接">内部连接</h4>
<p>只连接匹配的行</p>
<p>连接条件两边的字段都不能有null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL2这种写法，顺序写错会很慢</span></span><br><span class="line"><span class="comment">-- 形成的中间表为两个表的笛卡尔积</span></span><br><span class="line"><span class="keyword">select</span> b.buyer_id,b.buyer_name,s.qty</span><br><span class="line"><span class="keyword">from</span> buyers b,sales s</span><br><span class="line"><span class="keyword">where</span> b.buyer_id = s.buyer_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SQL3这种写法，Oracle会自动调整顺序</span></span><br><span class="line"><span class="comment">-- 形成的中间表为两个表经过ON条件过滤后的笛卡尔积</span></span><br><span class="line"><span class="keyword">select</span> b.buyer_id,b.buyer_name,s.qty</span><br><span class="line"><span class="keyword">from</span> buyers b <span class="keyword">inner</span> <span class="keyword">join</span> sales s</span><br><span class="line"><span class="keyword">on</span> b.buyer_id = s.buyer_id;</span><br><span class="line"><span class="comment">-- (inner可省)</span></span><br></pre></td></tr></table></figure>
<p>==sql语句优化==eg：？？？</p>
<p>起别名提高效率？？？</p>
<p>emp 10万员工 + dept 4个部门（10，20，30，40）</p>
<ul>
<li>from dept,emp：先到部门表取出一个部门10，将10作为条件，和员工表每一条记录匹配，每个表访问4次</li>
<li>from emp,dept：先到员工表取出一位员工，将这个员工作为条件，和部门表每一条记录匹配，每个表访问10万次</li>
</ul>
<p><strong>小表在前，大表在后，减少对表的访问次数？？？</strong></p>
<p><strong>sql从后往前过滤，把筛选掉最多的条件，放在==最后面==</strong></p>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200414205612726.png" alt="image-20200414205612726"></p>
<ul>
<li>i - internet 本店</li>
<li>g - grid 连锁店</li>
<li>c - cloud 以租代买</li>
</ul>
<h4 id="外部连接（处理null）">外部连接（处理null）</h4>
<p>==哪边外，哪边所有行数据全部显示==</p>
<p>最好用内部连接，外连接开销大？？？</p>
<h5 id="左外连接">左外连接</h5>
<p>返回左表的全部行和右表满足ON条件的行，如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替。</p>
<p>from emp,dept</p>
<p>显示全部部门，包括没有员工的部门 122</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL2写法（+）</span></span><br><span class="line">col name for a20</span><br><span class="line">col dept for a20</span><br><span class="line"><span class="keyword">select</span> e.employee_id <span class="keyword">id</span>, e.first_name||<span class="string">' '</span>||e.last_name <span class="keyword">name</span>, d.department_name dept, d.location_id</span><br><span class="line"><span class="keyword">from</span> hr.departments d, hr.employees e</span><br><span class="line"><span class="keyword">where</span> e.department_id(+) = d.department_id;</span><br><span class="line"><span class="comment">-- SQL3写法（join），out都可以省略</span></span><br><span class="line"><span class="keyword">select</span> e.employee_id <span class="keyword">id</span>, e.first_name||<span class="string">' '</span>||e.last_name <span class="keyword">name</span>, d.department_name dept, d.location_id</span><br><span class="line"><span class="keyword">from</span> hr.departments d <span class="keyword">left</span> <span class="keyword">join</span> hr.employees e</span><br><span class="line"><span class="keyword">on</span> e.department_id = d.department_id;</span><br><span class="line"><span class="comment">-- on后面也可以再加and</span></span><br></pre></td></tr></table></figure>
<h5 id="右外连接">右外连接</h5>
<p>返回右表的全部行和左表满足ON条件的行，如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替。</p>
<p>from emp,dept</p>
<p>显示全部员工，包括没有部门的员工</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col name for a20</span><br><span class="line">col dept for a20</span><br><span class="line"><span class="keyword">select</span> e.employee_id <span class="keyword">id</span>, e.first_name||<span class="string">' '</span>||e.last_name <span class="keyword">name</span>, d.department_name dept, d.location_id</span><br><span class="line"><span class="keyword">from</span> hr.departments d, hr.employees e</span><br><span class="line"><span class="keyword">where</span> e.department_id = d.department_id(+);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.employee_id <span class="keyword">id</span>, e.first_name||<span class="string">' '</span>||e.last_name <span class="keyword">name</span>, d.department_name dept, d.location_id</span><br><span class="line"><span class="keyword">from</span> hr.departments d <span class="keyword">right</span> <span class="keyword">join</span> hr.employees e</span><br><span class="line"><span class="keyword">on</span> e.department_id = d.department_id;</span><br></pre></td></tr></table></figure>
<h5 id="全外连接">全外连接</h5>
<p>会从左表 和右表 那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替</p>
<p>全外 = 左外 UNION 右外</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 全外连接 SQL3才支持（不能两边加号）</span></span><br><span class="line">col name for a20</span><br><span class="line">col dept for a20</span><br><span class="line"><span class="keyword">select</span> e.employee_id <span class="keyword">id</span>, e.first_name||<span class="string">' '</span>||e.last_name <span class="keyword">name</span>, d.department_name dept, d.location_id</span><br><span class="line"><span class="keyword">from</span> hr.departments d <span class="keyword">full</span> <span class="keyword">join</span> hr.employees e</span><br><span class="line"><span class="keyword">on</span> e.department_id = d.department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内连接</span></span><br><span class="line">col name for a20</span><br><span class="line">col dept for a20</span><br><span class="line"><span class="keyword">select</span> e.employee_id <span class="keyword">id</span>, e.first_name||<span class="string">' '</span>||e.last_name <span class="keyword">name</span>, d.department_name dept, d.location_id</span><br><span class="line"><span class="keyword">from</span> hr.departments d <span class="keyword">join</span> hr.employees e</span><br><span class="line"><span class="keyword">on</span> e.department_id = d.department_id;</span><br></pre></td></tr></table></figure>
<h4 id="多表连接">多表连接</h4>
<p>sales只有(buyer_id, prod_id, qty)，还需要buyers表和product表提供两者的name</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.buyer_name,p.prod_name,s.qty</span><br><span class="line"><span class="keyword">from</span> scott.buyers b, scott.sales s, scott.product p</span><br><span class="line"><span class="keyword">where</span> b.buyer_id = s.buyer_id</span><br><span class="line"><span class="keyword">and</span> p.prod_id = s.prod_id;</span><br><span class="line"><span class="comment">-- 相当于两次内连接</span></span><br><span class="line"><span class="keyword">select</span> b.buyer_name,p.prod_name,s.qty</span><br><span class="line"><span class="keyword">from</span> scott.buyers b</span><br><span class="line"><span class="keyword">join</span> scott.sales s</span><br><span class="line"><span class="keyword">on</span> b.buyer_id = s.buyer_id   </span><br><span class="line"><span class="keyword">join</span> scott.product p</span><br><span class="line"><span class="keyword">on</span> p.prod_id = s.prod_id;</span><br></pre></td></tr></table></figure>
<p>最多连4张表，否则效率太低，效率出现拐点</p>
<p>解决方法：物化视图（实体化视图），变成一种存储结构了，但可以和基表同步。了解就行</p>
<ul>
<li>业务系统中，更新频繁时，总是同步物化视图，效率不高</li>
<li>数据仓库，只做查询，不变化时，适用</li>
</ul>
<h4 id="自连接">自连接</h4>
<p>购买同一种水果的顾客（prodid相同，但buyerid不同）</p>
<p>这两个数据在一张表中，所以必须用别名区分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 会查出一样的数据（镜像）</span></span><br><span class="line"><span class="keyword">select</span> a.buyer_id <span class="keyword">as</span> buyer1, b.buyer_id <span class="keyword">as</span> buyer2, a.prod_id</span><br><span class="line"><span class="keyword">from</span> scott.sales a, scott.sales b</span><br><span class="line"><span class="keyword">where</span> a.prod_id = b.prod_id</span><br><span class="line"><span class="keyword">and</span> a.buyer_id &lt;&gt; b.buyer_id;</span><br><span class="line"><span class="comment">-- 大于小于留一个就行</span></span><br><span class="line"><span class="keyword">select</span> a.buyer_id <span class="keyword">as</span> buyer1, b.buyer_id <span class="keyword">as</span> buyer2, a.prod_id</span><br><span class="line"><span class="keyword">from</span> scott.sales a, scott.sales b</span><br><span class="line"><span class="keyword">where</span> a.prod_id = b.prod_id</span><br><span class="line"><span class="keyword">and</span> a.buyer_id &lt; b.buyer_id;</span><br></pre></td></tr></table></figure>
<h4 id="交叉连接（笛卡尔乘积）">交叉连接（笛卡尔乘积）</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.buyer_name,s.qty <span class="keyword">from</span> scott.buyers b, scott.sales s;</span><br><span class="line"><span class="keyword">select</span> b.buyer_name,s.qty <span class="keyword">from</span> scott.buyers b <span class="keyword">cross</span> <span class="keyword">join</span> scott.sales s;</span><br></pre></td></tr></table></figure>
<h4 id="自然连接">自然连接</h4>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200313091614228.png" alt="image-20200313091614228" style="zoom:67%;">
<p>自动查找匹配的字段（需要名字相同，且字段类型相同）</p>
<p>有多个相同，则同时匹配；如果没有，则笛卡尔乘积</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200313091701960.png" alt="image-20200313091701960" style="zoom:67%;">
<p>也可以用using指定匹配的字段，using不能（表名.字段），不能有表名</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200313091833106.png" alt="image-20200313091833106" style="zoom:67%;">
<h3 id="访问多张表方法2-–-子查询">访问多张表方法2 – 子查询</h3>
<p>32.07</p>
<h4 id="嵌套子查询">嵌套子查询</h4>
<p>子查询作为条件被外部语句引用，内部查询只执行一次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal&gt;(<span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> ename = <span class="string">'SMITH'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="keyword">in</span> (<span class="keyword">select</span> deptno <span class="keyword">from</span> dept <span class="keyword">where</span> loc <span class="keyword">in</span> (<span class="string">'NEW YORK'</span>,<span class="string">'CHICAGO'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询谁工资最少</span></span><br><span class="line"><span class="keyword">select</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> salary = (<span class="keyword">select</span> <span class="keyword">min</span>(salary) <span class="keyword">from</span> hr.employees);</span><br><span class="line"><span class="comment">-- 查询每个部门工资最少的（用group by）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子查询返回为空，则外部查询不执行</li>
<li>子查询返回一行，则用单行操作符（= &lt; &gt; &lt;= &gt;= &lt;&gt;）</li>
<li>子查询返回多行，则不能使用单行操作符，要用多行操作符（in all any）
<ol>
<li>in 只要满足里面一个就出来</li>
<li>any 取条件最宽松的</li>
<li>all 取条件最严格</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 工资只要大于1500就好</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal&gt; <span class="keyword">any</span>(<span class="number">1500</span>,<span class="number">2850</span>);</span><br><span class="line"><span class="comment">-- 工资需要大于2850才能</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal&gt; <span class="keyword">all</span>(<span class="number">1500</span>,<span class="number">2850</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- any和all将多个值变为一个值</span></span><br><span class="line"><span class="comment">-- in只能用于判断是否和结果集中的一个相等</span></span><br></pre></td></tr></table></figure>
<p>运算的步骤放在右边效率会高一些。</p>
<p>多列子查询，只需要访问一次内部表即可，提高效率</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200415120715622.png" alt="image-20200415120715622" style="zoom: 80%;">
<h4 id="关联子查询">关联子查询</h4>
<p>和连接相似，外部查询得到的每一条结果传到内部查询中执行【类似于嵌套循环】</p>
<ul>
<li>一般连接的效率高于关联子查询，但关联子查询可读性高</li>
<li>外部查询返回较少记录时,关联子查询比嵌套子查询效果高;</li>
<li>内部查询返回较少记录时,嵌套子查询比关联子查询效果高.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">last_name,salary,department_id条件：高于其部门的平均工资利用关联子查询实现</span><br><span class="line"><span class="keyword">select</span> e.last_name,e.salary,e.department_id</span><br><span class="line"><span class="keyword">from</span> hr.employees e,</span><br><span class="line">  (<span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avgsal,department_id <span class="keyword">from</span> hr.employees <span class="keyword">group</span> <span class="keyword">by</span> department_id) s</span><br><span class="line"><span class="keyword">where</span> e.salary &gt; s.avgsal <span class="keyword">and</span> e.DEPARTMENT_ID = s.DEPARTMENT_ID;</span><br><span class="line">  或</span><br><span class="line"><span class="keyword">select</span> e.last_name,e.salary,e.department_id</span><br><span class="line"><span class="keyword">from</span> hr.employees e</span><br><span class="line"><span class="keyword">where</span> salary&gt;(<span class="keyword">select</span> <span class="keyword">avg</span>(salary)<span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> e.department_id = department_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id);</span><br></pre></td></tr></table></figure>
<h3 id="处理多个结果集">处理多个结果集</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> depyto =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> depyto =<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>两个结果集如何合并？</p>
<p>前提：两者的数据模式要一致</p>
<p>4个操作符：</p>
<pre><code>  1. union 去重
  2. union all 允许重复
  3. intersect 取交集
  4. minus 取第一个结果集去掉交集
</code></pre>
<p>为了保证结构对应，使用to_number(null)，或者直接用0填充</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200313102858035.png" alt="image-20200313102858035" style="zoom:67%;">
<img src="/2020/03/10/Oracle/OracleSQL/image-20200313102934943.png" alt="image-20200313102934943" style="zoom:67%;">
<p>控制结果集的顺序，了解</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200415122712218.png" alt="image-20200415122712218" style="zoom: 80%;">
<h3 id="伪列rownum-level">伪列rownum level</h3>
<p><strong>伪列</strong>就像表中的列一样，但是在表中并不存储。伪列只能查询，不能进行增删改操作。</p>
<ul>
<li>伪列rownum，在查询的结果集中，ROWNUM为结果集中每一行标识一个行号，第一行返回1，第二行返回2，以此类推。通过ROWNUM伪列可以限制查询结果集中返回的行数。</li>
<li>ROWNUM与ROWID不同，ROWID是插入记录时生成，ROWNUM是查询数据时生成</li>
<li>ROWID标识的是行的物理地址。ROWNUM标识的是查询结果中的行的次序。</li>
<li>LEVEL是一个“伪列”，代表树的第几层。对根节点来说，LEVEL返回1，根节点的子节点返回2，以此类推</li>
</ul>
<h3 id="别名">别名</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name <span class="keyword">as</span> <span class="keyword">name</span> <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>
<p>as 可以省略，别名引号？？？</p>
<p>表名加前缀，可以提高性能，别名提高性能？？？</p>
<h2 id="1’-QL函数">1’ QL函数</h2>
<p>找手册：<a href="https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/sql-language-reference.pdf" target="_blank" rel="noopener">https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/sql-language-reference.pdf</a></p>
<h3 id="字符型">字符型</h3>
<h4 id="lower-upper-initcap-concat">lower upper initcap concat</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">lower</span>(<span class="string">'SQL Course'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">upper</span>(<span class="string">'SQL Course'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> initcap(<span class="string">'SQL Course'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 只把第一个字母大写，其他全部小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'hello'</span>,<span class="string">'world'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 字符串连接函数，不改变大小写，只能两个参数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">concat</span>(<span class="string">'hello'</span>,<span class="string">'Oracle'</span>),<span class="string">'world'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 可以嵌套使用</span></span><br><span class="line"><span class="comment">-- || 也是连接字符串</span></span><br></pre></td></tr></table></figure>
<p>字符（串）加引号之后，大小写敏感</p>
<p>eg 查找人名的时候，不一定改后面的目标数据，可以改表中的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,sal <span class="keyword">from</span> scott.emp <span class="keyword">where</span> <span class="keyword">lower</span>(ename)=<span class="string">'james'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="length">length</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(<span class="string">'hahaha'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 6</span></span><br></pre></td></tr></table></figure>
<h4 id="substr">substr</h4>
<p>下标从1开始，取5个字符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'HelloWorld'</span>,<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">from</span> dual; <span class="comment">-- Hello</span></span><br></pre></td></tr></table></figure>
<p>如果要取到结尾，最后一个参数省略</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'HelloWorld'</span>,<span class="number">6</span>) <span class="keyword">from</span> dual; <span class="comment">-- World</span></span><br></pre></td></tr></table></figure>
<p>从倒数第五个开始正着取5个</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'HelloWorld'</span>,<span class="number">-5</span>,<span class="number">4</span>) <span class="keyword">from</span> dual; <span class="comment">-- Worl</span></span><br></pre></td></tr></table></figure>
<h4 id="instr">instr</h4>
<p>查找第一个出现的某字符的位置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'W'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'l'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 3</span></span><br></pre></td></tr></table></figure>
<p>从哪一位开始找起</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'l'</span>,<span class="number">4</span>) <span class="keyword">from</span> dual; <span class="comment">-- 4</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'l'</span>,<span class="number">5</span>) <span class="keyword">from</span> dual; <span class="comment">-- 9</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'l'</span>,<span class="number">-1</span>) <span class="keyword">from</span> dual; <span class="comment">-- 9 从右边第一个找起</span></span><br></pre></td></tr></table></figure>
<p>==从哪一位开始的第几个==</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'l'</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">from</span> dual; <span class="comment">-- 3</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'l'</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">from</span> dual; <span class="comment">-- 4</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'HelloWorld'</span>,<span class="string">'l'</span>,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">from</span> dual; <span class="comment">-- 9</span></span><br></pre></td></tr></table></figure>
<h4 id="lpad-rpad">lpad rpad</h4>
<p>padding – 填充、无意义的废话，和setw类似</p>
<p>lpad即为填充左部，右对齐</p>
<p>rpad即为填充右部，左对齐</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(last_name,<span class="number">12</span>,<span class="string">'-'</span>) <span class="keyword">from</span> employees; <span class="comment">-- 将位数填充至12位，-是填充符</span></span><br></pre></td></tr></table></figure>
<h4 id="level-pad实现层次查询">level + pad实现层次查询</h4>
<p>用填充，格式化层次型的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 空格个数(n-1)*2</span></span><br><span class="line">col ename for a30</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(<span class="string">'-'</span>,(<span class="keyword">level</span><span class="number">-1</span>)*<span class="number">2</span>,<span class="string">'-'</span>) || ename ename, <span class="keyword">level</span> <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> empno=<span class="number">7839</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">prior</span> empno=mgr;</span><br><span class="line"><span class="comment">-- 从最大的领导开始，找下属</span></span><br><span class="line"><span class="comment">-- 也可以从一个小领导开始</span></span><br><span class="line">col ename for a30</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(<span class="string">'-'</span>,(<span class="keyword">level</span><span class="number">-1</span>)*<span class="number">2</span>,<span class="string">'-'</span>) || ename ename, <span class="keyword">level</span> <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> empno=<span class="number">7839</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> mgr = <span class="keyword">prior</span> empno;</span><br><span class="line">ENAME                               LEVEL</span><br><span class="line"><span class="comment">------------------------------ ----------</span></span><br><span class="line">KING                                    1</span><br><span class="line"><span class="comment">--JONES                                 2</span></span><br><span class="line"><span class="comment">----SCOTT                               3</span></span><br><span class="line"><span class="comment">------ADAMS                             4</span></span><br><span class="line"><span class="comment">----FORD                                3</span></span><br><span class="line"><span class="comment">------SMITH                             4</span></span><br><span class="line"><span class="comment">--BLAKE                                 2</span></span><br><span class="line"><span class="comment">----ALLEN                               3</span></span><br><span class="line"><span class="comment">----WARD                                3</span></span><br><span class="line"><span class="comment">----MARTIN                              3</span></span><br><span class="line"><span class="comment">----TURNER                              3</span></span><br><span class="line"><span class="comment">----JAMES                               3</span></span><br><span class="line"><span class="comment">--CLARK                                 2</span></span><br><span class="line"><span class="comment">----MILLER                              3</span></span><br><span class="line"></span><br><span class="line">14 rows selected.</span><br><span class="line"></span><br><span class="line">col ename for a30</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(<span class="string">'-'</span>,(<span class="keyword">level</span><span class="number">-1</span>)*<span class="number">2</span>,<span class="string">'-'</span>)||ename ename, <span class="keyword">level</span> <span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> empno=<span class="number">7369</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">prior</span> mgr=empno;</span><br><span class="line"><span class="comment">-- 从最大的领导开始，找下属</span></span><br><span class="line"></span><br><span class="line">ENAME                               LEVEL</span><br><span class="line"><span class="comment">------------------------------ ----------</span></span><br><span class="line">SMITH                                   1</span><br><span class="line"><span class="comment">--FORD                                  2</span></span><br><span class="line"><span class="comment">----JONES                               3</span></span><br><span class="line"><span class="comment">------KING                              4</span></span><br></pre></td></tr></table></figure>
<p>LEVEL是一个“伪列”，代表树的第几层。对根节点来说，LEVEL返回1，根节点的子节点返回2，以此类推</p>
<h4 id="trim">trim</h4>
<p>相当于python中的strip</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">trim</span>(<span class="string">'H'</span> <span class="keyword">from</span> <span class="string">'HelloWorld'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">trim</span>(<span class="string">'H'</span> <span class="keyword">from</span> <span class="string">'HelloWorldH'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">trim</span>(<span class="string">'H'</span> <span class="keyword">from</span> <span class="string">'HelloHorld'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 不会去除中间的</span></span><br></pre></td></tr></table></figure>
<h3 id="数字型">数字型</h3>
<h4 id="round（四舍五入）">round（四舍五入）</h4>
<p>两个参数，一个是源数据，第二个是舍入的位数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">45.926</span>,<span class="number">2</span>) <span class="keyword">from</span> dual; <span class="comment">-- 45.93</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">45.926</span>) <span class="keyword">from</span> dual; <span class="comment">-- 46</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">45.926</span>,<span class="number">-1</span>) <span class="keyword">from</span> dual; <span class="comment">-- 50</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>正数表示小数点向右数，1代表十分位，2代表百分位</p>
</li>
<li>
<p>0表示舍入到个位，不写这个参数的话默认值就是0</p>
</li>
<li>
<p>负数表示小数点向左数，-1表示十位，-2百位</p>
</li>
</ul>
<h4 id="trunc（四舍五舍）">trunc（四舍五舍）</h4>
<p>和round语法完全一致，只是将舍入变为一律截断</p>
<h4 id="ceil-floor">ceil floor</h4>
<p>向上取整，向下取整</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ceil</span>(<span class="number">2.55</span>) <span class="keyword">from</span> dual; <span class="comment">-- 3</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="number">2.55</span>) <span class="keyword">from</span> dual; <span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
<h4 id="mod">mod</h4>
<p>取余数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">mod</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="keyword">from</span> dual; <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure>
<h3 id="日期型">日期型</h3>
<p>Oracle中日期类型存储得很全：世纪 - 年 - 月 - 日 - 时 - 分 - 秒</p>
<p>但是查找出来的，只是按照格式显示的一部分</p>
<h4 id="日期格式">日期格式</h4>
<h4 id="sysdate-current-date">sysdate current_date</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> <span class="keyword">from</span> dual; <span class="comment">-- 按nls_date_format参数格式显示</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">current_date</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<ul>
<li>nls是Oracle初始化参数</li>
<li>和sqlplus的参数区分</li>
</ul>
<p>规定日期格式</p>
<ul>
<li>nls==多级别覆盖问题==，见知识点</li>
<li>alter session 会话级设置，关闭会话，参数失效</li>
<li>alter system 系统级设置（nls不要用system，会被覆盖）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh:mi:ss'</span>;</span><br><span class="line"><span class="comment">-- alter system set nls_date_format='yyyy-mm-dd hh:mi:ss'; -- 不能这样改，scope问题？？？</span></span><br><span class="line"><span class="comment">-- 不能有两个mm：月份为mm，分钟为mi</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 静态参数？？？修改后，重启Oracle生效？？？</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh24:mi:ss'</span> <span class="keyword">scope</span>=<span class="keyword">spfile</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh24:mi:ss am'</span>; <span class="comment">-- 24小时制</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh:mi:ss am'</span>; <span class="comment">-- 12小时制，但有上下午表示</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<p>千年虫问题：用2位数字表示年份时</p>
<p>年的格式：</p>
<ul>
<li>
<p>yyyy格式，最常用</p>
</li>
<li>
<p>YY格式，和当前日期同一个世纪</p>
</li>
<li>
<p>RR格式（默认），取离当前日期最近的一个世纪</p>
<p>如下图的第二行例子：2017离1995，比1917离1995近，所以取2017</p>
</li>
</ul>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310145148675.png" alt="image-20200310145148675" style="zoom:67%;">
<h4 id="systimestamp-current-timestamp">systimestamp current_timestamp</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> systimestamp <span class="keyword">from</span> dual; <span class="comment">-- 13-APR-20 11.30.37.074805 PM +08:00</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- 按什么格式显示的？？？+08:00东八区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 括号中的是秒的小数位数（最多9位）</span></span><br><span class="line"><span class="keyword">select</span> systimestamp(<span class="number">3</span>) <span class="keyword">from</span> dual; <span class="comment">-- 13-APR-20 11.32.05.755 PM +08:00</span></span><br><span class="line"><span class="keyword">select</span> systimestamp(<span class="number">9</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- select systimestamp(10) from dual;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<h4 id="date相减">date相减</h4>
<p>查入职时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col last_name for a 20</span><br><span class="line"><span class="keyword">select</span> last_name, (<span class="keyword">sysdate</span>-hire_date)/<span class="number">7</span> <span class="keyword">as</span> weeks</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> department_id=<span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他日期函数？？？">其他日期函数？？？</h4>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310145539136.png" alt="image-20200310145539136" style="zoom:67%;">
<p>month_between 两个日期之间相差多少个月</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 刚刚会话级修改了nls日期格式，注意！</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'DD-MON-RR'</span>;</span><br><span class="line"><span class="keyword">select</span> months_between(<span class="string">'01-SEP-05'</span>, <span class="string">'11-JAN-04'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- 离现在近的日期放第一个！！！有顺序</span></span><br><span class="line"><span class="comment">-- select months_between('11-JAN-04','01-SEP-05') from dual;</span></span><br><span class="line"><span class="comment">-- 写反了会返回负数（相反数？？？）</span></span><br></pre></td></tr></table></figure>
<p>next_day中最后可以使用数字代替星期（1 - Sun，2 - Tue），下一个星期几是哪一天</p>
<h4 id="日期的舍入-截断">日期的舍入/截断</h4>
<p>判断是不是同一年</p>
<ol>
<li>提取年to_char？？？</li>
<li>截断年</li>
</ol>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310150035174.png" alt="image-20200310150035174" style="zoom:67%;">
<p>舍入 == 有没有过了这一月/年的一半</p>
<ul>
<li>以月为单位，则结果一定是1号</li>
<li>以年为单位，则结果一定是1.1</li>
</ul>
<h3 id="转换函数">转换函数</h3>
<ul>
<li>显示转换</li>
<li>隐式转换</li>
</ul>
<h4 id="to-char">to_char</h4>
<p>格式在to_char专用？？？和nls_date_format不通用？？？</p>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200310153636547.png" alt="image-20200310153636547"></p>
<p>大小写敏感</p>
<p>month Month MONTH不同，其他以此类推</p>
<p>加fm，会把没用的填充“0”去掉（fmdd）</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200414003319350.png" alt="image-20200414003319350" style="zoom:80%;">
<h5 id="日期转换为字符">日期转换为字符</h5>
<p>转换为字符的目的：按照我设定的格式来显示</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310153239676.png" alt="image-20200310153239676" style="zoom:67%;">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,hire_date <span class="keyword">from</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ename,to_char(hire_date,<span class="string">'yyyy-mm-dd'</span>) <span class="keyword">from</span> hr.employees; <span class="comment">-- 日期格式见上</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> nls_language=american;</span><br><span class="line"><span class="comment">--NLS_LANG=american_america.ZHS16GBK; export NLS_LANG</span></span><br><span class="line"></span><br><span class="line">to_char(sysdate, ‘yyyy/mm/dd’); <span class="comment">--‘2003/07/09’</span></span><br><span class="line">to_char(sysdate, ‘Month DD, YYYY’); <span class="comment">--‘July 09, 2003’</span></span><br><span class="line">to_char(sysdate, ‘FMMonth DD, YYYY’); <span class="comment">-- ‘July 9, 2003’</span></span><br><span class="line">to_char(sysdate, ‘MON DDth, YYYY’);	<span class="comment">--‘JUL 09TH, 2003’</span></span><br><span class="line">to_char(sysdate, ‘FMMON DDth, YYYY’); <span class="comment">-- ‘JUL 9TH, 2003’</span></span><br><span class="line">to_char(sysdate, ‘FMMon ddth, YYYY’); <span class="comment">-- ‘Jul 9th, 2003’</span></span><br></pre></td></tr></table></figure>
<h5 id="数字转换为字符">数字转换为字符</h5>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200414003925922.png" alt="image-20200414003925922" style="zoom:80%;">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,to_char(sal,<span class="string">'99,999.99'</span>) <span class="keyword">as</span> sal <span class="keyword">from</span> scott.emp; <span class="comment">-- 位数不够，不会填充</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,to_char(sal,<span class="string">'90,999.99'</span>) <span class="keyword">as</span> sal <span class="keyword">from</span> scott.emp; <span class="comment">-- 第4位强制显示0</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,to_char(sal,<span class="string">'$90,999.99'</span>) <span class="keyword">as</span> sal <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">select</span> empno,ename,to_char(sal,<span class="string">'L90,999.99'</span>) <span class="keyword">as</span> sal <span class="keyword">from</span> scott.emp; <span class="comment">-- 本地货币符号</span></span><br><span class="line"><span class="comment">-- 本地在哪和nls_territory有关，可改为america、china、united kingdom等</span></span><br><span class="line"></span><br><span class="line">to_char(1210.73, ‘9999.9’) <span class="comment">--‘1210.7’</span></span><br><span class="line">to_char(1210.73, ‘9,999.99’) <span class="comment">--‘1,210.73’</span></span><br><span class="line">to_char(1210.73, ‘$9,999.00’) <span class="comment">--‘$1,210.73’</span></span><br><span class="line">to_char(21, ‘000099’) <span class="comment">-- 000021’</span></span><br></pre></td></tr></table></figure>
<h4 id="to-date（使用很多）">to_date（使用很多）</h4>
<p>将字符类型按一定格式转化为日期类型，前后要一致</p>
<p>修改表中date类型数据时，格式不对很麻烦</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- update scott.emp set hiredate='1981-09-05' where empno=7900; -- 格式可能不对</span></span><br></pre></td></tr></table></figure>
<p>==自由写日期格式==，需要使用to_date将字符串改为date类型？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> scott.emp <span class="keyword">set</span> hiredate=<span class="keyword">to_date</span>(<span class="string">'1981-09-05'</span>,<span class="string">'yyyy-mm-dd'</span>) <span class="keyword">where</span> empno=<span class="number">7900</span>;</span><br></pre></td></tr></table></figure>
<p>YYYY：四位表示的年份<br>
YYY，YY，Y：年份的最后三位、两位或一位，缺省为当前世纪<br>
MM：01~12的月份编号<br>
MONTH：九个字符表示的月份，右边用空格填补<br>
MON：三位字符的月份缩写<br>
WW：一年中的星期<br>
D：星期中的第几天<br>
DD：月份中的第几天<br>
DDD：年所中的第几天<br>
DAY：九个字符表示的天的全称，右边用空格补齐<br>
HH，HH12：一天中的第几个小时，12进制表示法<br>
HH24：一天中的第几个小时，取值为00~23<br>
MI：一小时中的分钟<br>
SS：一分钟中的秒<br>
SSSS：从午夜开始过去的秒数</p>
<h3 id="处理null值的函数">处理null值的函数</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal,comm <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p>eg scott.emp中，comm为奖金，可能为空</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310160118150.png" alt="image-20200310160118150" style="zoom:80%;">
<h4 id="NVL">NVL</h4>
<p>expr1：如果不为null，则返回expr1；为null则返回expr2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(comm) <span class="keyword">from</span> scott.emp; <span class="comment">-- 550，奖金为null的舍弃</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(nvl(comm,<span class="number">0</span>)) <span class="keyword">from</span> scott.emp; <span class="comment">-- 157.14，奖金为null的按0处理</span></span><br><span class="line"><span class="comment">-- 对奖金进行判断：如果为空，则值为0；如果不为空，则值为奖金数</span></span><br></pre></td></tr></table></figure>
<h4 id="NVL2">NVL2</h4>
<p>expr1：如果不为null，则返回expr2；为null则返回expr3</p>
<p>构造收入 = sal + comm</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename,sal,comm, nvl2(comm,sal+comm,sal) <span class="keyword">as</span> income <span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure>
<h4 id="NULLIF">NULLIF</h4>
<p>判断expr1和expr2是否相同：如果相同返回null；如果相同，返回expr1</p>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200310160156120.png" alt="image-20200310160156120"></p>
<h4 id="COALESC">COALESC</h4>
<p>练习</p>
<p>后面跟一串值，取第一个不为null的值返回</p>
<p>一个数字 + null = null？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno, ename, sal, comm, <span class="keyword">coalesce</span>(comm+sal, sal) <span class="keyword">as</span> income <span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure>
<h3 id="处理if-then-else逻辑">处理if-then-else逻辑</h3>
<h4 id="CASE">CASE</h4>
<p>eg1：特定工种的人加工资</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310161009017.png" alt="image-20200310161009017" style="zoom:67%;">
<p>eg2：根据工资给员工分档次</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310161314653.png" alt="image-20200310161314653" style="zoom:67%;">
<h4 id="DECODE（使用很多）">DECODE（使用很多）</h4>
<p>只能用于判断是否相等，<strong>不能判断</strong>大于小于等<strong>范围</strong>关系</p>
<ul>
<li>第一个是待判断的值</li>
<li>后面一对一对看，即为条件和输出</li>
<li>最后一个是else的值</li>
</ul>
<p>eg1：特定工种的人加工资</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310161058714.png" alt="image-20200310161058714" style="zoom:67%;">
<p>eg2：根据工资等级收税</p>
<img src="/2020/03/10/Oracle/OracleSQL/image-20200310161358726.png" alt="image-20200310161358726" style="zoom:67%;">
<h3 id="组函数">组函数</h3>
<p>和group by搭配使用</p>
<p>不group by则对所有记录的某一字段操作（取最大值等）</p>
<h4 id="greatest-least">greatest least</h4>
<p>max min只能有两个参数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">greatest</span>(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>) <span class="keyword">from</span> dual; <span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">least</span>(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>) <span class="keyword">from</span> dual; <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure>
<h4 id="avg-count-max-min-sum">avg count max min sum</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="listagg-列表聚合">listagg 列表聚合</h4>
<p>一行显示所有姓名，但也有前后之分（用group）</p>
<p><code>listagg([要聚合的列],'分隔符') within group(order by [按哪个字段排序显示])</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col ename for a100</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">listagg</span>(ename,<span class="string">','</span>) <span class="keyword">within</span> <span class="keyword">group</span> (<span class="keyword">order</span> <span class="keyword">by</span> empno) <span class="keyword">as</span> ename</span><br><span class="line"><span class="keyword">from</span> scott.emp;</span><br><span class="line"></span><br><span class="line">ENAME</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------</span></span><br><span class="line">SMITH,ALLEN,WARD,JONES,MARTIN,BLAKE,CLARK,SCOTT,KING,TURNER,ADAMS,JAMES,FORD,MILLER</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/10/Oracle/OracleSQL/image-20200310164759320.png" alt="image-20200310164759320"></p>
<h4 id="stddev-偏差">stddev 偏差</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="variance-方差">variance 方差</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="rollup">rollup</h4>
<p>和多分组条件（group by 加多个字段）的区别！</p>
<p>rollby可以对分组==进行小计==，sum？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id,job_id,<span class="keyword">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> department_id&gt;<span class="number">40</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">rollup</span>(department_id,job_id);</span><br><span class="line"></span><br><span class="line">DEPARTMENT_ID JOB_ID               SUM(SALARY)</span><br><span class="line"><span class="comment">------------- -------------------- -----------</span></span><br><span class="line">           50 ST_MAN                     36400</span><br><span class="line">           50 SH_CLERK                   64300</span><br><span class="line">           50 ST_CLERK                   55700</span><br><span class="line">           50                           156400</span><br><span class="line">           60 IT_PROG                    28800</span><br><span class="line">           60                            28800</span><br><span class="line">           70 PR_REP                     10000</span><br><span class="line">           70                            10000</span><br><span class="line">           80 SA_MAN                     61000</span><br><span class="line">           80 SA_REP                    243500</span><br><span class="line">           80                           304500</span><br><span class="line">           90 AD_VP                      34000</span><br><span class="line">           90 AD_PRES                    24000</span><br><span class="line">           90                            58000</span><br><span class="line">          100 FI_MGR                     12008</span><br><span class="line">          100 FI_ACCOUNT                 39600</span><br><span class="line">          100                            51608</span><br><span class="line">          110 AC_MGR                     12008</span><br><span class="line">          110 AC_ACCOUNT                  8300</span><br><span class="line">          110                            20308</span><br><span class="line">                                        629616</span><br><span class="line"><span class="comment">-- 交换顺序也可以</span></span><br><span class="line"><span class="keyword">select</span> job_id,department_id,<span class="keyword">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">rollup</span>(job_id,department_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> department_id,job_id,<span class="keyword">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> department_id&gt;<span class="number">40</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id,job_id+department_id+<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="cube">cube</h4>
<p>“两个方向”都产生小计</p>
<p>第二个方向（job）没有次级详细信息（department）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id,job_id,<span class="keyword">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> department_id&gt;<span class="number">40</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">cube</span>(department_id,job_id);</span><br><span class="line"></span><br><span class="line">DEPARTMENT_ID JOB_ID               SUM(SALARY)</span><br><span class="line"><span class="comment">------------- -------------------- -----------</span></span><br><span class="line">                                        629616</span><br><span class="line">              AD_VP                      34000</span><br><span class="line">              AC_MGR                     12008</span><br><span class="line">              FI_MGR                     12008</span><br><span class="line">              PR_REP                     10000</span><br><span class="line">              SA_MAN                     61000</span><br><span class="line">              SA_REP                    243500</span><br><span class="line">              ST_MAN                     36400</span><br><span class="line">              AD_PRES                    24000</span><br><span class="line">              IT_PROG                    28800</span><br><span class="line">              SH_CLERK                   64300</span><br><span class="line">              ST_CLERK                   55700</span><br><span class="line">              AC_ACCOUNT                  8300</span><br><span class="line">              FI_ACCOUNT                 39600</span><br><span class="line">           50                           156400</span><br><span class="line">           50 ST_MAN                     36400</span><br><span class="line">           50 SH_CLERK                   64300</span><br><span class="line">           50 ST_CLERK                   55700</span><br><span class="line">           60                            28800</span><br><span class="line">           60 IT_PROG                    28800</span><br><span class="line">           70                            10000</span><br><span class="line">           70 PR_REP                     10000</span><br><span class="line">           80                           304500</span><br><span class="line">           80 SA_MAN                     61000</span><br><span class="line">           80 SA_REP                    243500</span><br><span class="line">           90                            58000</span><br><span class="line">           90 AD_VP                      34000</span><br><span class="line">           90 AD_PRES                    24000</span><br><span class="line">          100                            51608</span><br><span class="line">          100 FI_MGR                     12008</span><br><span class="line">          100 FI_ACCOUNT                 39600</span><br><span class="line">          110                            20308</span><br><span class="line">          110 AC_MGR                     12008</span><br><span class="line">          110 AC_ACCOUNT                  8300</span><br><span class="line"><span class="keyword">select</span> department_id,job_id,<span class="keyword">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> department_id&gt;<span class="number">40</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">cube</span>(department_id,job_id);</span><br></pre></td></tr></table></figure>
<h2 id="1’’-QL练习题">==1’’ QL练习题==</h2>
<h3 id="从全名中取lastname">从全名中取lastname</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.buyers;</span><br><span class="line"><span class="keyword">select</span> buyer_id, <span class="keyword">substr</span>(buyer_name,<span class="keyword">instr</span>(buyer_name,<span class="string">' '</span>)+<span class="number">1</span>) <span class="keyword">from</span> scott.buyers;</span><br><span class="line"><span class="comment">-- 只有一个参数，表示取到结尾</span></span><br></pre></td></tr></table></figure>
<h3 id="根据入职时间长短排序">根据入职时间长短排序</h3>
<p>years + month 降序</p>
<p>5马尔代夫 + 20云南</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name,</span><br><span class="line">	<span class="keyword">floor</span>(months_between(<span class="keyword">current_date</span>,hire_date)/<span class="number">12</span>) <span class="keyword">as</span> <span class="keyword">years</span>,</span><br><span class="line">	<span class="keyword">floor</span>(<span class="keyword">mod</span>(months_between(<span class="keyword">current_date</span>,hire_date),<span class="number">12</span>)) <span class="keyword">as</span> <span class="keyword">months</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">years</span> <span class="keyword">desc</span>,<span class="keyword">months</span> <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">first</span> <span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name,</span><br><span class="line">	<span class="keyword">floor</span>(months_between(<span class="keyword">current_date</span>,hire_date)/<span class="number">12</span>) <span class="keyword">as</span> <span class="keyword">years</span>,</span><br><span class="line">	<span class="keyword">floor</span>(<span class="keyword">mod</span>(months_between(<span class="keyword">current_date</span>,hire_date),<span class="number">12</span>)) <span class="keyword">as</span> <span class="keyword">months</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">years</span> <span class="keyword">desc</span>,<span class="keyword">months</span> <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">offset</span> <span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">fetch</span> <span class="keyword">first</span> <span class="number">20</span> <span class="keyword">rows</span> <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>
<h3 id="如果mgr为空，mgr显示boss-0">如果mgr为空，mgr显示boss/0</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col mgr for a20</span><br><span class="line"><span class="keyword">select</span> empno,ename,nvl(to_char(mgr),<span class="string">'boss'</span>) mgr <span class="keyword">from</span> scott.emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 位数不够也不会强制补0的</span></span><br><span class="line">col mgr for 999999</span><br><span class="line"><span class="keyword">select</span> empno,ename,nvl(mgr,<span class="number">0</span>) mgr <span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure>
<h3 id="显示特定年份入职的员工数量">显示特定年份入职的员工数量</h3>
<p>用to_char提取年份</p>
<p>decode、case返回一列值（0或1），求和即可计数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> total, </span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(to_char(hire_date, <span class="string">'YYYY'</span>),<span class="string">'2001'</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="string">"2001"</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(to_char(hire_date, <span class="string">'YYYY'</span>),<span class="string">'2002'</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="string">"2002"</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(to_char(hire_date, <span class="string">'YYYY'</span>),<span class="string">'2003'</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="string">"2003"</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(to_char(hire_date, <span class="string">'YYYY'</span>),<span class="string">'2008'</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="string">"2008"</span></span><br><span class="line"><span class="keyword">from</span> hr.employees;</span><br><span class="line"></span><br><span class="line">     TOTAL       2001       2002       2003       2008</span><br><span class="line"><span class="comment">---------- ---------- ---------- ---------- ----------</span></span><br><span class="line">       107          1          7          6         11</span><br><span class="line">       </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> total, </span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> to_char(hire_date, <span class="string">'YYYY'</span>) <span class="keyword">when</span> <span class="string">'2001'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">"2001"</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> to_char(hire_date, <span class="string">'YYYY'</span>) <span class="keyword">when</span> <span class="string">'2002'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">"2002"</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> to_char(hire_date, <span class="string">'YYYY'</span>) <span class="keyword">when</span> <span class="string">'2003'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">"2003"</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> to_char(hire_date, <span class="string">'YYYY'</span>) <span class="keyword">when</span> <span class="string">'2008'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">"2008"</span></span><br><span class="line"><span class="keyword">from</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> to_char(hire_date, <span class="string">'YYYY'</span>) <span class="keyword">when</span> <span class="string">'2001'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">from</span> hr.employees;</span><br></pre></td></tr></table></figure>
<h3 id="使用case-decode改变表模式">使用case/decode改变表模式</h3>
<p>（姓名，科目，成绩）改为（姓名，科目1成绩，科目2成绩…）</p>
<p>原表模式为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col name for a10</span><br><span class="line">col subject for a10</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hr.st;</span><br><span class="line"><span class="comment">-- number类型不能用col for a10</span></span><br><span class="line"></span><br><span class="line">NAME       SUBJECT         SCORE</span><br><span class="line"><span class="comment">---------- ---------- ----------</span></span><br><span class="line">zhangsan   chinese            90</span><br><span class="line">zhangsan   maths             100</span><br><span class="line">zhangsan   english            96</span><br><span class="line">lisi       chinese            94</span><br><span class="line">lisi       maths              98</span><br><span class="line">lisi       english            92</span><br><span class="line"></span><br><span class="line">6 rows selected.</span><br></pre></td></tr></table></figure>
<p>注意是单引号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, </span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'chinese'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) chinese,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'maths'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) maths,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'english'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) english</span><br><span class="line"><span class="keyword">from</span> hr.st</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, </span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">decode</span>(subject,<span class="string">'chinese'</span>,score,<span class="number">0</span>))<span class="string">"chinese"</span>,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">decode</span>(subject,<span class="string">'maths'</span>,score,<span class="number">0</span>))<span class="string">"maths"</span>,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">decode</span>(subject,<span class="string">'english'</span>,score,<span class="number">0</span>))<span class="string">"english"</span></span><br><span class="line"><span class="keyword">from</span> hr.st</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line">NAME          chinese      maths    english</span><br><span class="line"><span class="comment">---------- ---------- ---------- ----------</span></span><br><span class="line">zhangsan           90        100         96</span><br><span class="line">lisi               94         98         92</span><br></pre></td></tr></table></figure>
<h3 id="聚合显示">聚合显示</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按dept分类，姓名聚合显示，内部按照empno（也可以ename）排序</span></span><br><span class="line">col ename for a60</span><br><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">listagg</span>(ename,<span class="string">','</span>) <span class="keyword">within</span> <span class="keyword">group</span> (<span class="keyword">order</span> <span class="keyword">by</span> empno) <span class="keyword">as</span> ename</span><br><span class="line"><span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br><span class="line"></span><br><span class="line">    DEPTNO ENAME</span><br><span class="line"><span class="comment">---------- ------------------------------------------------------------</span></span><br><span class="line">        10 CLARK,KING,MILLER</span><br><span class="line">        20 SMITH,JONES,SCOTT,ADAMS,FORD</span><br><span class="line">        30 ALLEN,WARD,MARTIN,BLAKE,TURNER,JAMES</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按job分类，姓名聚合显示</span></span><br><span class="line">col ename for a60</span><br><span class="line"><span class="keyword">select</span> job, <span class="keyword">listagg</span>(ename,<span class="string">','</span>) <span class="keyword">within</span> <span class="keyword">group</span> (<span class="keyword">order</span> <span class="keyword">by</span> sal) <span class="keyword">as</span> ename</span><br><span class="line"><span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job; <span class="comment">-- gruop by加上之后，select只能用job和聚合函数了！！！！</span></span><br><span class="line"></span><br><span class="line">JOB                ENAME</span><br><span class="line"><span class="comment">------------------ ------------------------------------------------------------</span></span><br><span class="line">ANALYST            FORD,SCOTT</span><br><span class="line">CLERK              SMITH,JAMES,ADAMS,MILLER</span><br><span class="line">MANAGER            CLARK,BLAKE,JONES</span><br><span class="line">PRESIDENT          KING</span><br><span class="line">SALESMAN           MARTIN,WARD,TURNER,ALLEN</span><br></pre></td></tr></table></figure>
<h3 id="比本部门平均工资高的人">比本部门平均工资高的人</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col last_name for a20</span><br><span class="line"><span class="keyword">select</span> a.last_name,a.department_id,a.salary,b.average_salary</span><br><span class="line"><span class="keyword">from</span> hr.employees a,</span><br><span class="line">(<span class="keyword">select</span> department_id,<span class="keyword">avg</span>(salary) average_salary <span class="keyword">from</span> hr.employees <span class="keyword">group</span> <span class="keyword">by</span> department_id) b</span><br><span class="line"><span class="keyword">where</span> a.department_id = b.department_id</span><br><span class="line"><span class="keyword">and</span> a.salary &gt; b.average_salary;</span><br></pre></td></tr></table></figure>
<h3 id="输出所有人及对应的领导（注意null）">输出所有人及对应的领导（注意null）</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.first_name || <span class="string">' '</span> || e.last_name <span class="keyword">as</span> 职工全名</span><br><span class="line">,m.first_name || <span class="string">' '</span> || m.last_name <span class="keyword">as</span> 经理全名</span><br><span class="line"><span class="keyword">from</span> hr.employees e, hr.employees m</span><br><span class="line"><span class="keyword">where</span> e.manager_id = m.employee_id(+);</span><br></pre></td></tr></table></figure>
<p>==坑：有一个人没有领导==，他就是最大领导</p>
<h3 id="选普通群众（不是领导）">选普通群众（不是领导）</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- last_name </span></span><br><span class="line"><span class="comment">-- 嵌套</span></span><br><span class="line"><span class="keyword">select</span> last_name</span><br><span class="line"><span class="keyword">from</span> hr.employees</span><br><span class="line"><span class="keyword">where</span> employee_id <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> nvl(manager_id,<span class="number">0</span>) <span class="keyword">from</span> hr.employees);</span><br><span class="line"><span class="comment">-- 子查询将所有的领导id选出来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关联</span></span><br><span class="line"><span class="keyword">select</span> e.last_name</span><br><span class="line"><span class="keyword">from</span> hr.employees e</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> hr.employees i</span><br><span class="line"><span class="keyword">where</span> e.employee_id = i.manager_id);</span><br><span class="line"><span class="comment">-- 对外部表每一个employee_id，传入内部表，看他是不是其他人的领导</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 基操</title>
    <url>/2020/02/25/Oracle/Oracle%E5%9F%BA%E6%93%8D/</url>
    <content><![CDATA[<h2 id="1-sqlplus常用命令">1. sqlplus常用命令</h2>
<p>sql语句关键字 != sqlplus命令</p>
<p>不产生歧义的时候可以缩写</p>
<p>如何学习sqlplus命令：登陆SQL plus后，help index</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help index</span><br><span class="line"></span><br><span class="line">Enter Help [topic] for help.</span><br><span class="line"></span><br><span class="line"> @             COPY         PAUSE                    SHUTDOWN</span><br><span class="line"> @@            DEFINE       PRINT                    SPOOL</span><br><span class="line"> &#x2F;             DEL          PROMPT                   SQLPLUS</span><br><span class="line"> ACCEPT        DESCRIBE     QUIT                     START</span><br><span class="line"> APPEND        DISCONNECT   RECOVER                  STARTUP</span><br><span class="line"> ARCHIVE LOG   EDIT         REMARK                   STORE</span><br><span class="line"> ATTRIBUTE     EXECUTE      REPFOOTER                TIMING</span><br><span class="line"> BREAK         EXIT         REPHEADER                TTITLE</span><br><span class="line"> BTITLE        GET          RESERVED WORDS (SQL)     UNDEFINE</span><br><span class="line"> CHANGE        HELP         RESERVED WORDS (PL&#x2F;SQL)  VARIABLE</span><br><span class="line"> CLEAR         HOST         RUN                      WHENEVER OSERROR</span><br><span class="line"> COLUMN        INPUT        SAVE                     WHENEVER SQLERROR</span><br><span class="line"> COMPUTE       LIST         SET                      XQUERY</span><br><span class="line"> CONNECT       PASSWORD     SHOW</span><br><span class="line"></span><br><span class="line">help @</span><br></pre></td></tr></table></figure>
<p>@ 调用脚本，把文件中的语句执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@&#x2F;u01&#x2F;demo&#x2F;sql1</span><br></pre></td></tr></table></figure>
<p>list 列出当前缓存中的最后一条语句</p>
<p>edit 只能编辑最后一条语句？？？</p>
<p>run 运行edit中的语句</p>
<h3 id="sqlplus-startup-shutdown">sqlplus startup shutdown</h3>
<p>linux用oracle用户登录，不能用root</p>
<p>~ 相当于Oracle home？？？（使用pwd查看所在文件当前路径）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux中环境变量以$开头，$HOME，$ORACLE_HOME</span></span><br><span class="line"><span class="comment"># 使用echo查看，使用export设置</span></span><br><span class="line"><span class="comment"># export ORACLE_HOME=/u01/app/oracle/product/12.2.0/dbhome_1 # 等号两边不能有空格</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ORACLE_HOME</span> <span class="comment"># /u01/app/oracle/product/12.2.0/dbhome_1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span> <span class="comment"># /home/oracle</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linux不支持@echo，没有pause</span></span><br></pre></td></tr></table></figure>
<!--more-->
<p>在~下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsnrctl status</span><br><span class="line">lsnrctl start</span><br><span class="line">sqlplus &#x2F; as sysdba</span><br><span class="line"># 或者</span><br><span class="line">sqlplus hr&#x2F;123123</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">sqlplus &#x2F;nolog</span><br><span class="line">conn</span><br></pre></td></tr></table></figure>
<p>用Oracle用户登录后，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startup</span><br></pre></td></tr></table></figure>
<h3 id="connect切换用户">connect切换用户</h3>
<p>已登录时，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conn 用户名&#x2F;密码@网络服务器名 [as sysdba&#x2F;sysoper] </span><br><span class="line">conn &#x2F; as sysdba</span><br></pre></td></tr></table></figure>
<h3 id="exit退出登录">exit退出登录</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>该命令会断开与数据库的连接，同时会退出sqlplus</p>
<h3 id="password更改用户密码">password更改用户密码</h3>
<p>需要登录一个能修改密码的用户</p>
<p>在sys登录的时候，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">password scott 可以修改其他用户的密码</span><br><span class="line">password 修改sys的密码</span><br></pre></td></tr></table></figure>
<h3 id="set-show">set &amp; show</h3>
<h4 id="会话级别设置">会话级别设置</h4>
<p>show all，显示所有个性化定制</p>
<p>在这里set show，只是会话级别的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- prompt</span></span><br><span class="line"><span class="keyword">show</span> sqlprompt <span class="comment">-- sqlprompt "_user"@"_connect_identifier&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在prompt之前显示时间</span></span><br><span class="line"><span class="keyword">show</span> <span class="built_in">time</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">time</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前登录的数据库用户</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义变量所用的标志</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">define</span> <span class="comment">-- 默认为&amp;，可以修改</span></span><br><span class="line"><span class="keyword">set</span> difine !</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自动commit</span></span><br><span class="line"><span class="keyword">show</span> autoc</span><br><span class="line"><span class="keyword">set</span> autoc <span class="keyword">on</span> <span class="comment">-- 不建议，会导致性能差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询反馈信息</span></span><br><span class="line"><span class="keyword">show</span> feed</span><br><span class="line"><span class="keyword">set</span> feed <span class="number">5</span> <span class="comment">-- 5 rows selected也会显示，4行就不显示了</span></span><br><span class="line"><span class="keyword">set</span> feed <span class="keyword">off</span> <span class="comment">-- 也可以不开启尾部的反馈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表头</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">head</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">head</span> <span class="keyword">off</span> <span class="comment">-- 不输出表头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- verify，提交变量那里，显示old和new</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">verify</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">verify</span> <span class="keyword">off</span></span><br></pre></td></tr></table></figure>
<h4 id="全局设置显示格式">全局设置显示格式</h4>
<p>登陆时在会话里修改，则只为会话级别的，重新登陆会失效</p>
<p>不登陆Oracle时</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$ORACLE_HOME</span>/sqlplus/admin/glogin.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> linesize <span class="number">100</span></span><br><span class="line"><span class="keyword">set</span> pagesize <span class="number">50</span></span><br><span class="line"><span class="keyword">set</span> sqlprompt _user<span class="string">"@"</span>_connect_identifier&gt;</span><br><span class="line"><span class="keyword">define</span> _EDITOR=<span class="string">"vim"</span></span><br></pre></td></tr></table></figure>
<p>登录Oracle后可以用这两个命令查看参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show linesize</span><br><span class="line">show pagesize</span><br></pre></td></tr></table></figure>
<h3 id="column设置列">column设置列</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置列宽</span></span><br><span class="line">col [列名] for a20</span><br><span class="line">20指字符数量</span><br><span class="line"></span><br><span class="line">col [列名] format 9999999</span><br><span class="line">9代表一个数字</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不打印某一列</span></span><br><span class="line">col [列名] noprint</span><br><span class="line">col [列名] print</span><br></pre></td></tr></table></figure>
<h3 id="执行sql脚本">@执行sql脚本</h3>
<p>执行位于共享目录的sql脚本</p>
<p>用@执行脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@&#x2F;mnt&#x2F;hgfs&#x2F;D&#x2F;software&#x2F;os&#x2F;scott.sql</span><br><span class="line">用于安装scott方案</span><br></pre></td></tr></table></figure>
<h3 id="desc">desc</h3>
<p>查询时记得加上表的所有者</p>
<h2 id="2-moba常用操作">2. moba常用操作</h2>
<p>CTRL + L 清屏</p>
<h2 id="3-Oracle常用操作">3. Oracle常用操作</h2>
<h3 id="查数据字典">查数据字典</h3>
<h4 id="dict-columns">dict_columns</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> COLUMN_NAME,COMMENTS <span class="keyword">from</span> dict_columns <span class="keyword">where</span> TABLE_NAME=<span class="string">'DICT'</span>; </span><br><span class="line"><span class="keyword">select</span> COLUMN_NAME,COMMENTS <span class="keyword">from</span> dict_columns <span class="keyword">where</span> table_name=<span class="string">'DBA_TABLESPACES'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询某个表中字段是啥意思</span></span><br><span class="line"><span class="comment">-- 我们可以在catalog.sql脚本中找到DICT_COLUMNS视图的创建语句</span></span><br></pre></td></tr></table></figure>
<p>user_tab_columns？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dict_columns <span class="keyword">where</span> COLUMN_NAME=<span class="string">'TABLE_NAME'</span> <span class="keyword">and</span> <span class="keyword">rownum</span>&lt;<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询都有哪些表包含指定的字段</span></span><br><span class="line"><span class="comment">-- 不加限制，可能条目太多</span></span><br></pre></td></tr></table></figure>
<h4 id="dict">dict</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name,comments <span class="keyword">from</span> dict <span class="keyword">where</span> table_name=<span class="keyword">upper</span>(<span class="string">'dba_users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表的作用</span></span><br></pre></td></tr></table></figure>
<h4 id="users">_users</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username, account_status <span class="keyword">from</span> dba_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- expired - 过期，需要修改密码</span></span><br><span class="line"><span class="comment">-- locked - 需要解锁</span></span><br><span class="line"><span class="comment">-- open - 正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> hr <span class="keyword">account</span> <span class="keyword">unlock</span>;</span><br></pre></td></tr></table></figure>
<h4 id="views">_views</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> owner,view_name <span class="keyword">from</span> dba_views <span class="keyword">where</span> view_name=<span class="keyword">upper</span>(<span class="string">'dba_tablespaces'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看是不是视图 </span></span><br><span class="line"><span class="comment">-- 动态性能视图查不到？？？</span></span><br></pre></td></tr></table></figure>
<h4 id="tables">_tables</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- table_name, tablespace_name</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="keyword">upper</span>(<span class="string">'emp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查某一个表所在的表空间</span></span><br><span class="line"></span><br><span class="line">desc user_indexes <span class="comment">-- 查看有哪些索引</span></span><br><span class="line"><span class="keyword">select</span> index_name <span class="keyword">from</span> user_indexes;</span><br><span class="line">desc user_triggers <span class="comment">-- 触发器</span></span><br><span class="line">desc user_jobs <span class="comment">-- </span></span><br><span class="line">desc user_users <span class="comment">-- 用户</span></span><br></pre></td></tr></table></figure>
<p>查数据文件相关信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc v$datafile <span class="comment">-- 要在sys下</span></span><br><span class="line">desc dba_data_files</span><br></pre></td></tr></table></figure>
<p>查某一个表空间所在的数据文件</p>
<p>dba_data_files，没有all和user</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tablespace_name,file_id,<span class="keyword">bytes</span>/<span class="number">1024</span>/<span class="number">1024</span>,file_name <span class="keyword">from</span> dba_data_files <span class="keyword">order</span> <span class="keyword">by</span> file_id;</span><br></pre></td></tr></table></figure>
<h3 id="sqldeveloper">sqldeveloper</h3>
<p>在/下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=192.168.11.1:0.0</span><br><span class="line"><span class="comment"># echo $DISPLAY</span></span><br><span class="line">sqldeveloper.sh</span><br></pre></td></tr></table></figure>
<h3 id="查看Oracle错误信息">查看Oracle错误信息</h3>
<p>退出Oracle，在/下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oerr ora [错误代码]</span><br></pre></td></tr></table></figure>
<h3 id="查看警告日志文件">查看警告日志文件</h3>
<p>记录死锁、Oracle内部错误等等重大事件</p>
<p>知道是哪一个参数不对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;rdbms&#x2F;db12c&#x2F;trace&#x2F;alert_db12c.log</span><br></pre></td></tr></table></figure>
<p>这个文件可以删，记录日志时会自动产生</p>
<h3 id="adrci">adrci</h3>
<p>到另一个tab的os下，使用adrci命令查看警告日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adrci</span><br><span class="line">adrci&gt; help</span><br><span class="line">adrci&gt; show homes</span><br><span class="line">ADR Homes:</span><br><span class="line">diag/rdbms/db12c/db12c</span><br><span class="line">diag/rdbms/dummy/sales</span><br><span class="line">diag/rdbms/sales/sales</span><br><span class="line">diag/rdbms/oradup/oradup</span><br><span class="line">diag/rdbms/kwra_pitr_sales/kwra</span><br><span class="line">diag/rdbms/eyhf_pitr_sales/EyhF</span><br><span class="line">diag/rdbms/cdb/cdb</span><br><span class="line">diag/clients/user_oracle/host_901187968_107</span><br><span class="line">diag/tnslsnr/ocp/listener</span><br><span class="line"></span><br><span class="line">adrci&gt; set home diag/rdbms/db12c/db12c</span><br><span class="line">adrci&gt; show home</span><br><span class="line">ADR Homes:</span><br><span class="line">diag/rdbms/db12c/db12c</span><br><span class="line"></span><br><span class="line">adrci&gt; show alert -tail 30</span><br><span class="line"><span class="comment">-- 从后往前看，30行</span></span><br><span class="line">Errors in file /u01/app/oracle/diag/rdbms/db12c/db12c/trace/db12c_lgwr_28757.trc:</span><br><span class="line">ORA-00313: ??????? 1 (???? 1) ???</span><br><span class="line">ORA-00312: ???? 1 ?? 1: '/u01/app/oracle/oradata/db12c/redo01.log'</span><br><span class="line">ORA-27037: ????????</span><br><span class="line">Linux-x86_64 Error: 2: No such file or directory</span><br><span class="line"><span class="comment">-- 发现是redo01.log这个文件坏了</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">member</span> <span class="keyword">from</span> v$<span class="keyword">logfile</span>;</span><br></pre></td></tr></table></figure>
<h3 id="linux环境变量">linux环境变量</h3>
<p>环境变量一般是指操作系统中指定操作系统运行环境的一些参数。它相当于一个指针，想要查看变量的值，需要加上“$”</p>
<p>按作用的范围分。在Linux中的变量，可以分为环境变量和本地变量：</p>
<p>1）环境变量：相当于全局变量，存在于所有的Shell中，具有继承性；<br>
2）本地变量：相当于局部变量只存在当前Shell中，本地变量包含环境变量，非环境变量不具有继承性。</p>
<p>按生存周期分</p>
<p>1）永久：需要修改配置文件，变量永久生效；<br>
2）暂时：使用export定义，关闭Shell后失效。</p>
<p>在~下的.bash_profile中？？？</p>
<ul>
<li><code>export </code>命令显示当前系统定义的所有环境变量</li>
<li><code>echo $PATH</code> 命令输出当前的<code>PATH</code>环境变量的值</li>
</ul>
<p>DISPLAY</p>
<p>HOME  用户的主目录（也称家目录，和~相同） HOME 变量在不同用户身份下值不相同</p>
<p>HOSTNAME 主机名</p>
<p>LOGNAME 用户的登录名</p>
<p>ORACLE_BASE  oracle的根目录</p>
<p>ORACLE_HOME   oracle产品的目录，如果安装了两个版本的Oracle，会有两个</p>
<p>方便用户更轻松地进入一个层次较深的目录</p>
<p>ORACLE_SID 用于区别同一台机器上的不同实例</p>
<p>ORACLE_UNQNAME？？？</p>
<p>USER</p>
<p>HISTSIZE 该变量指定保存历史命令的数目（最多1000）</p>
<p>PATH  变量定义了==运行命令的查找路径==，以冒号<code>:</code>分割不同的路径</p>
<p>SHELL 该变量指定用户当前使用的解析器</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 手动创建数据库sales</title>
    <url>/2020/03/23/Oracle/Oracle%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93sales/</url>
    <content><![CDATA[<p>为了防止后面对各种文件的操作，对db12c造成不可逆转的损害，重新建一个sales库来操作</p>
<a id="more"></a>
<h3 id="1-创建-编辑初始化参数文件pfile">1.创建/编辑初始化参数文件pfile</h3>
<p>在db12c下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> pfile <span class="keyword">from</span> <span class="keyword">spfile</span>;</span><br></pre></td></tr></table></figure>
<p>到$ORACLE_HOME/dbs下，把db12c的pfile复制一份给sales</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp initdb12c.ora initsales.ora</span><br><span class="line">vim initsales.ora</span><br></pre></td></tr></table></figure>
<p>内容修改，查找全部替换db12c-&gt;sales（按esc，再输命令）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:1,$ s&#x2F;db12c&#x2F;sales&#x2F;g</span><br></pre></td></tr></table></figure>
<p>创建初始化参数文件（initsales.ora）中出现的相应的目录结构：新建对应的文件夹</p>
<p>去掉不需要的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.local_listener&#x3D;&#39;LISTNER_DB12C&#39;</span><br></pre></td></tr></table></figure>
<p>注意*.undo_tablespace=‘UNDOTBS1’</p>
<h3 id="2-创建pfile中相应的目录结构">2.创建pfile中相应的目录结构</h3>
<p>mkdir -p 三个含有sales的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales</span><br><span class="line">mkdir -p &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;recovery_area&#x2F;sales</span><br><span class="line">mkdir -p &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;admin&#x2F;sales&#x2F;adump</span><br></pre></td></tr></table></figure>
<p>os下修改ORACLE_SID为sales</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">echo $ORACLE_SID</span><br><span class="line">db12c</span><br><span class="line">export ORACLE_SID=sales</span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<h3 id="3-启动例程">3.启动例程</h3>
<p>（仅有初始化参数文件，只能到nomount）</p>
<p>startup nomount</p>
<h3 id="4-执行创建数据库的语句">4.执行创建数据库的语句</h3>
<p>创建数据库：</p>
<ul>
<li>system、sysaux和undotbs1是必须建的表空间</li>
<li>可选默认的临时表空间，注意数据文件datafile和临时文件tempfile不同！！！</li>
<li>日志组</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> sales</span><br><span class="line"><span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/system01.dbf'</span> <span class="keyword">size</span> <span class="number">400</span>m</span><br><span class="line"><span class="keyword">sysaux</span> <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/sysaux01.dbf'</span> <span class="keyword">size</span> <span class="number">400</span>m</span><br><span class="line"><span class="keyword">undo</span> <span class="keyword">tablespace</span> undotbs1 <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/undotbs01.dbf'</span> <span class="keyword">size</span> <span class="number">50</span>m</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">temporary</span> <span class="keyword">tablespace</span> temp tempfile <span class="string">'/u01/app/oracle/oradata/sales/temp01.dbf'</span> <span class="keyword">size</span> <span class="number">20</span>m</span><br><span class="line"><span class="keyword">logfile</span></span><br><span class="line"><span class="keyword">group</span> <span class="number">1</span> (<span class="string">'/u01/app/oracle/oradata/sales/redo01.log'</span>) <span class="keyword">size</span> <span class="number">10</span>m,</span><br><span class="line"><span class="keyword">group</span> <span class="number">2</span> (<span class="string">'/u01/app/oracle/oradata/sales/redo02.log'</span>) <span class="keyword">size</span> <span class="number">10</span>m,</span><br><span class="line"><span class="keyword">group</span> <span class="number">3</span> (<span class="string">'/u01/app/oracle/oradata/sales/redo03.log'</span>) <span class="keyword">size</span> <span class="number">10</span>m;</span><br></pre></td></tr></table></figure>
<p>建好库了，此时只是有Oracle的内部表</p>
<p>还没有数据字典，同样适用于数据字典损坏时的修复？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc dba_tables</span><br><span class="line"><span class="comment">-- 对象不存在</span></span><br></pre></td></tr></table></figure>
<h3 id="5-调用脚本创建数据字典视图（catalog-sql）">5.调用脚本创建数据字典视图（catalog.sql）</h3>
<p>在sales数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlplus / as sysdba</span><br><span class="line"><span class="comment">-- $ORACLE_HOME/rdbms/admin/</span></span><br><span class="line"><span class="comment">-- 很多脚本在这里，包括上次生成异常表的脚本</span></span><br><span class="line"><span class="comment">-- ?代表oracle_home</span></span><br><span class="line"><span class="comment">-- Oracle下</span></span><br><span class="line">@?/rdbms/admin/catalog <span class="comment">-- 不需要加sql后缀</span></span><br></pre></td></tr></table></figure>
<p>该脚本还会调用子脚本</p>
<p>执行完之后，数据字典就已经可以用了</p>
<p>只是把数据字典的定义建立好？？？</p>
<h3 id="6-创建口令文件">6.创建口令文件</h3>
<p>home下dbs下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- $ORACLE_HOME/dbs</span></span><br><span class="line"><span class="comment">-- 原来dbs下有一个orapwdb12c口令文件，现在要创建一份sales数据库的口令文件</span></span><br><span class="line"><span class="comment">-- 一定在dbs下执行</span></span><br><span class="line">orapwd file=orapwsales password=admin1<span class="comment">#3</span></span><br></pre></td></tr></table></figure>
<h3 id="7-调用脚本创建Oracle内部包">7.调用脚本创建Oracle内部包</h3>
<p>内部包现在还调用不起来（dbms_rowid、dbms_system）</p>
<p>要和口令文件在一个会话下创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 登录sys时</span></span><br><span class="line">@?/rdbms/admin/catproc</span><br><span class="line"></span><br><span class="line">desc dbms_rowid</span><br><span class="line">desc dbms_system</span><br></pre></td></tr></table></figure>
<p>这个脚本执行时间10min左右，中间有一些红字ora报错没关系</p>
<p>如果出（enter value for execfile）错误，说明没有通过口令文件还没生效需要验证？？？</p>
<p>用sys/admin1#3重新连接后，重新跑一遍脚本即可。</p>
<h3 id="8-创建spfile">8.创建spfile</h3>
<p>当前还是使用pfile启动，sysdba登录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">echo $ORACLE_SID</span><br><span class="line">export ORACLE_SID=sales</span><br><span class="line">sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> parameter <span class="keyword">spfile</span>  <span class="comment">--无spfile</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">spfile</span> <span class="keyword">from</span> pfile;<span class="comment">-- 在$ORACLE_HOME/dbs下多了一个spfilesales.ora</span></span><br><span class="line"><span class="comment">-- 重启数据库，就会使用spfile启动</span></span><br></pre></td></tr></table></figure>
<h3 id="9-创建scott方案、对象：">9.创建scott方案、对象：</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">@/mnt/hgfs/D/software/oracle/scott.sql</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">identified</span> <span class="keyword">by</span> <span class="number">123123</span>; <span class="comment">-- 改密码</span></span><br><span class="line">conn scott/123123 <span class="comment">-- 测试</span></span><br><span class="line"><span class="comment">-- 最好等内部包安装完，否则会报error accessing package xxx</span></span><br><span class="line"><span class="comment">-- 但是肯定还有一个错误（缺少产品概要信息）：error accessing PRODUCT_USER_PROILE</span></span><br></pre></td></tr></table></figure>
<h3 id="10-调用脚本加载产品用户概要文件">10.调用脚本加载产品用户概要文件</h3>
<p>相当于<strong>用户的配置文件</strong>，Oracle用户登录时需要这个初始化配置文件</p>
<p>【Windows不同用户登录后，桌面、快捷方式不一样】</p>
<p>【linux每个用户都有一个bash_profile，配置、环境变量都在这里】</p>
<p>用system用户跑一个脚本（system和sys不同）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn system/manager  <span class="comment">--默认密码是manager</span></span><br><span class="line">@?/sqlplus/admin/pupbld</span><br></pre></td></tr></table></figure>
<h3 id="11-配置监听器和服务名">11.配置监听器和服务名</h3>
<ul>
<li>监听器（服务器端）</li>
<li>服务名（客户端）</li>
</ul>
<p>想要远程登录数据库，需要配置<strong>监听器</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在$ORACLE_HOME/network/admin</span></span><br><span class="line"><span class="comment">-- 第一种方法，listener.ora中修改文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种方法，用图形化界面</span></span><br><span class="line">export DISPLAY=192.168.11.1:0.0</span><br><span class="line">netmgr <span class="comment">-- 记得文件-保存网络配置</span></span><br><span class="line"><span class="comment">-- 再看文件发现已经多了</span></span><br></pre></td></tr></table></figure>
<p>重启监听器不影响已经打开的数据库【欢迎光临小姐&amp;银行内办公人员】</p>
<p>重启监听：lsnrctl stop，再lsnrctl start</p>
<p>重启之后，两个状态都是unknown（静态注册）</p>
<p>配置<strong>服务名</strong>，在同目录的tnsnames.ora</p>
<p>也可以用图形化界面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">net manager <span class="comment">-- 记得文件-保存网络配置</span></span><br><span class="line"><span class="comment">-- 如果测试不成功，可能是密码不对的原因</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conn 用户名&#x2F;口令@服务名</span><br></pre></td></tr></table></figure>
<p>idle instance，没有startup的时候，从别的服务切换不过来的</p>
<h3 id="12-配置EM-Express">12.配置EM Express</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn sys/admin as sysdba;</span><br><span class="line"><span class="keyword">select</span> dbms_xdb.gethttpport <span class="keyword">from</span> dual; <span class="comment">-- 发现是0，说明还没有配端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">execute</span> dbms_xdb.sethttpport(<span class="number">7531</span>);</span><br><span class="line"><span class="keyword">select</span> dbms_xdb.gethttpport <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line">http://192.168.11.200:7531/em <span class="comment">-- 使用这个登录</span></span><br><span class="line"><span class="comment">-- system用户名 manager密码</span></span><br><span class="line"><span class="comment">-- sys用户名 admin1#3密码</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 安全3A</title>
    <url>/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/</url>
    <content><![CDATA[<ol>
<li>验证【第一步得现有身份证】</li>
<li>授权【有身份证还得有登机牌才能上飞机】</li>
<li>审核【飞机掉下去找黑匣子，找问题的原因】</li>
</ol>
<a id="more"></a>
<h2 id="概念澄清">概念澄清</h2>
<ul>
<li>用户拥有权限</li>
<li>用户拥有0个或多个角色（拥有这些角色对应的权限）</li>
<li>用户和角色（user、role）都是Oracle里的物理对象</li>
</ul>
<h3 id="用户">用户</h3>
<p>对数据库的访问需要以适当的身份通过验证，这就是用户的作用。</p>
<p>每个Oracle用户都有自己的用户名和密码，并且拥有资源：他们所创建的任意表、视图和其他资源。</p>
<p>需要注意的是新创建的用户连最基本的访问登入Oracle的权限都没有，所以后续需要授予不同的权限和角色来达成不同的操作目的。</p>
<p>用户分为<strong>普通用户和特权用户</strong>。</p>
<h4 id="特权用户-超级用户">特权用户/超级用户</h4>
<p>特权用户是指拥有特殊权限（sysdba、sysoper、sysdg等）的数据库用户，可以说是超级用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v$pwfile_users; <span class="comment">-- 查看数据库的特权用户，以及他们拥有的特权</span></span><br><span class="line"><span class="comment">-- V$PWFILE_USERS lists all users in the password file, and indicates whether the user has been granted the SYSDBA, SYSOPER, SYSASM,SYSBACKUP, SYSDG, and SYSKM privileges.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username,<span class="keyword">sysdba</span>,<span class="keyword">sysoper</span>,<span class="keyword">sysasm</span>,sysbackup,sysdg,syskm <span class="keyword">from</span> v$pwfile_users;</span><br><span class="line"><span class="comment">-- 在普通用户下也能看这个视图</span></span><br></pre></td></tr></table></figure>
<p>特权用户也可以不用特权身份登录（sys除外）</p>
<p>一旦以特权用户身份登录时，必须带有as sysdba、as sysoper、as sysdg等选项，但登录后“用户改变”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system如果正常登录，它其实就是一个普通的dba用户。</span><br><span class="line">但是如果以as sysdba登录，其结果实际上它是作为sys用户登录的，这一点类似Linux里面的sudo的感觉，从登录信息里面我们可以看出来。（show user）</span><br><span class="line">因此在as sysdba连接数据库后，创建的对象实际上都是生成在sys中的。</span><br><span class="line">system、sys以外的其他用户也是一样，如果 as sysdba登录，也是作为sys用户登录的。</span><br></pre></td></tr></table></figure>
<p>如果参数REMOTE_LOGIN_PASSWORDFILE的值为EXCLUSIVE，那么就可以将sysdba和sysoper权限授予其它用户。？？？</p>
<h4 id="sys和system用户的区别">sys和system用户的区别</h4>
<p>sys &gt; system</p>
<p>1 )   最重要的区别，存储的数据的重要性不同</p>
<ul>
<li>
<p>【sys】所有oracle的数据字典的基表和视图都存放在sys用户中，这些基表和视图对于oracle的运行是至关重要的，由数据库自己维护，任何用户都不能手动更改。</p>
<p>sys用户拥有dba，sysdba，sysoper等角色或权限，是oracle权限最高的用户。</p>
</li>
<li>
<p>【system】 用户用于存放次一级的内部数据，如oracle的一些特性或工具的管理信息。system用户拥有普通dba角色权限。</p>
</li>
</ul>
<ol start="2">
<li>其次的区别，权限不同</li>
</ol>
<ul>
<li>
<p>【system】用户只能用normal身份登陆em，除非你对它授予了sysdba的系统权限或者syspoer系统权限。</p>
</li>
<li>
<p>【sys】用户具有“SYSDBA”或者“SYSOPER”系统权限，登陆em也只能用这两个身份，不能用normal。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">28009, 00000, <span class="string">"connection as SYS should be as SYSDBA or SYSOPER"</span></span><br><span class="line">// *Cause:    connect SYS/&lt;password&gt; is no longer a valid syntax</span><br><span class="line">// *Action:   Try connect SYS/&lt;password&gt; as SYSDBA or</span><br><span class="line">//            connect SYS/&lt;password&gt; as SYSOPER</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="权限（特权privilege）">权限（特权privilege）</h3>
<p>权限管理是 Oracle 系统的精华，不同用户登录到同一数据库中，可能看到不同数量的表，拥有不同的权限。</p>
<p>ORACLE系统提供三种权限：Object 对象级、System 系统级、Role 角色级。</p>
<p>这些权限可以授予给用户、特殊用户public、角色。</p>
<p>如果授予一个权限给特殊用户”Public”（用户public是oracle预定义的，每个用户享有这个用户享有的权限），那么就意味作将该权限授予了该数据库的所有用户。</p>
<p>权限一般分为<strong>系统权限和对象权限（和角色权限？）</strong>。</p>
<ul>
<li>系统权限：全局性，着重用户（先找到用户）【select any table】</li>
<li>对象权限：局部性，着重资源（先找到资源，涉及到了某一个对象）【select on scott.emp】</li>
</ul>
<p>操作系统中，很类似，只是换了说法：</p>
<ul>
<li>权力：全局性，【backup】</li>
<li>权限：局部性【对某个目录可读可写，对其他不行】</li>
</ul>
<p>考试：哪些是系统权限，哪些是对象权限</p>
<img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200331140518784.png" alt="image-20200331140518784" style="zoom:80%;">
<h4 id="系统权限">系统权限</h4>
<p>可以通俗地理解为将数据库对象从无到有或从有到无的创建操作</p>
<p>比如说创建和删除表、视图、索引、存储过程、session等这些操作都可以认为是系统权限；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">常用的系统权限:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">session</span> 创建会话</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> 创建序列</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">synonym</span> 创建同名对象</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 在用户模式中创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">any</span> <span class="keyword">table</span> 在任何模式中创建表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 在用户模式中删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">any</span> <span class="keyword">table</span> 在任何模式中删除表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 创建存储过程</span><br><span class="line"><span class="keyword">execute</span> <span class="keyword">any</span> <span class="keyword">procedure</span> 执行任何模式的存储过程</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> 创建用户</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> 删除用户</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 创建视图</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有系统权限</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> system_privilege_map;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> system_privilege_map <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%SYS%'</span>;</span><br><span class="line"> PRIVILEGE NAME</span><br><span class="line"><span class="comment">---------- --------------------------------------------------------------------------------</span></span><br><span class="line">  PROPERTY</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">        -3 <span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span></span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="number">-4</span> <span class="keyword">AUDIT</span> <span class="keyword">SYSTEM</span></span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">       <span class="number">-83</span> <span class="keyword">SYSDBA</span></span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">       <span class="number">-84</span> <span class="keyword">SYSOPER</span></span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="number">-340</span> SYSBACKUP</span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="number">-341</span> SYSDG</span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="number">-342</span> SYSKM</span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="number">-345</span> <span class="keyword">KEEP</span> SYSGUID</span><br><span class="line">         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="number">-398</span> SYSRAC</span><br><span class="line">         <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h5 id="SYSDBA等特殊系统权限">SYSDBA等特殊系统权限</h5>
<p>概念上的role，不是role角色,只是一种登录认证时的身份标识而已</p>
<p>sysdba和sysoper属于system privilege，也称为administrative privilege，拥有例如数据库开启关闭之类一些系统管理级别的权限</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用conn as + 这些特殊权限，都可以通过验证，登录成功</span></span><br><span class="line">CONN[ECT] [&#123;logon|/|proxy&#125; [AS &#123;SYSDBA|SYSOPER|SYSASM|SYSBACKUP|SYSDG|SYSKM|SYSRAC&#125;]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>sysdba：可以访问整个Oracle服务器，包括instance和database，系统默认登陆用户是 SYS。</p>
<p>sysdba身份登陆<strong>可以打开，关闭数据库</strong>，创建SPFILE，对数据库进行恢复操作等，而这些是DBA角色无法实现的；</p>
</li>
<li>
<p>sysoper：系统操作员，只能管理instance，系统默认登陆用户是 PUBLIC。</p>
<p>可以startup、shutdown，但是不能看v$instance，不能访问数据文件？？？（不能查表）</p>
</li>
<li>
<p>sysasm：只能进行自动存储管理操作</p>
</li>
<li>
<p>sysback：只能进行备份操作</p>
</li>
<li>
<p>sysdg（data guard）：可以进行双机热备操作？？？，数据库有多份</p>
<p>多节点对于地震等天灾没啥用【汶川地震，但在北京做一个双机热备，要保证数据库的同步，所以要传日志，应用一下就行了】</p>
<p>讲归档模式的时候，可以归到本地，也可以用service放到远端</p>
<p>也可以打开关闭数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> log_archive_dest_1=<span class="string">'[service]=/u01/arch/1'</span>;<span class="comment">-- 远程，service填写一个服务名</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>syskm：给数据库做加密工作</p>
</li>
</ul>
<h5 id="SYS、SYSDBA和DBA的区别">SYS、SYSDBA和DBA的区别</h5>
<ul>
<li>sys是用户，拥有sysdba权限</li>
<li>sysdba是权限，不是role</li>
<li>dba是角色（角色、用户都是Oracle的一种对象）</li>
</ul>
<p>只有在数据库完全启动后，dba角色才有了存在的基础.</p>
<h5 id="normal、SYSDBA、SYSOPER的区别">normal、SYSDBA、SYSOPER的区别</h5>
<ul>
<li>normal 是普通用户</li>
<li>sysdba拥有最高的系统权限，登陆后是 sys</li>
<li>sysoper主要用来启动、关闭数据库，sysoper 登陆后用户是 public</li>
</ul>
<h4 id="对象权限">对象权限</h4>
<p>赋予了你在不同的数据库对象上操作的能力</p>
<p>比如DELETE权限允许你对表和视图删除行，SELECT权限允许你对表、视图、序列等进行查询操作。</p>
<h4 id="常用数据字典">常用数据字典</h4>
<p>这些数据字典命名格式为【谁_拥有的哪种权限】</p>
<p><strong>系统权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> COLUMN_NAME,COMMENTS <span class="keyword">from</span> dict_columns <span class="keyword">where</span> table_name=<span class="string">'DBA_SYS_PRIVS'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- select * from dict where table_name like '%SYS\_PRIVS' escape '\';</span></span><br><span class="line"><span class="comment">-- 系统权限</span></span><br><span class="line">DBA_SYS_PRIVS</span><br><span class="line">System privileges granted to users and roles</span><br><span class="line"></span><br><span class="line">CDB_SYS_PRIVS</span><br><span class="line">System privileges granted to users and roles in all containers</span><br><span class="line"></span><br><span class="line">USER_SYS_PRIVS</span><br><span class="line">System privileges granted to current user</span><br><span class="line"></span><br><span class="line">ROLE_SYS_PRIVS</span><br><span class="line">System privileges granted to roles</span><br></pre></td></tr></table></figure>
<p><strong>对象权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select * from dict where table_name like '%TAB\_PRIVS' escape '\';</span></span><br><span class="line"><span class="comment">-- 对象（表？？？）权限</span></span><br><span class="line">USER_TAB_PRIVS</span><br><span class="line">Grants on objects for which the user is the owner, grantor or grantee</span><br><span class="line"></span><br><span class="line">ALL_TAB_PRIVS</span><br><span class="line">Grants on objects for which the user is the grantor, grantee, owner,</span><br><span class="line"> or an enabled role or PUBLIC is the grantee</span><br><span class="line"></span><br><span class="line">DBA_TAB_PRIVS</span><br><span class="line">All grants on objects in the database</span><br><span class="line"></span><br><span class="line">CDB_TAB_PRIVS</span><br><span class="line">All grants on objects in the database in all containers</span><br><span class="line"></span><br><span class="line">ROLE_TAB_PRIVS</span><br><span class="line">Table privileges granted to roles</span><br></pre></td></tr></table></figure>
<p><strong>角色权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select * from dict where table_name like '%ROLE\_PRIVS' escape '\';</span></span><br><span class="line"><span class="comment">-- 角色（权限）</span></span><br><span class="line">DBA_ROLE_PRIVS</span><br><span class="line">Roles granted to users and roles</span><br><span class="line"></span><br><span class="line">CDB_ROLE_PRIVS</span><br><span class="line">Roles granted to users and roles in all containers</span><br><span class="line"></span><br><span class="line">USER_ROLE_PRIVS</span><br><span class="line">Roles granted to current user</span><br><span class="line"></span><br><span class="line">ROLE_ROLE_PRIVS</span><br><span class="line">Roles which are granted to roles</span><br></pre></td></tr></table></figure>
<p><strong>会话级别的角色/权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SESSION_PRIVS</span><br><span class="line">Privileges which the user currently has <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">SESSION_ROLES</span><br><span class="line"><span class="keyword">Roles</span> which the <span class="keyword">user</span> currently has enabled.</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> session_roles; <span class="comment">-- 当前被激活的角色</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> session_privs; <span class="comment">-- 当前拥有的权限（不包括角色里的权限）</span></span><br></pre></td></tr></table></figure>
<p>使用例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看总共有哪些角色、用户</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">unique</span> <span class="keyword">role</span> <span class="keyword">from</span> dba_roles <span class="keyword">where</span> <span class="keyword">role</span>=<span class="string">'SYSDBA'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">unique</span> username <span class="keyword">from</span> dba_users;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span>$;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某一角色所拥有的</span></span><br><span class="line"><span class="comment">-- 系统权限</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> role_sys_privs <span class="keyword">where</span> <span class="keyword">role</span>=<span class="string">'DBA'</span>;</span><br><span class="line"><span class="comment">-- 对象权限</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> role_tab_privs <span class="keyword">where</span> <span class="keyword">role</span>=<span class="string">'R1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某个用户/角色所拥有的</span></span><br><span class="line"><span class="comment">-- 系统权限</span></span><br><span class="line"><span class="keyword">select</span> GRANTEE, PRIVILEGE <span class="keyword">from</span> dba_sys_privs <span class="keyword">where</span> grantee=<span class="string">'SCOTT'</span>;</span><br><span class="line"><span class="keyword">select</span> GRANTEE, PRIVILEGE <span class="keyword">from</span> dba_sys_privs <span class="keyword">where</span> grantee=<span class="string">'CONNECT'</span>;</span><br><span class="line"><span class="comment">-- 对象权限</span></span><br><span class="line"><span class="keyword">select</span> GRANTEE, PRIVILEGE, TABLE_NAME <span class="keyword">from</span> dba_tab_privs <span class="keyword">where</span> grantee=<span class="string">'SCOTT'</span>;</span><br><span class="line"><span class="keyword">select</span> GRANTEE, PRIVILEGE, TABLE_NAME <span class="keyword">from</span> dba_tab_privs <span class="keyword">where</span> grantee=<span class="string">'R1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某一用户/角色上的角色（以及这个角色是不是默认角色，默认角色可以有多个）</span></span><br><span class="line"><span class="keyword">select</span> GRANTEE, GRANTED_ROLE,DEFAULT_ROLE <span class="keyword">from</span> dba_role_privs <span class="keyword">where</span> grantee=<span class="string">'SCOTT'</span>;</span><br><span class="line"><span class="keyword">select</span> GRANTEE, GRANTED_ROLE <span class="keyword">from</span> dba_role_privs <span class="keyword">where</span> grantee=<span class="string">'DBA'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="角色">角色</h3>
<p>ORACLE有许多的系统权限，如果一个一个地把它们分配给用户，管理起来相当的不方便，所以我们引入了角色这个概念。</p>
<p>如果多个新建用户需要后续赋予10不等的不同权限，一般方法是需要将10个不等的权限分别列出来进行授予，不但麻烦而且重用性不高，角色的出现就是为了解决这个问题。</p>
<p>Oracle角色是<strong>一组权限的集合</strong>。正常情况下我们可以授予角色一些权限，然后将角色分配给适当的用户。这样，就方便了用户的管理，通过一个角色授权语句就可以将很多的系统权限授予给用户。 比如把A、B、C权限赋给角色ROLE1了，以后只要把ROLE1角色赋给任何用户，就等同于把A、B、C权限赋给了用户</p>
<p>如果参数REMOTE_LOGIN_PASSWORDFILE的值为EXCLUSIVE,那么就可以将sysdba和sysoper权限授予其它用户。但是当以特权用户身份登录时，必须带有as sysdba或as sysoper选项。</p>
<p><strong>角色的作用</strong></p>
<p>1&gt; 简化权限的管理，减少授权次数；</p>
<p>2&gt; 权限本身是静态的（授予了就有，不授予就没有），用角色就能实现动态权限管理（==激活角色==）</p>
<p>角色处于激活状态（登陆之后激活）时，权限才有效</p>
<ul>
<li>
<p>默认角色在用户登录时激活</p>
</li>
<li>
<p>非默认角色用set role r1来激活</p>
</li>
<li>
<p>带口令激活角色set role r2 identified by r2;</p>
</li>
</ul>
<h4 id="用户自定义角色（角色激活）">用户自定义角色（角色激活）</h4>
<p>用户登录时，只激活默认角色；非default的角色都无效，需要手动set role</p>
<p>创建无口令、有口令的角色r1、r2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> r1;  <span class="comment">-- 角色</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> r2 <span class="keyword">identified</span> <span class="keyword">by</span> r2;  <span class="comment">-- 带口令角色</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> r1,r2;  <span class="comment">-- 两个角色都对此表有访问的权限</span></span><br></pre></td></tr></table></figure>
<p>赋予角色之后，要重启才有效</p>
<p>赋予r1给a</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> r1 <span class="keyword">to</span> a; <span class="comment">-- 赋予角色后，此时r1是a的默认角色</span></span><br><span class="line"><span class="comment">-- 但是r1登陆时才激活（需要重启一下），此时a不能查emp表</span></span><br><span class="line">a&gt;conn a/a</span><br><span class="line"><span class="comment">-- 这里a可以查emp表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下将a默认角色清空。此时a的默认角色为空，r1不是他的默认</span></span><br><span class="line"><span class="comment">-- 但是此时还没有“刷新”，a还暂时拥有r1角色</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> a <span class="keyword">default</span> <span class="keyword">role</span> <span class="keyword">none</span>;</span><br><span class="line"><span class="comment">-- alter user a default role all;</span></span><br><span class="line"><span class="comment">-- 重启之后，a的r1角色没有激活，不可以查emp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时需要显式激活角色r1，但set role的作用只对当前session有效，重新连接后失效</span></span><br><span class="line">a&gt;set role r1;</span><br><span class="line"><span class="comment">-- 把r1的角色激活之后a就可以访问这个表了。角色只有激活，权限才生效</span></span><br></pre></td></tr></table></figure>
<p>赋予r2给b</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> r2 <span class="keyword">to</span> b;</span><br><span class="line"><span class="comment">-- 带口令的角色赋予给用户后，不是默认角色</span></span><br><span class="line"></span><br><span class="line">b&gt;conn b/b</span><br><span class="line">b&gt;set role r2;</span><br><span class="line"><span class="comment">-- 没有激活，因为r2是带口令的</span></span><br><span class="line">ORA-01979: missing or invalid password for role 'R2'</span><br><span class="line"></span><br><span class="line">b&gt;set role r2 identified by r2; -- 激活带口令的角色</span><br><span class="line"><span class="comment">-- 此时可以查询emp</span></span><br></pre></td></tr></table></figure>
<p>sys下收回角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">revoke r2 from b;</span><br><span class="line">revoke r1 from a;</span><br></pre></td></tr></table></figure>
<h4 id="预定义角色">预定义角色</h4>
<p>创建数据库就自带的，自己分配了权限，为了之后使用方便</p>
<p><strong>connect和create session区别：</strong></p>
<p>connect 是角色，create session是权限，默认这个角色有这个权限</p>
<img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200331142903634.png" alt="image-20200331142903634" style="zoom:80%;">
<p>resource给开发人员</p>
<p>dba给管理人员</p>
<p>scott是普通用户，不能<strong>访问数据字典</strong>，可以把角色select_catalog_role赋给scott</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> select_catalog_role <span class="keyword">to</span> scott;</span><br><span class="line"><span class="comment">-- 还要激活？？？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">revoke</span> select_catalog_role <span class="keyword">from</span> scott;</span><br></pre></td></tr></table></figure>
<h4 id="特殊角色public">特殊角色public</h4>
<p>所有用户都有的角色</p>
<h4 id="应用程序角色">应用程序角色</h4>
<p>应用程序激活角色</p>
<p>不需要指派给用户，用户只要能跑这个应用程序，就有相应的权限（做的时候有，不做的时候没有）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> r1 <span class="keyword">from</span> a; <span class="comment">-- 角色撤回</span></span><br><span class="line"><span class="keyword">revoke</span> r2 <span class="keyword">from</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> app_r1 <span class="keyword">identified</span> <span class="keyword">using</span> scott.p1; <span class="comment">-- 创建应用程序角色（不能用by，否则认定为口令）</span></span><br><span class="line"><span class="comment">--create role app_r1 identified using 具体应用程序，角色可通过scott下表的p1应用激活</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> app_r1; <span class="comment">-- 给角色app_r1分配权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建应用程序/存储过程，这个存储过程创建好了</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> scott.p1</span><br><span class="line"><span class="keyword">authid</span> <span class="keyword">current_user</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">dbms_session.set_role(<span class="string">'APP_R1'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> scott.p1 <span class="keyword">to</span> a,b; <span class="comment">-- 赋ab用户执行存储过程权限</span></span><br><span class="line">conn a/a;</span><br><span class="line"></span><br><span class="line">a&gt; desc scott.emp -- 无权限</span><br><span class="line">a&gt; execute scott.p1; -- A用户执行存储过程</span><br><span class="line">a&gt; desc scott.emp --当前登陆之后且跑完过程获得权限</span><br><span class="line"><span class="comment">--退出后重新登陆后不跑过程还是无权限</span></span><br></pre></td></tr></table></figure>
<h2 id="1-Oracle验证">1. Oracle验证</h2>
<h3 id="sys用户验证方式">sys用户验证方式</h3>
<p>sys特殊用户，不打开数据库都能连</p>
<p>non-sys用户的信息在数据文件中，不打开数据库无法访问，会报Oracle not available</p>
<p>所以，在数据库shutdown时，必须是sys用户先登录，将数据库startup之后，其他用户才能连接</p>
<p>两种验证方式都启用时，操作系统验证优先</p>
<h4 id="操作系统验证">操作系统验证</h4>
<p>oracle安装之后默认情况下是启用了服务器端os认证。</p>
<p>也就是将登录数据库的用户和口令校验放在了操作系统一级，你拥有了安装oracle时的用户操作系统的认证，默认也就拥有了sys用户的认证。</p>
<p>conn / as sysdba或者sqlplus / as sysdba</p>
<p>找$ORACLE_HOME/network/admin/sqlnet.ora文件，加一行，none表示禁用操作系统验证（包括non-sys的也被禁用了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLNET.AUTHENTICATION_SERVICES&#x3D;(NONE)</span><br></pre></td></tr></table></figure>
<p>禁用后效果</p>
<p><img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200327110357194.png" alt="image-20200327110357194"></p>
<h4 id="口令文件验证">口令文件验证</h4>
<p>==口令文件中，存放着被授予sysdba/sysoper（等？？？）特殊权限的用户（特权用户/超级用户）的用户名和密码==，as sysdba就是使用口令文件验证登录的</p>
<p>口令文件是用来给远程超级用户去验证密码的。（这个口令文件的密码只适用于sys用户，一般和sys用户的密码相同，scott还是用之前的密码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如sys用户，你如果要在pl&#x2F;sqldev工具登陆，就必须使用口令文件配置好的密码，而不是你数据库中的实际密码。例如你sys用户的数据库密码为admin1#3，而口令文件配置为orap#1234。远程登陆时，使用的是orap#1234，而不是admin1#3。</span><br></pre></td></tr></table></figure>
<p>数据库在没有启动时，数据库<strong>内建用户</strong>是无法通过数据库本身来验证身份的（conn scott/123123会失败），只能用口令文件验证登录（操作系统验证禁用的情况下），有sysdba权限的用户能连接到数据库然后打开</p>
<p>Oracle可以实现对用户的身份认证，在数据库未启动之前登录，进而启动数据库</p>
<h5 id="产生及配置">产生及配置</h5>
<p>产生一个口令验证文件（二进制文件），用grant，revoke修改</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span>/dbs</span><br><span class="line">orapwd file=orapwsales password=orap<span class="comment">#1234 force=y</span></span><br><span class="line"><span class="comment"># force=y 可以强制更新</span></span><br><span class="line"><span class="comment"># 这个密码只对sys用户生效</span></span><br></pre></td></tr></table></figure>
<p>口令文件的初始化参数设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter remote_login_passwordfile</span><br><span class="line"><span class="comment">-- 三种取值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>none - 禁用口令文件</p>
</li>
<li>
<p>exclusive - 使用口令文件，但只能单例程多用户</p>
<p>适用于集群（可通过多台机器访问Oracle，多例程对应一个数据库）</p>
<p>多个instance只有一个能访问</p>
</li>
<li>
<p>shared - 使用口令文件，但只能多例程单用户</p>
<p>可以多个例程同时访问，共用一个口令文件，但只能是单用户（即sys）</p>
<p>这种设置下是不能增加其他数据库用户作为特殊权限用户到口令文件中的。</p>
</li>
</ul>
<p>Oracle数据库究竟使用OS认证还是口令文件认证来进行管理取决于下面三个因素，都要设置正确才能启用口令文件验证：</p>
<ol>
<li>SQLNET.ORA参数文件中的参数SQLNET.AUTHENTICATION_SERVICES设置不是none</li>
<li>PFILE(SPFILE)参数文件中的参数REMOTE_LOGIN_PASSWORDFILE设置不是none</li>
<li>有口令文件<code>orapw$SID(Linux) | PWD$SID.ora(Windows)</code></li>
</ol>
<h5 id="v-pwfile-users">v$pwfile_users</h5>
<p><code>V$PWFILE_USERS lists all users in the password file, and indicates whether the user has been granted the SYSDBA, SYSOPER, SYSASM,SYSBACKUP, SYSDG, and SYSKM privileges.</code></p>
<p>哪些用户能用什么“角色”，“用as的方式”登录</p>
<p>如果向用户授予特殊权限，则会将<strong>用户口令</strong>从数据字典复制到外部口令文件中，此时，即使数据库未处于打开状态，实例也可以读取口令。</p>
<p>这个视图的内容是从口令文件读出来的，如果我们将口令文件删除，那么这个视图就为空。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username,<span class="keyword">sysdba</span>,<span class="keyword">sysoper</span>,<span class="keyword">sysasm</span>,sysbackup,sysdg,syskm <span class="keyword">from</span> v$pwfile_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">sysdba</span> <span class="keyword">to</span> scott;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">sysdba</span> <span class="keyword">from</span> scott;</span><br></pre></td></tr></table></figure>
<img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200330102956168.png" alt="image-20200330102956168" style="zoom:67%;">
<p>特权身份登录上去的用户自动修改，变为sys、sysdg、public等。而不是scott</p>
<p>如果开启操作系统验证，则<strong>任意用户名</strong>用<strong>任意密码</strong>连接<strong>任意一个角色</strong>都可以，连接上的用户都是sys，赋予权限变得没有意义</p>
<p>所以要开启口令文件验证，禁用操作系统验证</p>
<p>开启之后，sys用户只能按正确的用户名密码，用特定允许的身份登录</p>
<p>（如果只有sysdba权限，则不能用sysoper身份登录）</p>
<h3 id="non-sys用户验证方式">non-sys用户验证方式</h3>
<h4 id="数据库（口令身份）验证">数据库（口令身份）验证</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc user$ <span class="comment">-- 外部连接时，去这个表验证</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> u11 <span class="keyword">identified</span> <span class="keyword">by</span> <span class="number">123123</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span> <span class="keyword">to</span> u11;</span><br><span class="line">conn u11/123123</span><br></pre></td></tr></table></figure>
<p>这是 Oracle 一般用户使用得最多的一种身份验证方式。</p>
<p>在使用口令身份验证进行连接时，实例将针对在<strong>数据字典</strong>中的用户账户存储的口令，验证给定的口令。为此，数据库必须处于打开状态；</p>
<p>从逻辑上讲，在使用口令身份验证连接时，不可能发出 STARTUP 命令或者 SHUTDOWN 命令。不允许 SYS 用户以口令身份验证的方式进行连接，SYS 只能使用口令文件、操作系统或LDAP 身份验证。</p>
<h4 id="操作系统验证-2">操作系统验证</h4>
<p>这里要把操作系统验证打开（去掉none）</p>
<p>普通用户，只要连到操作系统，就能连到数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter os_authent_prefix</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> os_authent_prefix=<span class="string">''</span> <span class="keyword">scope</span>=<span class="keyword">spfile</span>;</span><br><span class="line"><span class="comment">-- 静态参数，重启生效</span></span><br></pre></td></tr></table></figure>
<p>创建操作系统用户qq</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">useradd -g oinstall -G dba qq</span><br><span class="line">passwd qq</span><br></pre></td></tr></table></figure>
<p>sys下创建Oracle用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> qq <span class="keyword">identified</span> <span class="keyword">externally</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span> <span class="keyword">to</span> qq;</span><br></pre></td></tr></table></figure>
<p>配置qq用户的.bash_profile</p>
<p>在Oracle登录操作系统时，在~下查看profile文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>将下面这一段，复制到qq操作系统用户的profile文件下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su - qq</span><br><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ORACLE_SID=sales;<span class="built_in">export</span> ORACLE_SID</span><br><span class="line">ORACLE_UNQNAME=sales;<span class="built_in">export</span> ORACLE_UNQNAME</span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/java; <span class="built_in">export</span> JAVA_HOME</span><br><span class="line">ORACLE_BASE=/u01/app/oracle; <span class="built_in">export</span> ORACLE_BASE</span><br><span class="line">ORACLE_HOME=<span class="variable">$ORACLE_BASE</span>/product/12.2.0/dbhome_1; <span class="built_in">export</span> ORACLE_HOME</span><br><span class="line">ORACLE_TERM=xterm; <span class="built_in">export</span> ORACLE_TERM</span><br><span class="line">NLS_LANG=american_america.ZHS16GBK; <span class="built_in">export</span> NLS_LANG</span><br><span class="line">TNS_ADMIN=<span class="variable">$ORACLE_HOME</span>/network/admin; <span class="built_in">export</span> TNS_ADMIN</span><br><span class="line">ORA_NLS11=<span class="variable">$ORACLE_HOME</span>/nls/data; <span class="built_in">export</span> ORA_NLS11</span><br><span class="line">PATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$HOME</span>/bin:<span class="variable">$ORACLE_HOME</span>/bin:<span class="variable">$ORA_CRS_HOME</span>/bin</span><br><span class="line">PATH=<span class="variable">$&#123;PATH&#125;</span>:/usr/bin:/bin:/usr/bin/X11:/usr/<span class="built_in">local</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$ORACLE_HOME</span>/lib</span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>:<span class="variable">$ORACLE_HOME</span>/oracm/lib</span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>:/lib:/usr/lib:/usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH</span><br><span class="line">CLASSPATH=<span class="variable">$ORACLE_HOME</span>/JRE</span><br><span class="line">CLASSPATH=<span class="variable">$&#123;CLASSPATH&#125;</span>:<span class="variable">$ORACLE_HOME</span>/jlib</span><br><span class="line">CLASSPATH=<span class="variable">$&#123;CLASSPATH&#125;</span>:<span class="variable">$ORACLE_HOME</span>/rdbms/jlib</span><br><span class="line">CLASSPATH=<span class="variable">$&#123;CLASSPATH&#125;</span>:<span class="variable">$ORACLE_HOME</span>/network/jlib</span><br><span class="line"><span class="built_in">export</span> CLASSPATH</span><br><span class="line">THREADS_FLAG=native; <span class="built_in">export</span> THREADS_FLAG</span><br><span class="line"><span class="built_in">export</span> TEMP=/tmp</span><br><span class="line"><span class="built_in">export</span> TMPDIR=/tmp</span><br><span class="line"><span class="built_in">umask</span> 022</span><br></pre></td></tr></table></figure>
<p>让profile立即生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200330113114808.png" alt="image-20200330113114808"></p>
<p>此时qq没有查询数据字典的权限</p>
<h4 id="全局验证（了解）">全局验证（了解）</h4>
<p>基于LDAP 轻型目录访问协议</p>
<p>企业有很多数据库，如果每个数据库记录一个用户名密码，很麻烦</p>
<p>用一个用户登录到所有数据库【单点登录】</p>
<p>【pegion】做一个映射？？？全局服务器？？？</p>
<h2 id="2-Oracle授权">2. Oracle授权</h2>
<h3 id="授予系统权限">授予系统权限</h3>
<h3 id="权限传递的规则">权限传递的规则</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> a <span class="keyword">identified</span> <span class="keyword">by</span> a;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> b <span class="keyword">identified</span> <span class="keyword">by</span> b;</span><br><span class="line"><span class="comment">-- 登陆时注意在sales数据库下</span></span><br></pre></td></tr></table></figure>
<p>==系统权限是不连带收回的，可以越级撤销==</p>
<p>对某个系统权限：A授权给B，B授权给C，A收回B的权限后，C的权限不被收回的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- a下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> b; <span class="comment">-- 不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> a <span class="keyword">with</span> <span class="keyword">admin</span> <span class="keyword">option</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- a下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> b; <span class="comment">-- 可以了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">from</span> a;</span><br><span class="line"><span class="comment">-- b还可以访问，没有被连带收回</span></span><br></pre></td></tr></table></figure>
<p>==对象权限是连带收回的，不能（也不需要）越级撤销==</p>
<p>A授权给B，B授权给C，A收回B的权限后，C的权限也是被收回的。不可以越级撤销</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- a下，没有赋权限的权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下重新赋权限，带grant</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> a <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- a下</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> b; <span class="comment">-- 可以了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys收回A的对象权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">from</span> a; <span class="comment">-- B的对象权限被连带收回，</span></span><br></pre></td></tr></table></figure>
<p>如果sys给A赋了系统权限和对象权限（with grant/admin option），A再次把这些权限赋给了B</p>
<p>此时把A用户删除，权限自然也就被收回</p>
<p>B的系统权限还在，B的对象权限连带收回了</p>
<p>角色权限，和系统权限类似，==不连带撤回，能越级撤销==</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> r3;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> r3;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> r3;</span><br><span class="line"><span class="comment">-- ？？？ORA-01950: no privileges on tablespace 'USERS'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--sys</span></span><br><span class="line"><span class="keyword">grant</span> r3 <span class="keyword">to</span> a <span class="keyword">with</span> <span class="keyword">admin</span> <span class="keyword">option</span>;</span><br><span class="line"><span class="comment">--a</span></span><br><span class="line"><span class="keyword">grant</span> r3 <span class="keyword">to</span> b;</span><br><span class="line"><span class="comment">--sys</span></span><br><span class="line"><span class="keyword">revoke</span> r3 <span class="keyword">from</span> a;</span><br><span class="line"><span class="comment">--此时，b的权限还是在的</span></span><br></pre></td></tr></table></figure>
<h3 id="利用权限分析来实现最小权限原则">利用权限分析来实现最小权限原则</h3>
<p>最小权限原则：给用户能够执行这个操作的最小权限</p>
<p>dbms_privilege_capture</p>
<p><img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200331144353915.png" alt="image-20200331144353915"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 新建权限测试用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给两个权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 调用包，创建捕获</span></span><br><span class="line"><span class="comment">-- 捕获用户对两个角色内部权限的使用情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 启用捕获</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 使用测试用户连接，做一些操作（创建表、序列、视图、向表中查记录commit，顺便再访问一下数据字典）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 禁用捕获，产生分析结果</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   创建用户并赋予权限</span><br><span class="line">CREATE USER priv_test_user IDENTIFIED BY priv_test_user;</span><br><span class="line">GRANT DBA, RESOURCE TO priv_test_user;</span><br><span class="line"></span><br><span class="line">2   创建捕获</span><br><span class="line">BEGIN</span><br><span class="line">  DBMS_PRIVILEGE_CAPTURE.create_capture(</span><br><span class="line">    name        &#x3D;&gt; &#39;dba_res_user_pol&#39;,</span><br><span class="line">    type        &#x3D;&gt; DBMS_PRIVILEGE_CAPTURE.g_role_and_context,</span><br><span class="line">    roles       &#x3D;&gt; role_name_list(&#39;DBA&#39;, &#39;RESOURCE&#39;),</span><br><span class="line">    condition   &#x3D;&gt; &#39;SYS_CONTEXT(&#39;&#39;USERENV&#39;&#39;, &#39;&#39;SESSION_USER&#39;&#39;) </span><br><span class="line">    &#x3D; &#39;&#39;PRIV_TEST_USER&#39;&#39;&#39;</span><br><span class="line">  );</span><br><span class="line">END;</span><br><span class="line">&#x2F;</span><br><span class="line"></span><br><span class="line">3  启用捕获</span><br><span class="line">BEGIN</span><br><span class="line">  DBMS_PRIVILEGE_CAPTURE.enable_capture(</span><br><span class="line">    name        &#x3D;&gt; &#39;dba_res_user_pol&#39;</span><br><span class="line">  );</span><br><span class="line">END;</span><br><span class="line">&#x2F;</span><br><span class="line"></span><br><span class="line">4  用户PRIV_TEST_USER执行一些操作</span><br><span class="line">CONN priv_test_user&#x2F;priv_test_user;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab1 (</span><br><span class="line">  id NUMBER,</span><br><span class="line">  description VARCHAR2(50),</span><br><span class="line">  CONSTRAINT tab1_px PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE SEQUENCE tab1_seq;</span><br><span class="line"></span><br><span class="line">CREATE VIEW tab1_view AS</span><br><span class="line">SELECT * FROM tab1;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab1</span><br><span class="line">SELECT level, &#39;Description of &#39; || TO_CHAR(level)</span><br><span class="line">FROM   dual</span><br><span class="line">CONNECT BY level &lt;&#x3D; 5;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">SELECT name FROM v$database;</span><br><span class="line"></span><br><span class="line">5   禁用捕获并产生分析结果</span><br><span class="line">conn &#x2F; as sysdba</span><br><span class="line">BEGIN</span><br><span class="line">  DBMS_PRIVILEGE_CAPTURE.disable_capture(</span><br><span class="line">    name        &#x3D;&gt; &#39;dba_res_user_pol&#39;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  DBMS_PRIVILEGE_CAPTURE.generate_result(</span><br><span class="line">    name        &#x3D;&gt; &#39;dba_res_user_pol&#39;</span><br><span class="line">  );</span><br><span class="line">END;</span><br><span class="line">&#x2F;</span><br><span class="line"></span><br><span class="line">6    从 DBA_USED_PRIVS, DBA_USED_SYSPRIVS or DBA_USED_SYSPRIVS_PATH视图查询被使用到的系统权限</span><br><span class="line">COLUMN username FORMAT A20</span><br><span class="line">COLUMN sys_priv FORMAT A20</span><br><span class="line"></span><br><span class="line">SELECT username, sys_priv</span><br><span class="line">FROM   dba_used_sysprivs</span><br><span class="line">WHERE  capture &#x3D; &#39;dba_res_user_pol&#39;</span><br><span class="line">ORDER BY username, sys_priv;</span><br><span class="line"></span><br><span class="line">USERNAME             SYS_PRIV</span><br><span class="line">-------------------- --------------------</span><br><span class="line">PRIV_TEST_USER       CREATE ANY INDEX</span><br><span class="line">PRIV_TEST_USER       CREATE SEQUENCE</span><br><span class="line">PRIV_TEST_USER       CREATE SESSION</span><br><span class="line">PRIV_TEST_USER       CREATE TABLE</span><br><span class="line">PRIV_TEST_USER       CREATE VIEW</span><br><span class="line"></span><br><span class="line">7    从DBA_USED_SYSPRIVS_PATH视图查看用户priv_test_user怎么获得这些权限的</span><br><span class="line">COLUMN username FORMAT A20</span><br><span class="line">COLUMN used_role FORMAT A30</span><br><span class="line">COLUMN sys_priv FORMAT A20</span><br><span class="line">COLUMN path FORMAT A50</span><br><span class="line">SET LINESIZE 200</span><br><span class="line"></span><br><span class="line">SELECT username, sys_priv, used_role, path</span><br><span class="line">FROM   dba_used_sysprivs_path</span><br><span class="line">WHERE  capture &#x3D; &#39;dba_res_user_pol&#39;</span><br><span class="line">ORDER BY username, sys_priv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8   从DBA_USED_PRIVS, DBA_USED_OBJPRIVS or DBA_USED_OBJPRIVS_PATH视图查询被使用到的对象权限</span><br><span class="line"></span><br><span class="line">COLUMN username FORMAT A20</span><br><span class="line">COLUMN obj_priv FORMAT A8</span><br><span class="line">COLUMN object_owner FORMAT A15</span><br><span class="line">COLUMN object_name FORMAT A20</span><br><span class="line">COLUMN used_role FORMAT A20</span><br><span class="line">COLUMN path FORMAT A30</span><br><span class="line">SET LINESIZE 200</span><br><span class="line"></span><br><span class="line">SELECT username, obj_priv, object_owner, object_name, used_role, path </span><br><span class="line">FROM   dba_used_objprivs_path</span><br><span class="line">WHERE  capture &#x3D; &#39;dba_res_user_pol&#39;;</span><br><span class="line"></span><br><span class="line">也可以通过DBA_UNUSED_SYSPRIVS视图查询未使用到的系统权限。</span><br><span class="line">select sys_priv from DBA_UNUSED_SYSPRIVS where CAPTURE&#x3D;&#39;dba_res_user_pol&#39;;</span><br><span class="line"></span><br><span class="line">249 rows selected</span><br><span class="line"></span><br><span class="line">9   通过分析发现</span><br><span class="line">1） 所有的权限来源于DBA角色，而不是被赋予直接的权限</span><br><span class="line">2） resource角色没有被使用</span><br><span class="line">由于DBA角色有更大的权限，所以解决方案就比较简单了：</span><br><span class="line">创建一个用户自定义角色，然后将这些权限分配给该角色，并将该角色指派给该用户，完成最小权限原则。</span><br><span class="line"></span><br><span class="line">conn &#x2F; as sysdba</span><br><span class="line">CREATE ROLE custom_role;</span><br><span class="line">GRANT CREATE SEQUENCE TO custom_role;</span><br><span class="line">GRANT CREATE SESSION TO custom_role;</span><br><span class="line">GRANT CREATE TABLE TO custom_role;</span><br><span class="line">GRANT CREATE VIEW TO custom_role;</span><br><span class="line">GRANT SELECT ON SYS.V_$DATABASE TO custom_role;</span><br><span class="line"></span><br><span class="line">GRANT custom_role TO priv_test_user;</span><br><span class="line">REVOKE DBA, RESOURCE FROM priv_test_user;</span><br><span class="line"></span><br><span class="line">10   任务完毕，删除捕获</span><br><span class="line">BEGIN</span><br><span class="line">  DBMS_PRIVILEGE_CAPTURE.drop_capture(</span><br><span class="line">    name        &#x3D;&gt; &#39;dba_res_user_pol&#39;</span><br><span class="line">  );</span><br><span class="line">END;</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="概要文件">概要文件</h3>
<p>操作如果超过资源限制，则不允许做</p>
<p>创建完之后，将profile指派给用户</p>
<p>eg 输入密码错误几次，将账户锁定，只能管理员来解锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oracle@ocp ~]$ export DISPLAY&#x3D;192.168.11.1:0.0</span><br><span class="line">[oracle@ocp ~]$ sqldeveloper.sh</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200331152557598.png" alt="image-20200331152557598"></p>
<h2 id="3-Oracle审核">3. Oracle审核</h2>
<p>监视可疑的活动</p>
<h3 id="默认审核（强制审核）">默认审核（强制审核）</h3>
<p>重大的数据库事件会记录，如果系统出现故障就会有审核</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col user_name for a20</span><br><span class="line"></span><br><span class="line">col proxy_name for a20</span><br><span class="line"></span><br><span class="line">col privilege for a30</span><br><span class="line"></span><br><span class="line">col success for a20</span><br><span class="line"></span><br><span class="line">col failure for a20</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_priv_audit_opts;</span><br></pre></td></tr></table></figure>
<h3 id="标准数据库审核（初始化参数）">标准数据库审核（初始化参数）</h3>
<img src="/2020/03/21/Oracle/Oracle%E5%AE%89%E5%85%A83A/image-20200331153400633.png" alt="image-20200331153400633" style="zoom:67%;">
<p>1）启用审核，通过初始化参数audit_trail</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> audit_trail=extend db <span class="keyword">scope</span>=<span class="keyword">spfile</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>none：不启用审核</p>
</li>
<li>
<p>os：审核记录存放在操作系统的文件里（show parameter audit_file_dest）</p>
</li>
<li>
<p>db：审核记录放在数据库aud$表里（一般不去查这个表，查对应的视图dba_audit_trail）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">TIMESTAMP</span>, ACTION_NAME, USERNAME <span class="keyword">from</span> dba_audit_trail;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format = <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>xml：审核记录放在一个xml表里，放在audit_file_dest的路径里</p>
</li>
</ul>
<p>–extended不可单独使用，与其他的一起，记录的信息更能详细，开销也大</p>
<p>2）指定审核选项</p>
<p>1.审核用户（权限审核）</p>
<p>某用户行使权限时，记录下来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">audit <span class="keyword">select</span> <span class="keyword">any</span> <span class="keyword">table</span> <span class="keyword">by</span> scott; <span class="comment">--只要scott用户访问表（行使权限），就记录下来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查自己的表时，没有行使权限，不会记录</span></span><br><span class="line">audit <span class="keyword">select</span> <span class="keyword">on</span> scott.emp; <span class="comment">-- 这个才会记录</span></span><br></pre></td></tr></table></figure>
<p>2.审核对象（对象审核）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">audit <span class="keyword">delete</span> <span class="keyword">on</span> scott.emp; <span class="comment">--只关心表有没有被删除，不管谁删的都要记录下来</span></span><br><span class="line">noaudit <span class="keyword">delete</span> <span class="keyword">on</span> scott.emp; <span class="comment">-- 取消审核</span></span><br><span class="line"></span><br><span class="line">audit <span class="keyword">delete</span> <span class="keyword">on</span> scott.emp <span class="keyword">whenever</span> successful; <span class="comment">-- 只记录成功</span></span><br><span class="line">audit <span class="keyword">delete</span> <span class="keyword">on</span> scott.emp <span class="keyword">whenever</span> <span class="keyword">not</span> successful; <span class="comment">-- 只记录失败</span></span><br></pre></td></tr></table></figure>
<p>3.审核语句：和某种行为有关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">audit <span class="keyword">create</span> <span class="keyword">trigger</span>; <span class="comment">-- 审核有没有创建触发器模式</span></span><br><span class="line"></span><br><span class="line">audit <span class="keyword">delete</span> <span class="keyword">on</span> scott.emp <span class="keyword">whenever</span> successful; <span class="comment">-- 删表成功时审计，失败忽略不计</span></span><br><span class="line">audit <span class="keyword">delete</span> <span class="keyword">on</span> scott.emp <span class="keyword">whenever</span> <span class="keyword">not</span> successful; <span class="comment">-- 删表失败时审计，成功忽略不计</span></span><br><span class="line"></span><br><span class="line">audit session whenever not successful; <span class="comment">-- 仅登陆失败时记录</span></span><br><span class="line"></span><br><span class="line">audit <span class="keyword">update</span> <span class="keyword">on</span> scott.emp <span class="keyword">by</span> <span class="keyword">session</span>; <span class="comment">-- 会话中若干次更新记录，只记录一次（默认是只记录一次）</span></span><br><span class="line">audit <span class="keyword">update</span> <span class="keyword">on</span> scott.emp <span class="keyword">by</span> <span class="keyword">access</span>; <span class="comment">-- 干一次记一次</span></span><br></pre></td></tr></table></figure>
<p>查看自己设置过什么审核</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_obj_audit_opts;</span><br></pre></td></tr></table></figure>
<h3 id="基于值的审核-–-触发器">基于值的审核 – 触发器</h3>
<ul>
<li>函数和脚本，可以手工调用</li>
<li>触发器可以自动执行的一段代码，不可以手工调用（和procedure不同）</li>
</ul>
<h4 id="dml触发器">dml触发器</h4>
<p>触发条件为dml语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn scott/tiger</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> soctt.tr1_test(a <span class="built_in">varchar</span>(<span class="number">30</span>));   <span class="comment">--一般触发器不创建在sys下</span></span><br></pre></td></tr></table></figure>
<p>语句触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> scott.tr1</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">update</span> <span class="keyword">on</span> scott.emp</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.tr1_test <span class="keyword">values</span>(<span class="string">'Be changed!'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> sal=<span class="number">2800</span> <span class="keyword">where</span> mgr=<span class="number">7698</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.tr1_test; <span class="comment">-- 一条be changed</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回滚了，tr_test1中的数据也没了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果改5行，那么插入一行记录</span></span><br><span class="line"><span class="keyword">update</span> scott.emp <span class="keyword">set</span> sal=<span class="number">5000</span> <span class="keyword">where</span> mgr=<span class="number">7839</span>;<span class="comment">--动了很多条</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.tr1_test; <span class="comment">-- 一条be changed</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回滚了，tr_test1中的数据也没了</span></span><br></pre></td></tr></table></figure>
<p>逐行触发for each row</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> scott.tr1</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">update</span> <span class="keyword">on</span> scott.emp <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.tr1_test <span class="keyword">values</span>(<span class="string">'Be changed!'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.tr1_test;<span class="comment">--空</span></span><br><span class="line"><span class="keyword">update</span> scott.emp <span class="keyword">set</span> sal=<span class="number">10000</span> <span class="keyword">where</span> mgr=<span class="number">7839</span>;<span class="comment">--动了3条</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.tr1_test;<span class="comment">--有3条be changed</span></span><br></pre></td></tr></table></figure>
<p>练习：利用触发器记录员工的工资改变情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sal_change(ename <span class="built_in">varchar2</span>(<span class="number">10</span>),old_sal <span class="built_in">number</span>(<span class="number">7</span>,<span class="number">2</span>),new_sal <span class="built_in">number</span>(<span class="number">7</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> scott.tr1</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">update</span> <span class="keyword">on</span> emp <span class="keyword">referencing</span> <span class="keyword">old</span> <span class="keyword">as</span> my_old <span class="keyword">new</span> <span class="keyword">as</span> my_new <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.sal_change <span class="keyword">values</span>(:my_old.ename,:my_old.sal,:my_new.sal);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sal_change;</span><br><span class="line"><span class="keyword">update</span> scott.emp <span class="keyword">set</span> sal=<span class="number">4399</span> <span class="keyword">where</span> empno=<span class="number">7369</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sal_change;</span><br></pre></td></tr></table></figure>
<h4 id="系统触发器">系统触发器</h4>
<p>只要有用户登录，就记录时间用户等信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.logon_rec(username <span class="built_in">varchar</span>(<span class="number">30</span>),logon_time <span class="built_in">date</span>);</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">administer</span> <span class="keyword">database</span> <span class="keyword">trigger</span> <span class="keyword">to</span> scott; <span class="comment">-- 赋权限</span></span><br></pre></td></tr></table></figure>
<p>创建触发器，只要用户登陆了数据库，就有记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> scott.tr3</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">logon</span> <span class="keyword">on</span> <span class="keyword">database</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">user</span> <span class="keyword">in</span> (<span class="string">'SYS'</span>,<span class="string">'SYSTEM'</span>) <span class="keyword">then</span> <span class="literal">null</span>;</span><br><span class="line">else <span class="keyword">insert</span> <span class="keyword">into</span> scott.logon_rec <span class="keyword">values</span>(<span class="keyword">user</span>,<span class="keyword">sysdate</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn a/a;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.logon_rec;</span><br></pre></td></tr></table></figure>
<p>创建打开数据库就锁定进程的触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询内存中的对象</span></span><br><span class="line">col owner for a20</span><br><span class="line">col name for a30</span><br><span class="line">col type for a30</span><br><span class="line"><span class="keyword">select</span> owner,<span class="keyword">name</span>,<span class="keyword">type</span> <span class="keyword">from</span> v$db_object_cache <span class="keyword">where</span> owner&lt;&gt;<span class="string">'SYS'</span> <span class="keyword">and</span> kept=<span class="string">'YES'</span>;</span><br><span class="line"></span><br><span class="line">desc user_procedures;</span><br><span class="line"><span class="keyword">select</span> object_name,object_type <span class="keyword">from</span> user_procedures <span class="keyword">where</span> object_type=<span class="string">'PROCEDURE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">execute</span> dbms_shared_pool.keep(<span class="string">'SCOTT.P1'</span>);</span><br><span class="line"><span class="comment">-- 只要启动就调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 需要先给scott权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> dbms_shared_pool <span class="keyword">to</span> scott;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> scott.tr4</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">startup</span> <span class="keyword">on</span> <span class="keyword">database</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">sys.dbms_shared_pool.keep(<span class="string">'SCOTT.P1'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- shutdown，startup之后就有了</span></span><br></pre></td></tr></table></figure>
<h4 id="细粒度审计（FGA）">细粒度审计（FGA）</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc dbms_fga <span class="comment">-- 有4个存储过程，add drop enable disable policy</span></span><br><span class="line">desc dbms_shared_pool <span class="comment">-- keep存储过程，锁在内存中</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="comment">-- 调用包</span></span><br><span class="line"><span class="keyword">execute</span> dbms_fga.ADD_POLICY(<span class="string">'SCOTT'</span>,<span class="string">'EMP'</span>,<span class="string">'FGA_DEMO'</span>,STATEMENT_TYPES=<span class="string">'select,insert,delete'</span>);</span><br><span class="line">  <span class="comment">--a:</span></span><br><span class="line">   <span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> scott.emp；</span><br><span class="line">   <span class="comment">--处理错误</span></span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">index</span> scott.pk_emp <span class="keyword">rebuild</span>;</span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">quota</span> <span class="keyword">unlimited</span>……；</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> scott.emp(empno,ename)<span class="keyword">values</span>(<span class="number">1234</span>,<span class="string">'Tom'</span>);</span><br><span class="line">   <span class="keyword">update</span> scott.emp <span class="keyword">set</span> sal=<span class="number">3000</span> <span class="keyword">where</span> empno=<span class="number">1234</span>;</span><br><span class="line">   <span class="keyword">delete</span> <span class="keyword">from</span> scott.emp wheer empno=<span class="number">1234</span>;</span><br><span class="line">   <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line">   <span class="comment">--sys:</span></span><br><span class="line">   desc dba_fga_audit_trail<span class="comment">--查询dba_fga_audit_trail结果</span></span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>;</span><br><span class="line">   <span class="keyword">select</span> <span class="built_in">timestamp</span>,db_user,sql_text <span class="keyword">from</span> dba_fga_audit_trail <span class="keyword">where</span></span><br><span class="line">policy_name=<span class="string">'FGA_DEMO'</span>;<span class="comment">--policy</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 数据移动&amp;外部表</title>
    <url>/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-数据移动">1.数据移动</h2>
<ul>
<li>数据文件 ----- 数据库</li>
<li>数据库 ----- 数据文件</li>
<li>数据库 ----- 数据库</li>
</ul>
<a id="more"></a>
<h3 id="sqlload-外部数据文件–-数据库">sqlload 外部数据文件–&gt;数据库</h3>
<img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200403080339320.png" alt="image-20200403080339320" style="zoom:100%;">
<ul>
<li>control file（==重要==）：文本文件</li>
<li>input data file：数据源</li>
<li>bad file（如果有坏数据，则强行生成）：保存坏数据的文件（格式不对）【id本来应该是整型，但文件中是字符串】</li>
<li>discarded file（可选）：将格式正确，但不符合筛选条件的数据放在这里【只向数据库中插入工资大于2500的记录，不满足记录的放到这个文件中】</li>
<li>log file：（不同于重做日志文件）文本文件，sqlload出了问题可以查这个</li>
</ul>
<h4 id="sqlload数据类型">sqlload数据类型</h4>
<img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200403082334486.png" alt="image-20200403082334486" style="zoom:80%;">
<img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200404184140838.png" alt="image-20200404184140838" style="zoom: 88%;">
<p>zoned和position适用于==固定长度的记录==</p>
<p>zoned：precision表示总的位数，scale表示小数点后的位数，源数据一个小数的小数点省略表示</p>
<p>position：源数据中字段间的分隔符省略</p>
<h4 id="控制文件">控制文件</h4>
<p>数据较少时，直接写在控制文件内？</p>
<p>数据较多时，使用外部文件</p>
<ol>
<li>写load data</li>
<li>infile指定外部文件（数据源）</li>
<li>指定目标表</li>
<li>指定数据格式（记录、字段、字段名、类型、和Oracle不同）</li>
</ol>
<p>简略版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span></span><br><span class="line">  <span class="keyword">infile</span> <span class="string">'/u01/demo/animal_feeding.dat'</span></span><br><span class="line"></span><br><span class="line">  append</span><br><span class="line">  <span class="keyword">into</span> <span class="keyword">table</span> scott.animal_feeding</span><br><span class="line">  trailing nullcols</span><br><span class="line">  (</span><br><span class="line">  animal_id <span class="built_in">integer</span> <span class="keyword">external</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>,</span><br><span class="line">  feeding_date <span class="built_in">date</span> <span class="string">"dd-mon-yyyy"</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>,</span><br><span class="line">  pounds_eaten <span class="built_in">decimal</span> <span class="keyword">external</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>,</span><br><span class="line">  note <span class="built_in">char</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span></span><br><span class="line">  <span class="keyword">optionally</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">'"'</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>完整版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span></span><br><span class="line">  <span class="keyword">infile</span> <span class="string">'/u01/demo/animal_feeding.dat'</span></span><br><span class="line">  <span class="keyword">badfile</span> <span class="string">''</span></span><br><span class="line">  <span class="keyword">infile</span> <span class="comment">--可以有多个文件</span></span><br><span class="line">  <span class="keyword">badfile</span> <span class="string">''</span> <span class="comment">--一个infile对应一个badfile</span></span><br><span class="line">  </span><br><span class="line">  append <span class="comment">--默认是insert</span></span><br><span class="line">  concatenate <span class="number">2</span> <span class="comment">-- 两行一条记录，删掉则为一行一条记录</span></span><br><span class="line">  <span class="keyword">into</span> <span class="keyword">table</span> scott.animal_feeding</span><br><span class="line">  trailing nullcols <span class="comment">-- 只允许尾部为空？？？</span></span><br><span class="line">  (</span><br><span class="line">  animal_id <span class="keyword">position</span>(<span class="number">1</span>:<span class="number">3</span>) <span class="built_in">integer</span> <span class="keyword">external</span>,</span><br><span class="line">  feeding_date <span class="keyword">position</span>(<span class="number">4</span>:<span class="number">14</span>) <span class="built_in">date</span> <span class="string">"dd-mon-yyyy"</span>, <span class="comment">-- 单引号？双引号？</span></span><br><span class="line">  pounds_eaten <span class="keyword">position</span>(<span class="number">15</span>:<span class="number">19</span>) zoned(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">  note <span class="keyword">position</span>(<span class="number">20</span>:<span class="number">99</span>) <span class="built_in">char</span> <span class="comment">-- </span></span><br><span class="line">  <span class="keyword">optionally</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">'"'</span> <span class="comment">-- 只适用于note，</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>ps：</p>
<ul>
<li>
<p>默认一行是一条记录</p>
<p>如果两行一条数据，则<code>append concatenate 2 into</code></p>
</li>
<li>
<p>如果没规律，则要有标志表示新纪录的开始<code>continueif this (1:1)='-'</code></p>
<p>从第一列开始，到第一列结束</p>
</li>
<li>
<p>字段的结束符<code>terminated by &quot;,&quot;</code></p>
</li>
<li>
<p>可选定界符<code>optionally enclosed by '&quot;'</code>。char类型的如果不写这个，会将引号当作数据写入数据库</p>
</li>
</ul>
<p>into table有多种模式</p>
<img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200403084555419.png" alt="image-20200403084555419" style="zoom:80%;">
<ul>
<li>默认为insert into，表里原来有数据的话，就不会覆盖，插不进去了</li>
<li>表里已经有，则用append into</li>
<li>replace into，将表中的原来的数据删除后再插入（覆盖）</li>
</ul>
<h4 id="操作过程">操作过程</h4>
<p>csv可以用记事本打开，复制内容拷贝到/u01/demo/animal_feeding.dat下</p>
<p>建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- scott下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> animal_feeding(</span><br><span class="line">animal_id <span class="built_in">number</span>,</span><br><span class="line">feeding_date <span class="built_in">date</span>,</span><br><span class="line">pounds_eaten <span class="built_in">number</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">note <span class="built_in">varchar2</span>(<span class="number">80</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用控制文件导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlldr scott&#x2F;123123 control&#x3D;&#39;&#x2F;u01&#x2F;demo&#x2F;animal_feeding.ctl&#39;</span><br></pre></td></tr></table></figure>
<p>ps: 不需要控制文件的快捷模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ORACLE_SID&#x3D;db12c</span><br><span class="line">sqlldr scott&#x2F;123123 table&#x3D;test</span><br></pre></td></tr></table></figure>
<h4 id="eg2-st表">eg2 st表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在/u01/demo下</span></span><br><span class="line">vim st.dat</span><br><span class="line"><span class="comment">-- 复制数据</span></span><br><span class="line">name.subject,score</span><br><span class="line">zhangsan,chinese,90</span><br><span class="line">zhangsan,maths,100</span><br><span class="line">zhangsan,english,96</span><br><span class="line">lisi,chinese,94</span><br><span class="line">lisi,maths,98</span><br><span class="line">lisi,english,92</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hr下建表st</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> hr.st(<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),subject <span class="built_in">varchar</span>(<span class="number">20</span>),score <span class="built_in">int</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hr.st; <span class="comment">-- 无数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同目录下创建控制文件</span></span><br><span class="line">vim st.ctl</span><br><span class="line"><span class="comment">-- 内容</span></span><br><span class="line"><span class="keyword">load</span></span><br><span class="line">  <span class="keyword">infile</span> <span class="string">'/u01/demo/st.dat'</span></span><br><span class="line">  <span class="keyword">into</span> <span class="keyword">table</span> hr.st</span><br><span class="line">(<span class="keyword">name</span> <span class="built_in">char</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>,</span><br><span class="line"> subject <span class="built_in">char</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>,</span><br><span class="line"> score <span class="built_in">integer</span> <span class="keyword">external</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 同目录下（demo）</span></span><br><span class="line">sqlldr hr/<span class="number">123123</span> control=st.ctl</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成功~</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hr.st;</span><br></pre></td></tr></table></figure>
<h3 id="exp-imp-数据库-数据库">exp&amp;imp 数据库 --&gt; 数据库</h3>
<h4 id="exp">exp</h4>
<p>–一个工具imp/exp(可以把对象导入导出)：</p>
<p>1.交互式（问什么答什么）使用的少</p>
<p>/u01/demo/exp &gt; exp</p>
<p>2.命令模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exp scott&#x2F;tiger file &#x3D; emp.dmp tables&#x3D;emp,dept;</span><br><span class="line">imp scott&#x2F;tiger file &#x3D; emp.dmp tables&#x3D;emp;</span><br></pre></td></tr></table></figure>
<p>3.获取帮助</p>
<p>exp help=y  --看看下面的参数</p>
<p>4.exp可以导出的对象：</p>
<p>sys里的表没法导出，查看把所有的表都导出来需要多长时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">bytes</span>)/<span class="number">1024</span>/<span class="number">1024</span> <span class="keyword">size</span>(m)</span><br><span class="line"><span class="keyword">from</span> dba_segments</span><br><span class="line"><span class="keyword">where</span> segment_type=<span class="string">'TABLE'</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>整库（整个数据库，不包括系统数据）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exp &quot;&#39;sys&#x2F;admin1#3@sales as sysdba&#39;&quot; file&#x3D;&#x2F;jddl.dmp full&#x3D;y</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>表空间tablespaces=users</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> exp_full_database <span class="keyword">to</span> scott; <span class="comment">-- 把角色赋给用户scott-&gt;赋权（注意权限！）</span></span><br><span class="line">/u01/demo/exp&gt; exp scott/tiger file=users.dmp tablespaces=users  -- ok</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>方案（表的集合）owner=scott</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;u01&#x2F;demo&#x2F;exp&gt; exp scott&#x2F;tiger file&#x3D;scott.dmp owner&#x3D;scott,……其他用户;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>表tables=dept;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;u01&#x2F;demo&#x2F;exp&gt; exp scott&#x2F;tiger file&#x3D;table.dmp tables&#x3D;emp,dept,……其他表;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>导出表的子集（只把符合条件的导出）转义？？？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ORACLE_SID&#x3D;db12c</span><br><span class="line">&#x2F;u01&#x2F;demo&#x2F;exp&gt; exp scott&#x2F;123123 query&#x3D;\&#39;where sal\&gt;2500\&#39; file&#x3D;rich.dmp tables&#x3D;emp</span><br><span class="line">&#x2F;u01&#x2F;demo&#x2F;exp&gt; exp scott&#x2F;123123 query&#x3D;\&#39;where &quot;sal&gt;2500&quot;\&#39; file&#x3D;rich.dmp tables&#x3D;emp</span><br><span class="line">--注意shell</span><br></pre></td></tr></table></figure>
<p>6)使用参数文件</p>
<p>vim中写，并保存p1.par:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userid&#x3D;scott&#x2F;123123</span><br><span class="line">file&#x3D;test_para_emp.dmp</span><br><span class="line">tables&#x3D;emp</span><br><span class="line">query&#x3D;&#39;where sal&gt;2500&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">/u01/demo/exp&gt; exp parfile=p1.par</span><br><span class="line"><span class="comment">--将结果保存在test_para_emp这个文件中，且query中不用加双引号</span></span><br></pre></td></tr></table></figure>
<h4 id="imp">imp</h4>
<p>导入imp的注意事项：</p>
<p>1.ignore忽略创建错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> scott.emp;<span class="comment">--表记录全部清空，但表还在</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> scott.emp;<span class="comment">--删掉表</span></span><br><span class="line"></span><br><span class="line">imp scott/tiger file=emp1.dmp tables=emp;</span><br><span class="line"><span class="comment">--导入出错-&gt;因为导入是先创一个表，在将内容导入表中，再映射到文件，这时候表已经存在就错了</span></span><br><span class="line"></span><br><span class="line">imp scott/tiger file=emp1.dmp tables=emp ignore=y;<span class="comment">--索引出错</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> ……（粘贴）<span class="keyword">rebuild</span>;</span><br><span class="line">imp scott/tiger file=emp1.dmp tables=emp ignore=y;<span class="comment">--忽略创建这张表的错误</span></span><br></pre></td></tr></table></figure>
<p>2.fromuser, touser将用户导到哪去</p>
<p>–练习：权限问题先将scott.emp中工资大于2500的记录导出，不导出约束contraints=N，然后导入到hr.emp里（换用户from/touser）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:\exp&gt;exp scott&#x2F;tiger file&#x3D;sal2500.dmp tables&#x3D;emp query&#x3D;&#39;where &quot;sal&gt;2500&quot;&#39; constraints&#x3D;N</span><br><span class="line">F:\exp&gt;imp hr&#x2F;hr file&#x3D;sal2500.dmp fromuser&#x3D;scott touser&#x3D;hr tables&#x3D;emp--无权限</span><br><span class="line">SYS@demo&gt;grant imp_full_database to hr;</span><br><span class="line">F:\exp&gt;imp hr&#x2F;hr file&#x3D;sal2500.dmp fromuser&#x3D;scott touser&#x3D;hr tables&#x3D;emp constraints&#x3D;N</span><br><span class="line">create user hr identified by hr;--创建用户hr</span><br><span class="line">grant create session to hr;</span><br><span class="line">EXP-00091: 正在导出有问题的统计信息。--字符集不匹配，要转换会出现乱码</span><br></pre></td></tr></table></figure>
<h4 id="expdp-impdp">expdp/impdp</h4>
<p>数据泵——快</p>
<p>通过并行来提高性能，但是不一定就比exp快，对于规模小的时候效率会低一点</p>
<p>小任务：【把一个盘子敲碎，10个人洗完再合起来】</p>
<p>大任务：【餐馆里洗碗，雇佣10个人】【还要有10个水龙头（CPU）】</p>
<p>并行比串行快的情况</p>
<ul>
<li>大任务</li>
<li>足够多的空闲资源</li>
</ul>
<p>1.查看帮助<br>
expdp help=y显示参数列表<br>
F:\exp&gt;expdp scott/tiger file=F:\exp\empdp.dmp tables=emp       //报错??换db18c<br>
–文件名里不能包含路径说明<br>
F:\exp&gt;expdp scott/tiger file=empdp.dmp tables=emp<br>
–必须指定目录对象参数且不可为空</p>
<p>2.创建目录（逻辑目录）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> owner, DIRECTORY_NAME,DIRECTORY_PATH <span class="keyword">from</span> dba_directories;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> oracle_sid=db12c</span><br><span class="line">sqlplus / <span class="keyword">as</span> <span class="keyword">sysdba</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">directory</span> expdp1 <span class="keyword">as</span> <span class="string">'/u01/exp'</span>;</span><br><span class="line">F:\exp&gt; expdp scott/123123 directory=expdp1 file=empdp1.dmp tables=emp --scott用户对目录无权限</span><br></pre></td></tr></table></figure>
<p>3.授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sys@db12c&gt; grant read,write on directory expdp1 to scott;</span><br></pre></td></tr></table></figure>
<p>4.导出表格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">F:\exp&gt; expdp scott/123123 directory=expdp1 file=empdp1.dmp tables=emp</span><br><span class="line"></span><br><span class="line">impdp scott/123123 directory=expdp1 dumpfile=empdp1.dmp tables=emp  <span class="comment">--出错，表已存在</span></span><br><span class="line">impdp scott/123123 directory=expdp1 dumpfile=empdp1.dmp tables=emp</span><br><span class="line">table_exists_action=<span class="keyword">replace</span></span><br><span class="line"><span class="comment">--sys@db18c可select scott.emp</span></span><br></pre></td></tr></table></figure>
<p>–参数</p>
<ul>
<li>remap_table=emp:emp1       导入表的时候可以换个名字emp-&gt;emp1，这样不会冲掉原来的表</li>
<li>remap_schema=scott:hr     （源：目标）换到另一个用户下把原对象到瑞到目标对象下</li>
<li>remap_tablespace=tbs1:tbs2 换到另一个表空间</li>
<li>exclude=constraints;       不导出约束</li>
</ul>
<p>练习：利用expdp导出scott.emp，不导出约束，然后导入到hr.emp1，且换一个表空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select tablespace_name from dba_tables where owner&#x3D;&#39;SCOTT&#39; and table_name&#x3D;&#39;EMP&#39;;</span><br><span class="line">-- 原来在users表空间下</span><br><span class="line"></span><br><span class="line">-- 前面一定要在sys下建好逻辑目录</span><br><span class="line"></span><br><span class="line">F:\exp&gt; expdp scott&#x2F;123123 query&#x3D;\&#39;where sal\&gt;2500\&#39; directory&#x3D;expdp1 dumpfile&#x3D;scott_emp.dmp tables&#x3D;emp exclude&#x3D;constraint</span><br><span class="line"></span><br><span class="line">grant read,write on directory expdp1 to scott;</span><br><span class="line">grant read,write on directory expdp1 to hr;</span><br><span class="line"></span><br><span class="line">impdp hr&#x2F;123123 directory&#x3D;expdp1 dumpfile&#x3D;scott_emp.dmp remap_table&#x3D;emp:emp1 remap_schema&#x3D;scott:hr remap_tablespace&#x3D;users:demo</span><br><span class="line"></span><br><span class="line">select tablespace_name from dba_tables where owner&#x3D;&#39;HR&#39; and table_name&#x3D;&#39;EMP1&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="2-外部表">2.外部表</h2>
<p>不在Oracle中，在os中，减轻Oracle负担</p>
<h3 id="外部表读取文本文件">外部表读取文本文件</h3>
<p><img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200403104100838.png" alt="image-20200403104100838"></p>
<h4 id="1-产生外部表的定义">1. 产生外部表的定义</h4>
<img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200403104505249.png" alt="image-20200403104505249" style="zoom:80%;">
<p>sales sys下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">directory</span> load_dir <span class="keyword">as</span> <span class="string">'/u01/exp_load'</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">read</span>,write <span class="keyword">on</span> <span class="keyword">directory</span> load_dir <span class="keyword">to</span> scott;</span><br></pre></td></tr></table></figure>
<p>sales scott下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table external_employees</span><br><span class="line">(</span><br><span class="line">empno number,</span><br><span class="line">deptno number,</span><br><span class="line">ename varchar2(25)</span><br><span class="line">)</span><br><span class="line">organization external</span><br><span class="line">(</span><br><span class="line">type oracle_loader default directory load_dir</span><br><span class="line">access parameters</span><br><span class="line">(</span><br><span class="line">    records delimited by newline</span><br><span class="line">    fields terminated by &#39;,&#39;</span><br><span class="line">    missing field values are null</span><br><span class="line">    (empno,deptno,ename)</span><br><span class="line">)</span><br><span class="line">location (&#39;employee.dat&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>employee 要放在load_dir对应的物理目录exp_load下</p>
<img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200403110631061.png" alt="image-20200403110631061" style="zoom:90%;">
<h4 id="2-指定？？？">2. 指定？？？</h4>
<h3 id="外部表读二进制文件">外部表读二进制文件</h3>
<p>不能写数据类型</p>
<p><img src="/2020/03/27/Oracle/Oracle%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8_%E5%A4%96%E9%83%A8%E8%A1%A8/image-20200403110836078.png" alt="image-20200403110836078"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导出文件时不能写字段类型？？？是pump不是dump</span></span><br><span class="line"><span class="comment">-- 当前数据库的逻辑目录要存在</span></span><br><span class="line"><span class="comment">-- 创建了一张外部表的同时，从数据库中导出test.dmp二进制文件，表指向这个文件</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_binary(<span class="keyword">id</span>,<span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">organization</span> <span class="keyword">external</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">type</span> oracle_datapump</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">directory</span> load_dir</span><br><span class="line">location(<span class="string">'test.dmp'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span>, tname</span><br><span class="line"><span class="keyword">from</span> tab;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问这张表</span></span><br><span class="line">col name for a30</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_binary;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 然后删除t_binary这个表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t_binary;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 然后再从dmp中创建外部表，其他数据库也可以用</span></span><br><span class="line"><span class="comment">--（vim打开二进制文件，找一找像xml的地方可以看到字段名字）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tt</span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">number</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar2</span>(<span class="number">40</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">organization</span> <span class="keyword">external</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">type</span> oracle_datapump</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">directory</span> load_dir</span><br><span class="line">location(<span class="string">'test.dmp'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>tab表？？？</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 数据库备份&amp;恢复</title>
    <url>/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<ul>
<li>演示logMiner</li>
<li>演示【备份-破坏-恢复】操作</li>
</ul>
<a id="more"></a>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200407140226228.png" alt="image-20200407140226228" style="zoom:67%;">
<p>错误分类？？？</p>
<ul>
<li>用户进程错误</li>
<li>网络错误</li>
<li>用户误操作</li>
</ul>
<p>防止用户误操作（误删所有记录，误删所有表）</p>
<p>闪回，闪回到什么时候？？？</p>
<!--more-->
<h2 id="logMiner">logMiner</h2>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200407140103767.png" alt="image-20200407140103767" style="zoom:67%;">
<p>用户可能不承认，所以要看日志</p>
<p>日志是二进制文件，通过logMiner查看联机和归档重做日志文件</p>
<p>1.使用logMiner日志挖掘器（工具）查询重做日志文件</p>
<p>1）启用数据库补充日志：记日志比较全面</p>
<p>查询启动了吗？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc v$database</span><br><span class="line"><span class="comment">-- supplemental_log_data_min</span></span><br><span class="line"><span class="keyword">select</span> supplemental_log_data_min <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- NO未启动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">add</span> supplemental <span class="keyword">log</span> <span class="keyword">data</span>; <span class="comment">-- 启用</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">drop</span> supplemental <span class="keyword">log</span> <span class="keyword">data</span>; <span class="comment">-- 关闭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> supplemental_log_data_min <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- YES启动了</span></span><br></pre></td></tr></table></figure>
<p>不启用结果：update旧数据不保留，启用可以使日志记得更完整</p>
<p>2）创建/产生一个数据字典文件：</p>
<p>日志文件中—对象号：二进制/16进制记日记，人看不懂，对照数据字典文件——能对应看懂</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">directory</span> dict <span class="keyword">as</span> <span class="string">'/u01/dict'</span>; <span class="comment">-- 物理路径+逻辑路径。创建目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">execute</span> dbms_logmnr_d.build(<span class="string">'v816dic.ora'</span>,<span class="string">'DICT'</span>); <span class="comment">-- 加单引号之后要大写</span></span><br></pre></td></tr></table></figure>
<p>3）开始一个事务：开始记日记</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales scott下</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> sal=<span class="number">3800</span> <span class="keyword">where</span> empno=<span class="number">7369</span>;</span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 提交，记日记</span></span><br></pre></td></tr></table></figure>
<p>4)添加需要分析的日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sys sales下</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">group</span><span class="comment">#,status from v$log; -- 看现在哪个日志文件在使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">group</span><span class="comment">#,member from v$logfile; -- 查看正在使用的日志文件的路径</span></span><br><span class="line"><span class="comment">-- 查到日志文件名/u01/app/oracle/oradata/sales/redo04b.log</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 添加需要分析的日志文件</span></span><br><span class="line"><span class="keyword">execute</span> dbms_logmnr.add_logfile(LogFileName=&gt;<span class="string">'/u01/app/oracle/oradata/sales/redo04b.log'</span>,options=&gt;dbms_logmnr.new);</span><br></pre></td></tr></table></figure>
<p>5)执行分析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">execute</span> dbms_logmnr.start_logmnr(DictFileName=&gt;<span class="string">'/u01/dict/v816dic.ora'</span>);</span><br></pre></td></tr></table></figure>
<p>6)查询结果==视图v$logmnr_contents中==</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc v$logmnr_contents</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>; <span class="comment">-- 改一下日期格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看对某个表，进行的某个操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">timestamp</span>,username,sql_redo <span class="keyword">from</span> v$logmnr_contents</span><br><span class="line"><span class="keyword">where</span> SEG_NAME=<span class="string">'EMP'</span> <span class="keyword">and</span> operation=<span class="string">'UPDATE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询怎么对冲undo</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">timestamp</span>,username,sql_undo <span class="keyword">from</span> v$logmnr_contents</span><br><span class="line"><span class="keyword">where</span> SEG_NAME=<span class="string">'EMP'</span> <span class="keyword">and</span> operation=<span class="string">'UPDATE'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="备份与恢复">备份与恢复</h2>
<p>RMAN == Recover manage（恢复管理器，处理备份和恢复）</p>
<p>两种备份方式：</p>
<p>1）冷备份：MOUNT（数据库未打开，mount状态下的备份，不是shutdown状态下）</p>
<p>2）热备份：（数据库打开时做的备份）</p>
<p>了解：备份分类</p>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200407144339989.png" alt="image-20200407144339989" style="zoom: 80%;">
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200407144351636.png" alt="image-20200407144351636" style="zoom:67%;">
<h3 id="用户管理的冷备份和恢复">用户管理的冷备份和恢复</h3>
<ul>
<li>处于shutdown状态</li>
<li>文件不能漏，所以要做一个文件列表</li>
</ul>
<ol>
<li>初始化参数文件</li>
<li>控制文件</li>
<li>数据文件、日志文件（联机&amp;归档）</li>
<li>口令文件（可选）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> property_name,property_value <span class="keyword">from</span> database_properties;</span><br><span class="line"><span class="comment">-- 删掉不用的表空间</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">tablespace</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> USERDATA <span class="keyword">including</span> <span class="keyword">contents</span> <span class="keyword">and</span> <span class="keyword">datafiles</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> tempdef <span class="keyword">including</span> <span class="keyword">contents</span> <span class="keyword">and</span> <span class="keyword">datafiles</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> temp2 <span class="keyword">including</span> <span class="keyword">contents</span> <span class="keyword">and</span> <span class="keyword">datafiles</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> undotbs2 <span class="keyword">including</span> <span class="keyword">contents</span> <span class="keyword">and</span> <span class="keyword">datafiles</span>;</span><br></pre></td></tr></table></figure>
<h4 id="做一个文件列表">做一个文件列表</h4>
<p>通过以下命令查看现有的文件，把路径拷出来备用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS@sales&gt;show parameter undo_tablespace;</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE                   VALUE</span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line">undo_tablespace                      string                 UNDOTBS1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYS@sales&gt;show parameter spfile</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE                   VALUE</span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line">spfile                               string                 /u01/app/oracle/product/12.2.0</span><br><span class="line">                                                            /dbhome_1/dbs/spfilesales.ora</span><br><span class="line">SYS@sales&gt;select name from v$controlfile;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">/u01/app/oracle/oradata/sales/control01.ctl</span><br><span class="line">/u01/app/oracle/recovery_area/sales/control02.ctl</span><br><span class="line">/u01/demo/control03.ctl</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;select name from v$datafile;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">/u01/app/oracle/oradata/sales/system01.dbf</span><br><span class="line">/u01/app/oracle/oradata/sales/sysaux01.dbf</span><br><span class="line">/u01/app/oracle/oradata/sales/undotbs01.dbf</span><br><span class="line">/u01/app/oracle/oradata/sales/users01.dbf</span><br><span class="line">/u01/app/oracle/oradata/sales/undotbs02.dbf</span><br><span class="line">/u01/app/oracle/oradata/sales/tbs1.dbf</span><br><span class="line">/u01/app/oracle/oradata/sales/users02.dbf</span><br><span class="line"></span><br><span class="line">7 rows selected.</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;select member from v$logfile;</span><br><span class="line"></span><br><span class="line">MEMBER</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">/u01/app/oracle/oradata/sales/redo03.log</span><br><span class="line">/u01/app/oracle/oradata/sales/redo02.log</span><br><span class="line">/u01/app/oracle/oradata/sales/redo04b.log</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;select name from v$tempfile;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">/u01/app/oracle/oradata/sales/temp01.dbf</span><br><span class="line">/u01/app/oracle/oradata/sales/temp02.dbf</span><br></pre></td></tr></table></figure>
<h4 id="创建测试表">创建测试表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS@sales&gt;create table scott.cold(a varchar(30)) tablespace users;</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入一条测试记录</span></span><br><span class="line">SYS@sales&gt;insert into scott.cold values('Before backup~~');</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line">SYS@sales&gt;commit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Commit</span> complete.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 做检查点</span></span><br><span class="line"><span class="keyword">SYS</span>@sales&gt;<span class="keyword">alter</span> <span class="keyword">system</span> checkpoint;</span><br><span class="line"></span><br><span class="line">System altered.</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;select * from scott.cold;</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line">Before <span class="keyword">backup</span>~~</span><br></pre></td></tr></table></figure>
<h4 id="shutdown拷贝列表中的文件">shutdown拷贝列表中的文件</h4>
<p>==cp的时候记得shutdown，否则造成scn不一致问题==！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oracle@ocp ~]$ cd &#x2F;u01</span><br><span class="line">[oracle@ocp u01]$ cd dict</span><br><span class="line">[oracle@ocp dict]$ cd salesbak</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;12.2.0&#x2F;dbhome_1&#x2F;dbs&#x2F;spfilesales.ora .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;control01.ctl .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;recovery_area&#x2F;sales&#x2F;control02.ctl .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;demo&#x2F;control03.ctl .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo02.log .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo03.log .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo04b.log .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;system01.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;sysaux01.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;undotbs01.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;undotbs02.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;users01.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;users02.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;tbs1.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;temp01.dbf .&#x2F;</span><br><span class="line">[oracle@ocp salesbak]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;temp02.dbf .&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="startup，再插入一条记录">startup，再插入一条记录</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS@sales&gt;insert into scott.cold values('After backup~~');</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;select * from scott.cold;</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line">Before <span class="keyword">backup</span>~~</span><br><span class="line"><span class="keyword">After</span> <span class="keyword">backup</span>~~</span><br><span class="line"></span><br><span class="line"><span class="keyword">SYS</span>@sales&gt;<span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Commit</span> complete.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SYS</span>@sales&gt;<span class="keyword">shutdown</span> <span class="keyword">immediate</span></span><br><span class="line"><span class="comment">-- 需不需要shut之后再拷贝？</span></span><br></pre></td></tr></table></figure>
<h4 id="拷贝新的控制文件和日志文件">拷贝新的控制文件和日志文件</h4>
<p>因为新数据（after）都在日志文件中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@ocp salesbak]$ <span class="built_in">cd</span> <span class="built_in">log</span></span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp /u01/demo/control03.ctl ./</span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp /u01/app/oracle/oradata/sales/redo02.log ./</span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp /u01/app/oracle/oradata/sales/redo03.log ./</span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp /u01/app/oracle/oradata/sales/redo04b.log ./</span><br></pre></td></tr></table></figure>
<h4 id="破坏数据库">破坏数据库</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@ocp ~]$ vim /etc/oratab</span><br><span class="line">增加一行sales</span><br><span class="line">sales:/u01/app/oracle/product/12.2.0/dbhome_1:N</span><br><span class="line"></span><br><span class="line">[oracle@ocp ~]$ <span class="built_in">export</span> DISPLAY=192.168.11.1:0.0</span><br><span class="line">[oracle@ocp ~]$ dbca</span><br><span class="line">-- 要在startup的时候删？？？否则造成部分删除</span><br><span class="line">-- 一路向下删即可</span><br><span class="line">sys/admin1<span class="comment">#3</span></span><br></pre></td></tr></table></figure>
<p>恢复数据库</p>
<h4 id="还原初始化参数文件">还原初始化参数文件</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@ocp salesbak]$ cp spfilesales.ora /u01/app/oracle/product/12.2.0/dbhome_1/dbs/spfilesales.ora</span><br></pre></td></tr></table></figure>
<h4 id="创建口令文件中的目录">创建口令文件中的目录</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@ocp salesbak]$ cat spfilesales.ora</span><br><span class="line"></span><br><span class="line">[oracle@ocp salesbak]$ mkdir -p /u01/app/oracle/admin/sales/adump</span><br><span class="line">[oracle@ocp salesbak]$ mkdir -p /u01/app/oracle/oradata/sales</span><br><span class="line">[oracle@ocp salesbak]$ mkdir -p /u01/app/oracle/recovery_area/sales</span><br><span class="line">[oracle@ocp salesbak]$ mkdir -p /u01/omf</span><br><span class="line">[oracle@ocp salesbak]$ mkdir -p /u01/arch/1</span><br><span class="line">[oracle@ocp salesbak]$ mkdir -p /u01/arch/2</span><br></pre></td></tr></table></figure>
<h4 id="startup-nomount">startup nomount</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SYS@sales&gt;conn / as sysdba</span><br><span class="line">Connected to an idle instance.</span><br><span class="line">SYS@sales&gt;startup nomount</span><br><span class="line">ORACLE instance started.</span><br></pre></td></tr></table></figure>
<h4 id="还原控制文件">还原控制文件</h4>
<p>注意版本，用log中的，恢复到最新状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@ocp salesbak]$ <span class="built_in">cd</span> <span class="built_in">log</span></span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp control03.ctl /u01/app/oracle/oradata/sales/control01.ctl</span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp control03.ctl /u01/app/oracle/recovery_area/sales/control02.ctl</span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp control03.ctl /u01/demo/control03.ctl</span><br></pre></td></tr></table></figure>
<h4 id="mount">mount</h4>
<p>有控制文件就可以mount</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">mount</span>;</span><br></pre></td></tr></table></figure>
<h4 id="还原日志文件和数据文件">还原日志文件和数据文件</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp redo02.log /u01/app/oracle/oradata/sales/redo02.log</span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp redo03.log /u01/app/oracle/oradata/sales/redo03.log</span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ cp redo04b.log /u01/app/oracle/oradata/sales/redo04b.log</span><br><span class="line"></span><br><span class="line">[oracle@ocp <span class="built_in">log</span>]$ <span class="built_in">cd</span> ..</span><br><span class="line">[oracle@ocp salesbak]$ cp *.dbf /u01/app/oracle/oradata/sales/</span><br></pre></td></tr></table></figure>
<h4 id="介质恢复recover">介质恢复recover</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">recover database;</span><br></pre></td></tr></table></figure>
<h4 id="打开数据库并检查数据">打开数据库并检查数据</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS@sales&gt;recover database;</span><br><span class="line">Media recovery complete.</span><br><span class="line">SYS@sales&gt;alter database open;</span><br><span class="line"></span><br><span class="line">Database altered.</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;select * from scott.cold;</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line">Before <span class="keyword">backup</span>~~</span><br><span class="line"><span class="keyword">After</span> <span class="keyword">backup</span>~~</span><br></pre></td></tr></table></figure>
<h3 id="热备份一个表空间users">热备份一个表空间users</h3>
<h4 id="查找users表空间相关信息">查找users表空间相关信息</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tablespace_name <span class="keyword">from</span> dba_tables <span class="keyword">where</span> table_name=<span class="string">'COLD'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> file_name <span class="keyword">from</span> dba_data_files <span class="keyword">where</span> tablespace_name=<span class="string">'USERS'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">file</span><span class="comment">#,name from v$datafile;</span></span><br></pre></td></tr></table></figure>
<h4 id="开始备份-插入数据-结束备份">开始备份 - 插入数据 - 结束备份</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">begin</span> <span class="keyword">backup</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v$<span class="keyword">backup</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.cold <span class="keyword">values</span>(<span class="string">'After hot backup'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">end</span> <span class="keyword">backup</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v$<span class="keyword">backup</span>;</span><br></pre></td></tr></table></figure>
<h4 id="将数据文件拷贝出来">将数据文件拷贝出来</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SYS@sales&gt;!cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;users01.dbf &#x2F;u01</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;!cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;users02.dbf &#x2F;u01</span><br></pre></td></tr></table></figure>
<h4 id="将表空间脱机，删除原位置的数据文件">将表空间脱机，删除原位置的数据文件</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter tablespace users offline;</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;!rm &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;users01.dbf</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;!rm &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;users02.dbf</span><br><span class="line"></span><br><span class="line">select * from scott.cold; -- 已经没了</span><br></pre></td></tr></table></figure>
<h4 id="拷回来-介质恢复-联机查询">拷回来 - 介质恢复 - 联机查询</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS@sales&gt;!cp /u01/users01.dbf /u01/app/oracle/oradata/sales/users01.dbf</span><br><span class="line">SYS@sales&gt;!cp /u01/users02.dbf /u01/app/oracle/oradata/sales/users02.dbf</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;alter tablespace users online;</span><br><span class="line"><span class="comment">-- 连不了机，需要介质恢复</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">online</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-01113</span>: <span class="keyword">file</span> <span class="number">4</span> needs media <span class="keyword">recovery</span></span><br><span class="line">ORA<span class="number">-01110</span>: <span class="keyword">data</span> <span class="keyword">file</span> <span class="number">4</span>: <span class="string">'/u01/app/oracle/oradata/sales/users01.dbf'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SYS</span>@sales&gt;<span class="keyword">recover</span> <span class="keyword">tablespace</span> <span class="keyword">users</span>;</span><br><span class="line">Media recovery complete.</span><br><span class="line">SYS@sales&gt;alter tablespace users online;</span><br><span class="line"></span><br><span class="line">Tablespace altered.</span><br><span class="line"></span><br><span class="line">SYS@sales&gt;select * from scott.cold;</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line">After hot <span class="keyword">backup</span></span><br><span class="line"><span class="keyword">Before</span> <span class="keyword">backup</span>~~</span><br><span class="line"><span class="keyword">After</span> <span class="keyword">backup</span>~~</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">tablespace</span> <span class="keyword">users</span>;//报错，未连接到目标数据库</span><br><span class="line">connect target sys/admin</span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">tablespace</span> <span class="keyword">users</span>;//非归档模式只能做冷备份，不可做热备份</span><br><span class="line"></span><br><span class="line">sys@db18c&gt;shutdown immediate</span><br><span class="line">sys@db18c&gt;startup mount</span><br><span class="line">sys@db18c&gt;alter database archievelog;//修改数据库日志模式（非存档-&gt;存档模式）</span><br><span class="line">sys@db18c&gt;select log_mode from v$datafile;</span><br><span class="line">RMAN&gt;backup tablespace users;</span><br><span class="line">RMAN&gt;exit</span><br></pre></td></tr></table></figure>
<p>犯错：删数据文件<br>
sys db18c:select name from v$datafile;<br>
select * from scott.emp;<br>
alter tablespace users offline;</p>
<p>目录夹中users01.dbf删掉<br>
sys db18c&gt;select * from scott.emp;//查不到了，找备份<br>
F:\exp&gt;rman targer /<br>
restore tablespace users;<br>
recover tablespace users;<br>
sys db18c&gt;select * from scott.emp;//查到了</p>
<p>RMAN&gt;exit<br>
删掉数据文件<br>
F:\exp&gt;rman target /<br>
RMAN&gt;advise failure all;<br>
看修复文件脚本这个文件<br>
RMAN&gt;repair failure;<br>
db18c&gt;alter tablespace users online;<br>
可select</p>
<h2 id="RMAN下的整库备份和恢复">RMAN下的整库备份和恢复</h2>
<p>创建测试表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table scott.hotbak(a varchar(30)) tablespace users;</span><br><span class="line">insert into scott.hotback values(&#39;before rman full&#39;)</span><br></pre></td></tr></table></figure>
<p>备份前的准备</p>
<p>备份spfile、备份控制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rman target &#x2F;</span><br><span class="line">RMAN&gt;show all</span><br><span class="line">Configure controlfile autobackup on;</span><br></pre></td></tr></table></figure>
<p>备份数据文件<br>
Channel(通道）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 改为三个通道，加快速度</span><br><span class="line">CONFIGURE DEVICE TYPE DISK PARALLELISM 3 BACKUP TYPE TO BACKUPSET;</span><br><span class="line">Configure channel.device bzd</span><br><span class="line">RMAN&gt;Configure channel.device type disk format &#39;\d\demobak\%d_%u_%T&#39;</span><br><span class="line">Configure controlfile autobackup format for device type disk to &#39;d:\demobak\auto\%F&#39;;</span><br></pre></td></tr></table></figure>
<p>备份归档日志文件</p>
<p>select log_mode from v$database;//数据库中的归档模式（mount 修改状态，归档模式）<br>
Alter system archive log current ;当前日志归档</p>
<p>开始备份<br>
backup database plus archivelog//自动备份开关打开了，回车开始备份<br>
4.增加新的记录<br>
insert into scott.hotbak values(‘After backup’);<br>
commit;<br>
Demo_编号_日期备份文件<br>
delete backup;<br>
Configure device type disk parallelism 3;<br>
Alter system archive log current;<br>
Show all;<br>
backup database plus archivelog;//3个通道<br>
select tablespace_name,status from dba_tablespaces;<br>
备份数据文件、初始化参数文件<br>
RMAN&gt;select * from scot.hotbak;<br>
Insert into scott/hotbak values(‘After backup’);<br>
RMAN&gt;select * from scott.hotbak;</p>
<p>复制联机重做日志文件<br>
D:\demobak\文件夹中新建文件夹log<br>
把日志文件拷过去<br>
Demo&gt;Select member from v$logfile;//查询有哪些日志文件<br>
复制需要的日志文件至此文件夹D：\demobak\log</p>
<h3 id="破坏数据库-2">破坏数据库</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oracle@ocp ~]$ export DISPLAY&#x3D;192.168.11.1:0.0</span><br><span class="line">[oracle@ocp ~]$ vim &#x2F;etc&#x2F;oratab</span><br><span class="line">[oracle@ocp ~]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo03.log &#x2F;u01&#x2F;salesbak&#x2F;log&#x2F;re                do03.log</span><br><span class="line">[oracle@ocp ~]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo02.log &#x2F;u01&#x2F;salesbak&#x2F;log&#x2F;redo02.log</span><br><span class="line">[oracle@ocp ~]$ cp &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo04b.log &#x2F;u01&#x2F;salesbak&#x2F;log&#x2F;redo04b.log</span><br><span class="line">[oracle@ocp ~]$ dbca</span><br></pre></td></tr></table></figure>
<h3 id="恢复">恢复</h3>
<p>恢复初始化参数文件spfile</p>
<p>rman target /<br>
连接到目标数据库未启动，无法恢复<br>
rman&gt;restore spfile form’d:\demobak\auto’C-…;<br>
无初始化参数文件无法启动<br>
Rman target /<br>
rman&gt; startup nomount 找不到初始化参数文件（RMAN提供了一个简化的初始化参数文件）<br>
启动好执行restore spfile form ‘d:\demobak\auto’C-…’;<br>
Oracle \product\18.2.0\database\下有了初始化参数文件spfiledamo.ora</p>
<ol>
<li>创建相应的目录结构<br>
创建D:\app\oracle\admin\damo文件夹<br>
oracle\oradata\data<br>
fast_recovery_area\demo</li>
</ol>
<p>重新启动<br>
shutdown immediate<br>
startup nomount<br>
9. 恢复控制文件<br>
restore controlfile form ‘d:\demobak\auto’C-…’;<br>
alter database mount<br>
10. 恢复数据文件<br>
restore database;//恢复整个数据库<br>
11.将前面复制的日志文件复制到demo文件夹中<br>
recover database;//完成恢复<br>
12.打开数据库<br>
alter database open resetlogs;</p>
<h2 id="RMAN">RMAN</h2>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200407171727349.png" alt="image-20200407171727349"></p>
<h3 id="1-backup-restore">1. backup &amp; restore</h3>
<p>back — 把好多dbf文件整成一个bkp文件</p>
<p>restore — 把bkp文件还原为多个dbf文件</p>
<p>copy — 原来什么样就什么样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">export ORACLE_SID=sales</span><br><span class="line">rman target /</span><br><span class="line"></span><br><span class="line"><span class="comment">-- spfile和控制文件</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">spfile</span>; <span class="comment">-- 例程启动时，所需的初始化文件</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">current</span> control; <span class="comment">-- 需要加current</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日志文件</span></span><br><span class="line"><span class="comment">--backup logfile; -- 不能直接备份，日志文件需要归档就可</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">archivelog</span> <span class="keyword">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据文件和表空间</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">datafile</span> [文件号/文件名];</span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">tablespace</span> [表空间名]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全库备份</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-copy">2. copy</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">list copy of database;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看所有备份</span></span><br><span class="line">list <span class="keyword">backup</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">backup</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">noprompt</span> <span class="keyword">backup</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">noprompt</span> copy;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">noprompt</span> <span class="keyword">archivelog</span>;</span><br></pre></td></tr></table></figure>
<h3 id="report-show-list">report &amp; show &amp; list</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">report schema; <span class="comment">-- 查看整个数据库结构</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">datafile</span> [文件号/文件名];</span><br></pre></td></tr></table></figure>
<h3 id="show">show</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show all;</span><br><span class="line"></span><br><span class="line">report obsolete; -- 查看过期的策略（多少，多长时间）</span><br><span class="line">configure </span><br><span class="line">report need backup;</span><br><span class="line">report schema;</span><br><span class="line"></span><br><span class="line">backup datafile 4;</span><br></pre></td></tr></table></figure>
<h3 id="configure">configure</h3>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410082742307.png" alt="image-20200410082742307"></p>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410082055777.png" alt="image-20200410082055777"></p>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410082247675.png" alt="image-20200410082247675"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show all; -- 显示所有的configure</span><br><span class="line"></span><br><span class="line">configure retention policy to bzd;</span><br><span class="line"></span><br><span class="line">configure backup optimization on; -- 比较两份备份文件有没有变化，不变则不备份</span><br><span class="line">-- 存在多个只读表空间？？？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CONFIGURE CHANNEL DEVICE TYPE DISK FORMAT   &#39;&#x2F;u01&#x2F;salesbak&#x2F;%d_%u_%T&#39;;</span><br></pre></td></tr></table></figure>
<p>想把备份文件规定放置位置</p>
<p>==rman的每个操作需要分配channel - 通道（只管两头，中间不管）==</p>
<p>不要把文件名写死，下一次直接报错重复，使用变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--configure channel device type disk format &#39;&#x2F;u01&#x2F;salesbak&#x2F;users.dbf&#39;</span><br><span class="line">configure channel device type disk format &#39;&#x2F;u01&#x2F;salesbak&#x2F;%d_%u_%T&#39;;</span><br><span class="line">配置auto control、spfile的路径</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410083728264.png" alt="image-20200410083728264"></p>
<p>多开通道，加快速度</p>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410083835010.png" alt="image-20200410083835010"></p>
<h2 id="整库的不完全恢复">整库的不完全恢复</h2>
<p>何时用不完全恢复？incomplete recovery</p>
<ol>
<li>被动：eg 日志文件忘了拷贝，无法全部恢复</li>
<li>主动：有错误的命令【eg 有一个删除命令不想让他再执行一遍】</li>
</ol>
<p>用备份的控制文件，恢复一个已经删除的表空间？</p>
<p>基于时间的不完全恢复</p>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410095612006.png" alt="image-20200410095612006" style="zoom:80%;">
<p>误操作之后没有很多正确的操作</p>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410102414154.png" alt="image-20200410102414154"></p>
<h2 id="辅助数据库">辅助数据库</h2>
<p>源库（sales）要求是归档模式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup mount</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,log_mode <span class="keyword">from</span> v$<span class="keyword">database</span>;</span><br><span class="line"></span><br><span class="line">NAME               LOG_MODE</span><br><span class="line"><span class="comment">------------------ ------------------------</span></span><br><span class="line">SALES              ARCHIVELOG</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">archivelog</span>; <span class="comment">-- 打开归档模式</span></span><br></pre></td></tr></table></figure>
<p>辅助 == 克隆，名字不一样，内容一模一样（不是）</p>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410102538147.png" alt="image-20200410102538147" style="zoom:67%;">
<p>pfile</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. sales下先创建一个pfile</span></span><br><span class="line"><span class="keyword">create</span> pfile <span class="keyword">from</span> <span class="keyword">spfile</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. os下用sales的pfile复制一份给oradup，然后修改内容</span></span><br><span class="line">cd $ORACLE_HOME/dbs</span><br><span class="line">cp initsales.ora initoradup.ora</span><br><span class="line">vim initoradup.ora</span><br><span class="line"></span><br><span class="line"><span class="comment">-- vim替换命令</span></span><br><span class="line">1,$ s/sales/oradup/g</span><br><span class="line"><span class="comment">-- 去掉不用的参数</span></span><br><span class="line">db_create_file_dest db_create_online_log_dest log_archive_dest1 log_archive_dest2</span><br><span class="line"><span class="comment">-- 去掉一个控制文件</span></span><br><span class="line">control03.ctl</span><br><span class="line"></span><br><span class="line">添加初始化参数</span><br><span class="line">*.DB_FILE_NAME_CONVERT=('/u01/app/oracle/oradata/sales/','/u01/app/oracle/oradata/oradup/')</span><br><span class="line">*.LOG_FILE_NAME_CONVERT=('/u01/app/oracle/oradata/sales/','/u01/app/oracle/oradata/oradup/')</span><br><span class="line">*.log_archive_dest_1='location=/u01/arch/oradup'</span><br><span class="line"></span><br><span class="line">创建对应的目录，最下面的arch目录别忘了</span><br><span class="line">[oracle@ocp dbs]$ mkdir -p /u01/app/oracle/admin/oradup/adump</span><br><span class="line">[oracle@ocp dbs]$ mkdir -p /u01/app/oracle/oradata/oradup/</span><br><span class="line">[oracle@ocp dbs]$ mkdir -p /u01/app/oracle/recovery_area/oradup/</span><br><span class="line">[oracle@ocp dbs]$ mkdir -p /u01/arch/oradup</span><br></pre></td></tr></table></figure>
<p>做两个口令文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">orapwd file&#x3D;orapwsales password&#x3D;admin1#3</span><br><span class="line">orapwd file&#x3D;orapworadup password&#x3D;admin1#3</span><br></pre></td></tr></table></figure>
<p>配sales和oradup监听、服务名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DISPLAY&#x3D;192.168.11.1:0.0</span><br><span class="line">netmgr</span><br></pre></td></tr></table></figure>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200410103751948.png" alt="image-20200410103751948" style="zoom:80%;">
<p>记得保存网络设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ORACLE_SID&#x3D;oradup</span><br><span class="line">sqlplus sys&#x2F;admin1#3 as sysdba</span><br><span class="line">startup nomount</span><br></pre></td></tr></table></figure>
<p>开始复制数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rman target sys&#x2F;admin1#3@sales auxiliary sys&#x2F;admin1#3@oradup</span><br></pre></td></tr></table></figure>
<p>这里记得去重启下lsnrctl，oradup可能被block了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">duplicate target database to oradup from active database;</span><br></pre></td></tr></table></figure>
<p>完</p>
<h2 id="表空间基于时间点的恢复">表空间基于时间点的恢复</h2>
<p>误操作之后的数据要保留，那么需要</p>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200414140221764.png" alt="image-20200414140221764"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- scott下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/tbs101.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> tbs2 <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/tbs201.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- t1在tbs1</span></span><br><span class="line"><span class="comment">-- t2在users</span></span><br><span class="line"><span class="comment">-- t3在tbs1</span></span><br><span class="line"><span class="comment">-- idx_ename在tbs2</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.t1 <span class="keyword">tablespace</span> tbs1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> scott.idx_ename <span class="keyword">on</span> scott.t1(ename) <span class="keyword">tablespace</span> tbs2;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> checkpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rman备份数据库</span></span><br><span class="line">export ORACLE_SID=sales</span><br><span class="line">rman target /</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">backup</span>;</span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> plus <span class="keyword">archivelog</span>;</span><br><span class="line">list <span class="keyword">backup</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> systimestamp <span class="keyword">from</span> dual; <span class="comment">-- (2020-04-14 14:23:34)</span></span><br><span class="line"><span class="comment">-- 模拟误操作</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> scott.t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 误操作之后的正确操作</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.t2 <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.dept;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.t3 <span class="keyword">tablespace</span> tbs1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.t1;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.t2;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.t3;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 验证表空间的依赖性</span></span><br><span class="line"><span class="keyword">execute</span> DBMS_TTS.TRANSPORT_SET_CHECK(<span class="string">'TBS1'</span>,<span class="literal">TRUE</span>,<span class="literal">TRUE</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TRANSPORT_SET_VIOLATIONS; <span class="comment">-- 有tbs2上的索引，依赖于tbs1</span></span><br><span class="line"><span class="comment">-- 不能只把tbs1恢复，要加上tbs2</span></span><br><span class="line"><span class="keyword">execute</span> DBMS_TTS.TRANSPORT_SET_CHECK(<span class="string">'TBS1,TBS2'</span>,<span class="literal">TRUE</span>,<span class="literal">TRUE</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TRANSPORT_SET_VIOLATIONS; <span class="comment">-- 没有依赖了</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200414141201684.png" alt="image-20200414141201684"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 确定执行TSPITR后会丢失的对象</span></span><br><span class="line"><span class="comment">-- 查询执行TSPITR后会丢失的对象</span></span><br><span class="line"><span class="keyword">select</span> owner,<span class="keyword">name</span>,tablespace_name,to_char(creation_time,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) creation_time</span><br><span class="line"><span class="keyword">from</span> TS_PITR_OBJECTS_TO_BE_DROPPED</span><br><span class="line"><span class="keyword">where</span> tablespace_name <span class="keyword">in</span> (<span class="string">'TBS1'</span>,<span class="string">'TBS2'</span>)</span><br><span class="line"><span class="keyword">and</span> creation_time&gt;<span class="keyword">to_date</span>(<span class="string">'2020-04-14 14:23:34'</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>);</span><br><span class="line"><span class="comment">-- t3会丢失（误操作后的正确操作）</span></span><br><span class="line"><span class="comment">-- t2在users表空间，不受影响</span></span><br><span class="line"></span><br><span class="line">rm *.*</span><br><span class="line"><span class="comment">-- 把/u01/exp下的东西都删了</span></span><br><span class="line">-rw-r<span class="comment">----- 1 oracle oinstall 225280 4月   3 10:02 empdp1.dmp</span></span><br><span class="line">-rw-r<span class="comment">--r-- 1 oracle oinstall   1110 4月   3 10:17 export.log</span></span><br><span class="line">-rw-r<span class="comment">--r-- 1 oracle oinstall    885 4月   3 10:20 import.log</span></span><br><span class="line">-rw-r<span class="comment">--r-- 1 oracle oinstall  16384 4月   3 09:26 rich.dmp</span></span><br><span class="line">-rw-r<span class="comment">----- 1 oracle oinstall 212992 4月   3 10:17 scott_emp.dmp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先把t3导出到/u01/exp</span></span><br><span class="line">export ORACLE_SID=sales</span><br><span class="line">exp scott/123123 file=t3.dmp tables=t3</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自动创建辅助表空间，/u01/aux这个目录要有，放辅助数据库</span></span><br><span class="line"><span class="comment">-- 退出rman后</span></span><br><span class="line">export NLS_DATE_FORMAT="yyyy-mm-dd hh24:mi:ss" <span class="comment">-- 和rman一个会话，否则不生效</span></span><br><span class="line"><span class="comment">-- rman</span></span><br><span class="line">recover tablespace TBS1,TBS2 until time '2020-04-14 14:23:34' auxiliary destination '/u01/aux';</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sales下</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name,<span class="keyword">status</span> <span class="keyword">from</span> dba_tablespaces;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">online</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> tbs2 <span class="keyword">online</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时t3还没回来 exp下</span></span><br><span class="line">export ORACLE_SID=sales</span><br><span class="line">imp scott/123123 file=t3.dmp tables=t3</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 现在就回来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除测试表空间和表</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">including</span> <span class="keyword">contents</span> <span class="keyword">and</span> <span class="keyword">datafiles</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">tablespace</span> tbs2 <span class="keyword">including</span> <span class="keyword">contents</span> <span class="keyword">and</span> <span class="keyword">datafiles</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> scott.t2 <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> scott.t3 <span class="keyword">purge</span>;</span><br></pre></td></tr></table></figure>
<h2 id="表基于时间点的恢复">表基于时间点的恢复</h2>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200414140200689.png" alt="image-20200414140200689"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.emp1 <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="comment">-- rman</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> plus <span class="keyword">archivelog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> scott.emp1;</span><br><span class="line"><span class="keyword">select</span> current_scn <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- 2441438</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> scott.emp1 <span class="keyword">purge</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 误操作后的正确操作</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.emp2 <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp; <span class="comment">-- 创建另一个表</span></span><br><span class="line"><span class="keyword">update</span> scott.emp <span class="keyword">set</span> sal=<span class="number">8888</span> <span class="keyword">where</span> empno=<span class="number">7369</span>; <span class="comment">-- 更新一条数据</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rman</span></span><br><span class="line">recover table scott.emp1 until scn 2441438 auxiliary destination '/u01/aux';</span><br><span class="line"></span><br><span class="line"><span class="comment">-- emp1回来了，其他表没有受影响</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> scott.emp1;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> scott.emp2;</span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> scott.emp <span class="keyword">where</span> empno=<span class="number">7369</span>;</span><br></pre></td></tr></table></figure>
<h2 id="恢复目录数据库recovery-catalog">恢复目录数据库recovery catalog</h2>
<p>用途：</p>
<ol>
<li></li>
<li>多个版本的数据库？？？</li>
<li>存储rman脚本</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">list incarnation; <span class="comment">-- 数据库的化身</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">database</span> <span class="keyword">to</span> incarnation <span class="number">2</span>; <span class="comment">-- 要有恢复目录</span></span><br><span class="line"></span><br><span class="line">shutdown immediate</span><br><span class="line">startup mount</span><br></pre></td></tr></table></figure>
<ul>
<li>db12c - 目录数据库</li>
<li>sales - 目标数据库</li>
<li>oradup - 目标数据库</li>
</ul>
<p>把后两个的数据放到目录中？？？</p>
<h3 id="创建恢复目录">创建恢复目录</h3>
<p>步骤，考试简答题</p>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200414154632912.png" alt="image-20200414154632912" style="zoom:67%;">
<p>db12c下</p>
<p>a 创建表空间，用来保存【备份和恢复 有关的系统数据】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">tablespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> cat <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/db12c/cat01.dbf'</span> <span class="keyword">size</span></span><br><span class="line"><span class="comment">-- 一个15m</span></span><br></pre></td></tr></table></figure>
<p>b 创建目录的所有者catowner</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> catowner <span class="keyword">identified</span> <span class="keyword">by</span> <span class="keyword">admin</span>;</span><br></pre></td></tr></table></figure>
<p>c 修改目录所有者的默认表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> catowner <span class="keyword">default</span> <span class="keyword">tablespace</span> cat;</span><br></pre></td></tr></table></figure>
<p>d 赋相应的权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>,recovery_catalog_owner <span class="keyword">to</span> catowner;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> catowner <span class="keyword">quota</span> <span class="keyword">unlimited</span> <span class="keyword">on</span> cat;</span><br><span class="line"><span class="comment">-- 可以无限使用表空间的权限</span></span><br></pre></td></tr></table></figure>
<p>rman连接目录数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rman catalog catowner&#x2F;admin</span><br></pre></td></tr></table></figure>
<p>创建恢复目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create catalog tablespace &#39;CAT&#39;;</span><br><span class="line">report schema; -- 啥都没有</span><br></pre></td></tr></table></figure>
<p>连接到目标数据库sales，并注册（把sales备份相关的信息放到了这里）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect target sys&#x2F;admin1#3@sales</span><br><span class="line">register database;</span><br><span class="line">report schema;</span><br><span class="line">-- 此时backup database，备份的就是sales</span><br><span class="line">list incarnation;</span><br></pre></td></tr></table></figure>
<p>连接目标数据库oradup，并注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rman catalog catowner&#x2F;admin@db12c target sys&#x2F;admin1#3@oradup</span><br><span class="line">-- 将rman connect两个命令合在一起了</span><br><span class="line">register database;</span><br><span class="line">report schema;</span><br><span class="line">list incarnation; -- 和连接的数据库无关</span><br></pre></td></tr></table></figure>
<p>oradup下，创建一个表空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create tablespace demo datafile &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;db12c&#x2F;demo01.dbf&#39; size 10m;</span><br></pre></td></tr></table></figure>
<p>目标数据库结构发生变化后，一般会自动同步，rman下report schema;发现出现了</p>
<p>手工同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resync catalog;</span><br></pre></td></tr></table></figure>
<h3 id="rman脚本">rman脚本</h3>
<p>只有恢复目录才能创建脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rman catalog catowner&#x2F;admin@db12c target sys&#x2F;admin1#3@sales</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create script Level0Backup &#123;</span><br><span class="line">backup tablespace users;</span><br><span class="line">delete noprompt obselete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list script names;</span><br><span class="line"></span><br><span class="line">print script Level0Backup;</span><br><span class="line"></span><br><span class="line">run &#123;execute script Level0Backup&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闪回技术">闪回技术</h2>
<p>能解决逻辑错误（误删除表啥的）</p>
<p>物理错误无法解决</p>
<h3 id="闪回数据库">闪回数据库</h3>
<p>原理：闪回日志</p>
<p>闪回日志信息存在控制文件中</p>
<p>前提：归档模式、开启闪回日志</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales下</span></span><br><span class="line">archive log list</span><br><span class="line"><span class="keyword">select</span> flashback_on <span class="keyword">from</span> v$<span class="keyword">database</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">flashback</span> <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure>
<p>和闪回数据库相关的初始化参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter recover</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE                   VALUE</span><br><span class="line">------------------------------------ ---------------------- ------------------------------</span><br><span class="line">db_recovery_file_dest                string                 &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;recovery_area</span><br><span class="line">db_recovery_file_dest_size           big integer            8016M</span><br><span class="line">db_unrecoverable_scn_tracking        boolean                TRUE</span><br><span class="line">recovery_parallelism                 integer                0</span><br><span class="line">remote_recovery_file_dest            string</span><br><span class="line"></span><br><span class="line">show parameter db_flashback_retention_target</span><br></pre></td></tr></table></figure>
<ul>
<li>db_recovery_file_dest：闪回区。闪回日志存储位置</li>
<li>db_recovery_file_dest_size：闪回区大小</li>
<li>db_flashback_retention_target：默认闪回日志的保留时间（分钟）</li>
</ul>
<p>查询能闪回到的最早的时间点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc v$flashback_database_log</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">"yyyy-mm-dd hh24:mi:ss"</span>;</span><br><span class="line"><span class="keyword">select</span> oldest_flashback_scn,oldest_flashback_time <span class="keyword">from</span> v$flashback_database_log;</span><br></pre></td></tr></table></figure>
<p>记录时间，开始破坏</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> current_scn <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- 2458240</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> scott <span class="keyword">cascade</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- flashback database to scn 2458240;</span></span><br><span class="line"><span class="comment">-- 只能在mount阶段做</span></span><br><span class="line"></span><br><span class="line">shutdown immediate</span><br><span class="line">startup mount</span><br><span class="line">flashback database to scn 2458240;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有风险，reset之后日志就回不来了</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span> <span class="keyword">resetlogs</span>; <span class="comment">-- 日志scn不一样了，需要</span></span><br></pre></td></tr></table></figure>
<img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200414164058849.png" alt="image-20200414164058849" style="zoom:67%;">
<h3 id="闪回表">闪回表</h3>
<h4 id="针对DML">针对DML</h4>
<p>前提：激活表的行移动特性（delete一行之后，insert到了原位置，闪回就不能成功</p>
<p>scott下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">col table_name for a30</span><br><span class="line">select table_name,row_movement from user_tables;</span><br><span class="line"></span><br><span class="line">alter table emp enable row movement;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="built_in">time</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">select</span> systimestamp <span class="keyword">from</span> dual; <span class="comment">-- 14-APR-20 04.56.37.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">flashback table emp to timestamp to_timestamp('2020-04-14 16:56:37','yyyy-mm-dd hh24:mi:ss');</span><br></pre></td></tr></table></figure>
<h4 id="针对DDL">针对DDL</h4>
<p>系统表闪回不能</p>
<p>前提：启用回收站（初始化参数，默认启用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter recyclebin</span><br></pre></td></tr></table></figure>
<p>查看回收站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show recyclebin</span><br><span class="line"></span><br><span class="line">ORIGINAL NAME    RECYCLEBIN NAME                OBJECT TYPE  DROP TIME</span><br><span class="line">---------------- ------------------------------ ------------ -------------------</span><br><span class="line">EMP              BIN$oz1tqoxbZljgU8gLqMBFpQ&#x3D;&#x3D;$0 TABLE        2020-04-14:17:00:16</span><br><span class="line">TEST_HHH         BIN$oluSWkXCSzHgU8gLqMB2Tg&#x3D;&#x3D;$0 TABLE        2020-04-03:11:32:49</span><br></pre></td></tr></table></figure>
<p>清空回收站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">purge recyclebin</span><br></pre></td></tr></table></figure>
<p>删表（实际上只是把表改了名字）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp;</span><br><span class="line"><span class="comment">-- drop table cold1 purge; -- 不会放到回收站，彻底删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看回收站中表的内容</span></span><br><span class="line"><span class="keyword">show</span> recyclebin</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">"BIN$oluSWkXCSzHgU8gLqMB2Tg==$0"</span>; <span class="comment">-- 回收站里RECYCLEBIN NAME里的一串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flashback table emp to before drop;</span><br></pre></td></tr></table></figure>
<p>闪回时，如果外面已经又建了一张同名的表，报错（原来的名字已被占用）</p>
<p>也可以闪回时改名，解决重名问题</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flash table cold to before <span class="keyword">drop</span> <span class="keyword">rename</span> <span class="keyword">to</span> cold1;</span><br></pre></td></tr></table></figure>
<h3 id="闪回查询">闪回查询</h3>
<p>对一个表做了错误操作，但后面又做了正确操作</p>
<h4 id="闪回查询表">闪回查询表</h4>
<p>直接查这个表在某个时间的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 17:06:15</span></span><br><span class="line"><span class="comment">-- 误操作</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 误操作后的正确操作</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno,ename) <span class="keyword">values</span>(<span class="number">114514</span>,<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不能直接闪到delete之前，会丢失正确操作</span></span><br><span class="line"><span class="comment">-- 查找到表的历史版本中，误删了的数据</span></span><br><span class="line"><span class="comment">-- select * from emp as of timestamp to_timestamp('2020-04-14 17:06:15','yyyy-mm-dd hh24:mi:ss') where deptno=30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接将这些数据插回到现在的表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">as</span> <span class="keyword">of</span> <span class="built_in">timestamp</span> to_timestamp(<span class="string">'2020-04-14 17:06:15'</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">where</span> deptno=<span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<h4 id="闪回版本查询">闪回版本查询</h4>
<p><img src="/2020/04/05/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/image-20200414171208903.png" alt="image-20200414171208903"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> my_emp <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> my_emp <span class="keyword">set</span> sal=<span class="number">1500</span> <span class="keyword">where</span> empno=<span class="number">114</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> my_emp <span class="keyword">set</span> sal=<span class="number">3500</span> <span class="keyword">where</span> empno=<span class="number">114</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> my_emp <span class="keyword">set</span> sal=<span class="number">5000</span> <span class="keyword">where</span> empno=<span class="number">114</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> my_emp <span class="keyword">set</span> sal=<span class="number">5000</span> <span class="keyword">where</span> empno=<span class="number">114</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> my_emp <span class="keyword">versions</span> <span class="keyword">between</span> <span class="keyword">scn</span> <span class="keyword">minvalue</span> <span class="keyword">and</span> maxvalue <span class="keyword">where</span> empno=<span class="number">114</span>;</span><br><span class="line"><span class="comment">-- 可以看到特定记录的某些字段的历史数据</span></span><br></pre></td></tr></table></figure>
<h4 id="闪回事务查询">闪回事务查询</h4>
<p>前提：启用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> supplemental_log_data_min <span class="keyword">from</span> v$<span class="keyword">database</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- scott</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.my_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模拟事务中误操作后面的正确操作</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> scott.my_emp <span class="keyword">where</span> empno=<span class="number">114</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> scott.my_emp <span class="keyword">where</span> empno=<span class="number">7934</span>;</span><br><span class="line"><span class="comment">-- 删完记得commit，否则不记录事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7934要，114号tom不要了</span></span><br><span class="line"><span class="keyword">select</span> versions_xid,versions_operation, empno,ename,sal <span class="keyword">from</span> scott.my_emp <span class="keyword">versions</span> <span class="keyword">between</span> <span class="keyword">scn</span> <span class="keyword">minvalue</span> <span class="keyword">and</span> maxvalue;</span><br><span class="line"><span class="comment">-- 检查刚刚记录的事务号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys下获得这个事务号对应的对冲语句</span></span><br><span class="line">desc flashback_transaction_query</span><br><span class="line"><span class="keyword">select</span> undo_sql <span class="keyword">from</span> flashback_transaction_query <span class="keyword">where</span> xid=<span class="string">'08000600E7020000'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面undo_sql获得的对冲语句</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">"SCOTT"</span>.<span class="string">"MY_EMP"</span>(<span class="string">"EMPNO"</span>,<span class="string">"ENAME"</span>,<span class="string">"JOB"</span>,<span class="string">"MGR"</span>,<span class="string">"HIREDATE"</span>,<span class="string">"SAL"</span>,<span class="string">"COMM"</span>,<span class="string">"DEPTNO"</span>) <span class="keyword">values</span> (<span class="string">'7934'</span>,<span class="string">'MILLER'</span>,<span class="string">'CLERK'</span>,<span class="string">'7782'</span>,<span class="keyword">TO_DATE</span>(<span class="string">'23-JAN-82'</span>, <span class="string">'DD-MON-RR'</span>),<span class="string">'1300'</span>,<span class="literal">NULL</span>,<span class="string">'10'</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 文件部分</title>
    <url>/2020/03/23/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="管理控制文件">管理控制文件</h2>
<ul>
<li>
<p>二进制文件 - Oracle读的 - 效率高</p>
</li>
<li>
<p>控制文件定义整个数据库的状态</p>
<p>Oracle实例要访问存储时，要知道有哪些文件，是什么名字，分别存储在什么地方，有哪些表文件。。。</p>
<p>所以初始化参数文件中要规定好控制文件的位置</p>
</li>
<li>
<p>在mount阶段读取控制文件，无控制文件则无法mount</p>
</li>
<li>
<p>不能随便拷出来备份，有时间号，每个数据库有独有的控制文件</p>
</li>
<li>
<p>创建数据库时，自动产生控制文件，保证数据库完整性</p>
</li>
</ul>
<a id="more"></a>
<h3 id="控制文件位置">控制文件位置</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter control_files</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">controlfile</span>;</span><br></pre></td></tr></table></figure>
<h3 id="控制文件内容">控制文件内容</h3>
<img src="/2020/03/23/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86/image-20200324151311899.png" alt="image-20200324151311899" style="zoom: 67%;">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dbid,<span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- 名称和标识</span></span><br></pre></td></tr></table></figure>
<h3 id="如何查看控制文件内容">如何查看控制文件内容</h3>
<p>oradebug将二进制转成文本文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- oradebug在数据库登录时</span></span><br><span class="line">oradebug <span class="keyword">help</span></span><br><span class="line">oradebug setmypid <span class="comment">-- 指定一个进程做这件事</span></span><br><span class="line">oradebug dump controlf <span class="number">3</span> <span class="comment">-- 转储为trc文本文件，3级别</span></span><br><span class="line">oradebug tracefile_name <span class="comment">-- 输出，转储后文件路径</span></span><br><span class="line"><span class="comment">-- /u01/app/oracle/diag/rdbms/sales/sales/trace/sales_ora_22343.trc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里在数据库外面做</span></span><br><span class="line"><span class="keyword">export</span> DISPLAY=<span class="number">192.168</span><span class="number">.11</span><span class="number">.1</span>:<span class="number">0.0</span></span><br><span class="line">gedit 文件路径</span><br></pre></td></tr></table></figure>
<p>SCN号</p>
<ul>
<li>database entry：建库的相关信息</li>
<li>log file records：记录日志文件名称和位置（如果os级别日志文件位置变了，要敲命令更新控制文件）</li>
<li>data file records：数据文件名称和位置</li>
<li>tempfile records：临时文件名称和位置</li>
<li>tablespace record：表空间名和对应的数据文件</li>
<li>rman configuration records</li>
<li>flashback logfile records：闪回日志位置等相关信息</li>
<li>MTTR records：自动检查点</li>
<li>archived log records：归档日志情况</li>
</ul>
<p>==3.24考试：闪回数据库，闪不回来，原因？==</p>
<p>如果把控制文件重建了，闪回日志信息丢失</p>
<h3 id="控制文件的多路复用">控制文件的多路复用</h3>
<p>multiplexing the control file using spfile</p>
<p>最少一个，最多8个</p>
<p>内容全部相同，只是为了保险，一个坏了，其他拿来直接用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 需要使用spfile启动（使用show parameter spfile检查）</span></span><br><span class="line"><span class="comment">-- 否则修改scope=spfile时报错no spfile is in use</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第一步先将control files静态参数修改掉（注意scope），为了让Oracle知道控制文件在哪里</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> control_files=<span class="string">'/u01/app/oracle/oradata/sales/control01.ctl'</span>,<span class="string">'/u01/app/oracle/recovery_area/sales/control02.ctl'</span>,<span class="string">'/u01/demo/control03.ctl'</span> <span class="keyword">scope</span>=<span class="keyword">spfile</span>;</span><br><span class="line"><span class="comment">-- 修改静态参数后，shut</span></span><br><span class="line">shutdown immediate</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二步，复制一份控制文件到指定目录/u01/demo/</span></span><br><span class="line">cp /u01/app/oracle/oradata/sales/control01.ctl /u01/demo/control03.ctl</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第三步</span></span><br><span class="line">startup</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">controlfile</span>;</span><br><span class="line"><span class="comment">-- 复用完成</span></span><br><span class="line"><span class="comment">-- 发现有三个控制文件了，如果有一个坏了，直接拷过去就行？？？</span></span><br></pre></td></tr></table></figure>
<p>模拟有一个控制文件损坏了（直接os删除）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rm /u01/demo/control03.ctl</span><br><span class="line"></span><br><span class="line">startup mount;</span><br><span class="line"></span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-00205: error in identifying control file, <span class="keyword">check</span> alert <span class="keyword">log</span> <span class="keyword">for</span> more info</span><br></pre></td></tr></table></figure>
<p>查看警告日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adrci</span><br><span class="line"><span class="keyword">show</span> homes</span><br><span class="line"><span class="keyword">set</span> home diag/rdbms/sales/sales</span><br><span class="line"><span class="keyword">show</span> alert -tail <span class="number">30</span></span><br><span class="line"></span><br><span class="line">ORA<span class="number">-00202</span>: ????: <span class="string">''</span>/u01/demo/control03.ctl<span class="string">''</span></span><br><span class="line">ORA<span class="number">-27037</span>: ????????</span><br><span class="line">Linux-x86_64 <span class="keyword">Error</span>: <span class="number">2</span>: <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> <span class="keyword">directory</span></span><br></pre></td></tr></table></figure>
<p>数据库nomount或shutdown时，拷贝一份控制文件到这个缺失的地方（记得改名）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cp /u01/app/oracle/oradata/sales/control01.ctl /u01/demo/control03.ctl</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">mount</span>;</span><br><span class="line"><span class="comment">-- 就起来了</span></span><br></pre></td></tr></table></figure>
<h3 id="创建控制文件">创建控制文件</h3>
<p>如果所有控制文件坏了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- shutdown之后，在Oracle里（或者外面）将三个控制文件全部删除</span></span><br><span class="line">! rm /u01/app/oracle/oradata/sales/control01.ctl</span><br><span class="line">! rm /u01/app/oracle/recovery_area/sales/control02.ctl</span><br><span class="line">! rm /u01/demo/control03.ctl</span><br></pre></td></tr></table></figure>
<h4 id="方法一">方法一</h4>
<p>没有控制文件，只能起到nomount状态</p>
<p>如果用之前拷出去的控制文件拷回来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup</span><br><span class="line">ORA-00205: error in identifying control file, <span class="keyword">check</span> alert <span class="keyword">log</span> <span class="keyword">for</span> more info</span><br><span class="line"></span><br><span class="line">!cp /u01/demo/control04.ctl /u01/app/<span class="keyword">oracle</span>/<span class="keyword">oradata</span>/sales/control01.ctl</span><br><span class="line">!cp /u01/demo/control04.ctl /u01/app/<span class="keyword">oracle</span>/recovery_area/sales/control02.ctl</span><br><span class="line">!cp /u01/demo/control04.ctl /u01/demo/control03.ctl</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">mount</span>; <span class="comment">-- 可以</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br><span class="line">ORA-01122: database file 1 failed verification <span class="keyword">check</span></span><br><span class="line">ORA<span class="number">-01110</span>: <span class="keyword">data</span> <span class="keyword">file</span> <span class="number">1</span>: <span class="string">'/u01/app/oracle/oradata/sales/system01.dbf'</span></span><br><span class="line">ORA<span class="number">-01207</span>: <span class="keyword">file</span> <span class="keyword">is</span> more recent <span class="keyword">than</span> control <span class="keyword">file</span> - <span class="keyword">old</span> control <span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>会提示数据文件比控制文件新，实际上就是控制文件中记录的checkpoint_change#比数据文件头中的checkpoint_change#要小，这种情况是不能打开数据库的</p>
<p>但数据可以启动到mount状态</p>
<p>此时可以执行下面的命令，把<strong>创建控制文件的命令</strong>，写到trace文件中去，同时要使用as将这个文件定位</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只能在mount时做</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">backup</span> <span class="keyword">controlfile</span> <span class="keyword">to</span> <span class="keyword">trace</span> <span class="keyword">as</span> <span class="string">'/u01/demo/create_control6.txt'</span>; <span class="comment">-- 创建成功</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 去外面查看这个文件的内容，把里面的一段代码在Oracle中执行一遍</span></span><br><span class="line"><span class="comment">-- NORESETLOGS  NOARCHIVELOG注意是这两个参数对应的代码</span></span><br><span class="line"><span class="comment">-- 不是很相似的代码，RESETLOGS  ARCHIVELOG</span></span><br><span class="line"><span class="comment">-- 如果执行错代码，则会发生下面的错误，此时只要重新一遍执行正确代码即可</span></span><br><span class="line">SYS@sales&gt;alter database open;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-01589</span>: must <span class="keyword">use</span> <span class="keyword">RESETLOGS</span> <span class="keyword">or</span> <span class="keyword">NORESETLOGS</span> <span class="keyword">option</span> <span class="keyword">for</span> <span class="keyword">database</span> <span class="keyword">open</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删掉代码中间的【--】</span></span><br><span class="line"><span class="comment">-- 为什么是noarchivelog？？？</span></span><br><span class="line"><span class="comment">-- 必须在nomount下运行</span></span><br><span class="line"><span class="keyword">STARTUP</span> NOMOUNT</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">CONTROLFILE</span> <span class="keyword">REUSE</span> <span class="keyword">DATABASE</span> <span class="string">"SALES"</span> <span class="keyword">NORESETLOGS</span>  <span class="keyword">ARCHIVELOG</span></span><br><span class="line">    <span class="keyword">MAXLOGFILES</span> <span class="number">16</span></span><br><span class="line">    <span class="keyword">MAXLOGMEMBERS</span> <span class="number">2</span></span><br><span class="line">    MAXDATAFILES <span class="number">30</span></span><br><span class="line">    <span class="keyword">MAXINSTANCES</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">MAXLOGHISTORY</span> <span class="number">292</span></span><br><span class="line"><span class="keyword">LOGFILE</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="number">2</span> <span class="string">'/u01/app/oracle/oradata/sales/redo02.log'</span>  <span class="keyword">SIZE</span> <span class="number">10</span>M <span class="keyword">BLOCKSIZE</span> <span class="number">512</span>,</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="number">3</span> <span class="string">'/u01/app/oracle/oradata/sales/redo03.log'</span>  <span class="keyword">SIZE</span> <span class="number">10</span>M <span class="keyword">BLOCKSIZE</span> <span class="number">512</span>,</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="number">4</span> <span class="string">'/u01/app/oracle/oradata/sales/redo04b.log'</span>  <span class="keyword">SIZE</span> <span class="number">10</span>M <span class="keyword">BLOCKSIZE</span> <span class="number">512</span></span><br><span class="line"><span class="keyword">DATAFILE</span></span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/system01.dbf'</span>,</span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/sysaux01.dbf'</span>,</span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/undotbs01.dbf'</span>,</span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/users01.dbf'</span>,</span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/undotbs02.dbf'</span>,</span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/tbs101.dbf'</span>,</span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/tbs201.dbf'</span>,</span><br><span class="line">  <span class="string">'/u01/app/oracle/oradata/sales/users02.dbf'</span></span><br><span class="line"><span class="built_in">CHARACTER</span> <span class="keyword">SET</span> US7ASCII</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Control file created.</span><br></pre></td></tr></table></figure>
<p>如果控制文件丢了，nomount阶段，不能生成那个txt。只有mount时才可以</p>
<h4 id="方法二手写语句">方法二手写语句</h4>
<p>其中，重建的控制文件至少需要以下信息：</p>
<p>按照上面语句自己手写</p>
<ul>
<li>
<p>数据库名：create pfile from spfile，打开就可以看到</p>
</li>
<li>
<p>字符集：启动到nomount状态， select userenv(‘language’) from dual;</p>
</li>
<li>
<p>数据文件名称：os下找到所有数据文件 + 日志文件的路径</p>
<p>这里不包括临时文件。存在但是Oracle不知道？？？只有临时表空间</p>
</li>
<li>
<p>几个初始化参数（怎么设置？？？反正是max，随便设置得大一些？？？）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> v$<span class="keyword">instance</span>; <span class="comment">-- 发现已经自动mount</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br><span class="line"><span class="comment">-- 可能会有的错误</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-01113</span>: <span class="keyword">file</span> <span class="number">1</span> needs media <span class="keyword">recovery</span></span><br><span class="line"><span class="comment">-- ORA-01110: data file 1: \'/u01/app/oracle/oradata/HOEGH/system01.dbf\'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recover</span> <span class="keyword">database</span>;</span><br><span class="line">Media recovery complete.</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">controlfile</span>; <span class="comment">-- 已经全部恢复</span></span><br></pre></td></tr></table></figure>
<h2 id="管理日志文件">管理日志文件</h2>
<h3 id="了解日志文件">了解日志文件</h3>
<p>日志是恢复用的，例程或者介质出了问题，用日志恢复</p>
<ul>
<li>
<p>instance recovery 数据在内存中，还没写出来就丢掉了</p>
</li>
<li>
<p>media recovery 已经写出来到数据文件，数据文件丢了</p>
</li>
</ul>
<img src="/2020/03/23/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86/image-20200325124546258.png" alt="image-20200325124546258" style="zoom:67%;">
<ul>
<li>
<p>日志文件以组安排，至少要有两个组，组之间循环工作</p>
</li>
<li>
<p>一个组的两个成员是镜像关系，内容完全相同。只是放的位置不同，安全</p>
</li>
</ul>
<h3 id="了解日志文件组信息-v-log">了解日志文件组信息 v$log</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col status for a12</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">GROUP</span><span class="comment">#,MEMBERS,SEQUENCE#,STATUS,FIRST_CHANGE#,NEXT_CHANGE#,ARCHIVED from v$log;</span></span><br><span class="line"><span class="comment">-- members为组中的成员数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- first_time和first_change#作用相同，一个是date，一个是scn</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format=<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">GROUP</span><span class="comment">#,MEMBERS,SEQUENCE#,STATUS,FIRST_TIME,NEXT_TIME from v$log;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">GROUP</span><span class="comment">#    MEMBERS  SEQUENCE# STATUS       FIRST_CHANGE# NEXT_CHANGE#</span></span><br><span class="line"><span class="comment">---------- ---------- ---------- ------------ ------------- ------------</span></span><br><span class="line">         <span class="number">2</span>          <span class="number">1</span>         <span class="number">37</span> INACTIVE           <span class="number">2664938</span>      <span class="number">2766162</span></span><br><span class="line">         <span class="number">4</span>          <span class="number">1</span>         <span class="number">39</span> <span class="keyword">CURRENT</span>            <span class="number">2770810</span>   <span class="number">1.8447E+19</span></span><br><span class="line">         <span class="number">3</span>          <span class="number">1</span>         <span class="number">38</span> INACTIVE           <span class="number">2766162</span>      <span class="number">2770810</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>FIRST_CHANGE# 表示哪个时间点<strong>开始使用</strong>的这个组</p>
</li>
<li>
<p>NEXT_CHANGE# 表示哪个时间点<strong>结束使用</strong>的这个组</p>
<p>非常大的那个说明这个组还在使用</p>
</li>
<li>
<p>firstchange和nextchange<strong>用来定位</strong>，如果发生故障的时间位于这两者中间，则就用这个日志组恢复</p>
<p>【账本写满了，换一本，原来的封面上写上起止日期】</p>
</li>
</ul>
<p>日志组状态：</p>
<ul>
<li>active：此时该日志组中提交的事务引起的数据改变还没有完全从DB buffer cache写入到数据文件中。例程恢复时需要用到这个日志文件。</li>
<li>inactive：做完检查点之后，acive变为inactive，日志已经写到数据文件中了，不需要了，删掉也不会丢数据（介质恢复还是需要这些inactive的日志）</li>
<li>current： LGWR进程正把redo log buffer的日志写进日志组中</li>
<li>unused：新增的组，还没有开始用的</li>
</ul>
<h3 id="查询日志文件成员-v-logfile">查询日志文件成员 v$logfile</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">GROUP</span><span class="comment">#,type,STATUS,MEMBER from v$logfile;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">GROUP</span><span class="comment"># TYPE           STATUS</span></span><br><span class="line"><span class="comment">---------- -------------- ------------</span></span><br><span class="line"><span class="keyword">MEMBER</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">         <span class="number">3</span> <span class="keyword">ONLINE</span></span><br><span class="line">/u01/app/<span class="keyword">oracle</span>/<span class="keyword">oradata</span>/sales/redo03.log</span><br><span class="line"></span><br><span class="line">         <span class="number">2</span> <span class="keyword">ONLINE</span></span><br><span class="line">/u01/app/<span class="keyword">oracle</span>/<span class="keyword">oradata</span>/sales/redo02.log</span><br><span class="line"></span><br><span class="line">         <span class="number">4</span> <span class="keyword">ONLINE</span></span><br><span class="line">/u01/app/<span class="keyword">oracle</span>/<span class="keyword">oradata</span>/sales/redo04b.log</span><br><span class="line"></span><br><span class="line"><span class="comment">-- status有时会变成stale、invalid</span></span><br><span class="line"><span class="keyword">Status</span> <span class="keyword">of</span> the <span class="keyword">log</span> <span class="keyword">member</span>:</span><br><span class="line">INVALID - <span class="keyword">File</span> <span class="keyword">is</span> inaccessible</span><br><span class="line">STALE - <span class="keyword">File</span><span class="string">'s contents are incomplete</span></span><br><span class="line"><span class="string">-- 手动切换下日志组就好了</span></span><br></pre></td></tr></table></figure>
<h3 id="自动切换日志组时Oracle做的事情"><strong>自动</strong>切换日志组时Oracle做的事情</h3>
<ol>
<li>
<p>做检查点</p>
</li>
<li>
<p>相关信息<strong>写控制文件</strong>（当前日志序列号等）</p>
<p>将旧日志组的nextchange和新日志组的firstchange，更新为当时的SCN</p>
</li>
</ol>
<p>==考试：归档日志模式下，自动切换时，哪些进程在工作？多选题==</p>
<ul>
<li>LGWR，LGWR转向新的日志组写日志（指针改变？）</li>
<li>CKPT，做检查点</li>
<li>DBWR，检查点最后要写盘，发信号给database writer</li>
<li>ARC，归档进程</li>
</ul>
<h3 id="手动切换日志文件组">手动切换日志文件组</h3>
<p>原来的组变成active（未写入数据文件），新的组为current</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> current_scn,CHECKPOINT_CHANGE<span class="comment"># from v$database;</span></span><br><span class="line"><span class="comment">-- scn随时在更新，如果数据库没有open，则为0；系统检查点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">switch</span> <span class="keyword">logfile</span>; <span class="comment">-- 手动切换日志文件</span></span><br><span class="line"><span class="comment">-- 切换日志调用的是进程，所以是system</span></span><br></pre></td></tr></table></figure>
<p><strong>手工做检查点</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> checkpoint;</span><br><span class="line"><span class="comment">-- 所有active的日志组全部变为inactive，日志中的操作都写入数据文件</span></span><br></pre></td></tr></table></figure>
<p><strong>ps：自动做检查点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter fast_start_mttr_target</span><br></pre></td></tr></table></figure>
<p>默认是0，修改为300s</p>
<p>解释：积累了【使用日志需要300s才能恢复】的脏数据时，做一次检查点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> fast_start_mttr_target=<span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<h3 id="添加-删除日志组-日志文件">添加/删除日志组/日志文件</h3>
<h4 id="增加日志组">增加日志组</h4>
<p>生产中，可能会出现日志文件等待现象</p>
<p>如果只有两个组，一个组A写满了去归档。</p>
<p>如果另一个组B也写满的时候，前面那个组A归档还没有完成，造成等待</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">add</span> <span class="keyword">logfile</span> <span class="keyword">group</span> <span class="number">4</span> (<span class="string">'/u01/app/oracle/oradata/sales/redo04a.log'</span>) <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"><span class="comment">-- 这个组状态此时为unused</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--alter database add logfile group 5 '/u01/app/oracle/oradata/sales/redo05a.log' size 10m ,'/u01/app/oracle/oradata/sales/redo05b.log' size 10m;</span></span><br><span class="line"><span class="comment">-- 添加多个时，后一个文件自动加到组1里了？？？（此时组1不存在）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确添加方法</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">add</span> <span class="keyword">logfile</span> <span class="keyword">group</span> <span class="number">5</span> (<span class="string">'/u01/app/oracle/oradata/sales/redo05a.log'</span> ,<span class="string">'/u01/app/oracle/oradata/sales/redo05b.log'</span>) <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"><span class="comment">-- 日志组内成员，文件大小都一样，最后说一下就行</span></span><br></pre></td></tr></table></figure>
<h4 id="添加日志文件组成员">添加日志文件组成员</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">add</span> <span class="keyword">logfile</span> <span class="keyword">member</span> <span class="string">'/u01/app/oracle/oradata/sales/redo04b.log'</span> <span class="keyword">to</span> <span class="keyword">group</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 不需要写大小，因为成员之间是镜像关系</span></span><br><span class="line"><span class="comment">-- alter 语句中不可设定redo04b.log的大小</span></span><br></pre></td></tr></table></figure>
<p>成员状态为invalid（stale），开始使用就没有了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">!ls -l /u01/app/oracle/oradata/sales/redo04*.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 两个文件一样大的</span></span><br></pre></td></tr></table></figure>
<h4 id="删除日志文件组">删除日志文件组</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">drop</span> <span class="keyword">logfile</span> <span class="keyword">group</span> <span class="number">1</span>; <span class="comment">-- 1为组名</span></span><br></pre></td></tr></table></figure>
<p>current组不能删，一定要删就只能切换日志</p>
<p>active组也不能删，在系统恢复时需要使用</p>
<p>一定要删就只能将active日志组的内容写入数据文件（alter system checkpoint），变为inactive</p>
<p>组1删完之后，文件redo01.log还在</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">! rm /u01/app/oracle/oradata/sales/redo01.log</span><br></pre></td></tr></table></figure>
<p>需要操作系统rm掉这个log文件给Oracle擦屁股？引出OMF</p>
<h4 id="删除日志文件成员">删除日志文件成员</h4>
<p><strong>不能删掉一个组里唯一的成员</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">drop</span> <span class="keyword">logfile</span> <span class="keyword">member</span> <span class="string">'/u01/app/oracle/oradata/sales/redo02.log'</span>;</span><br><span class="line"></span><br><span class="line">ORA-00361: cannot remove last log member /u01/app/oracle/oradata/sales/redo02.log for group 2</span><br></pre></td></tr></table></figure>
<p><strong>current组的成员不能删</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">GROUP</span><span class="comment">#,MEMBERS,SEQUENCE#,STATUS,FIRST_CHANGE#,NEXT_CHANGE# from v$log;</span></span><br><span class="line">    <span class="keyword">GROUP</span><span class="comment">#    MEMBERS  SEQUENCE# STATUS       FIRST_CHANGE# NEXT_CHANGE#</span></span><br><span class="line"><span class="comment">---------- ---------- ---------- ------------ ------------- ------------</span></span><br><span class="line">         <span class="number">2</span>          <span class="number">1</span>         <span class="number">43</span> INACTIVE           <span class="number">2878349</span>      <span class="number">2878946</span></span><br><span class="line">         <span class="number">3</span>          <span class="number">1</span>         <span class="number">44</span> INACTIVE           <span class="number">2878946</span>      <span class="number">2881486</span></span><br><span class="line">         <span class="number">4</span>          <span class="number">2</span>         <span class="number">45</span> <span class="keyword">CURRENT</span>            <span class="number">2881486</span>   <span class="number">1.8447E+19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">drop</span> <span class="keyword">logfile</span> <span class="keyword">member</span> <span class="string">'/u01/app/oracle/oradata/sales/redo04a.log'</span>;</span><br><span class="line"></span><br><span class="line">ORA-01609: log 4 is the current log for thread 1 - cannot <span class="keyword">drop</span> members</span><br><span class="line">ORA<span class="number">-00312</span>: <span class="keyword">online</span> <span class="keyword">log</span> <span class="number">4</span> <span class="keyword">thread</span> <span class="number">1</span>: <span class="string">'/u01/app/oracle/oradata/sales/redo04b.log'</span></span><br><span class="line">ORA<span class="number">-00312</span>: <span class="keyword">online</span> <span class="keyword">log</span> <span class="number">4</span> <span class="keyword">thread</span> <span class="number">1</span>: <span class="string">'/u01/app/oracle/oradata/sales/redo04a.log'</span></span><br></pre></td></tr></table></figure>
<p><strong>切换之后，active组的成员能不能删？</strong></p>
<p>不是这个组的最后一个就行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">switch</span> <span class="keyword">logfile</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">GROUP</span><span class="comment">#,MEMBERS,SEQUENCE#,STATUS,FIRST_CHANGE#,NEXT_CHANGE# from v$log;</span></span><br><span class="line">    <span class="keyword">GROUP</span><span class="comment">#    MEMBERS  SEQUENCE# STATUS       FIRST_CHANGE# NEXT_CHANGE#</span></span><br><span class="line"><span class="comment">---------- ---------- ---------- ------------ ------------- ------------</span></span><br><span class="line">         <span class="number">2</span>          <span class="number">1</span>         <span class="number">46</span> <span class="keyword">CURRENT</span>            <span class="number">2884681</span>   <span class="number">1.8447E+19</span></span><br><span class="line">         <span class="number">3</span>          <span class="number">1</span>         <span class="number">44</span> INACTIVE           <span class="number">2878946</span>      <span class="number">2881486</span></span><br><span class="line">         <span class="number">4</span>          <span class="number">2</span>         <span class="number">45</span> ACTIVE             <span class="number">2881486</span>      <span class="number">2884681</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">drop</span> <span class="keyword">logfile</span> <span class="keyword">member</span> <span class="string">'/u01/app/oracle/oradata/sales/redo04a.log'</span>;</span><br><span class="line"></span><br><span class="line">    GROUP<span class="comment">#    MEMBERS  SEQUENCE# STATUS       FIRST_CHANGE# NEXT_CHANGE#</span></span><br><span class="line"><span class="comment">---------- ---------- ---------- ------------ ------------- ------------</span></span><br><span class="line">         2          1         46 CURRENT            2884681   1.8447E+19</span><br><span class="line">         3          1         44 INACTIVE           2878946      2881486</span><br><span class="line">         4          1         45 ACTIVE             2881486      2884681</span><br></pre></td></tr></table></figure>
<h3 id="clear“清除”日志文件组（成员）">clear“清除”日志文件组（成员）</h3>
<p>clear 适用情况：如果一个组的成员只有一个，还坏掉了，需要修理</p>
<p>（clear作用是删旧加新）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">clear</span> <span class="keyword">logfile</span> <span class="keyword">group</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">clear</span> <span class="keyword">logfile</span> <span class="string">''</span>;</span><br></pre></td></tr></table></figure>
<p>如果不用clear，则要加一个新名字的log，删除旧的log，改回名字</p>
<h3 id="归档模式">归档模式</h3>
<h4 id="设置归档-非归档模式">设置归档 / 非归档模式</h4>
<p>如何改成归档模式，这个命令必须在mount状态，还没open时做</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如何查看现在是什么状态</span></span><br><span class="line"><span class="keyword">select</span> log_mode <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- 方法一</span></span><br><span class="line">archive log list <span class="comment">-- 方法二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> v$<span class="keyword">instance</span>; <span class="comment">-- 查看处于open状态时</span></span><br><span class="line">shutdown immediate</span><br><span class="line">startup mount</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">archivelog</span>; <span class="comment">-- 修改为归档模式，日志写满之后，文件自动归档？？？</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">noarchivelog</span>; <span class="comment">-- 关闭归档模式</span></span><br></pre></td></tr></table></figure>
<p>以后都归档！！！</p>
<p>归档的日志文件可以通过LOGMNR进行分析</p>
<p>归档时：将日志中的操作写入数据文件，然后归档，切换日志组</p>
<h4 id="查询归档日志信息-v-archived-log">查询归档日志信息 v$archived_log</h4>
<p>recovery_area == 闪回区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$archived_log;</span><br></pre></td></tr></table></figure>
<h4 id="设置归档目的地并手工归档">设置归档目的地并手工归档</h4>
<p>归档目的地设置为/u01/arch</p>
<p>如果怕丢，在初始化参数中设置两个子归档目的地，这两个目录里存放的归档日志是完全相同的（复用）</p>
<p>/u01/arch/1</p>
<p>/u01/arch/2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter log_archive_dest</span><br><span class="line"><span class="keyword">NAME</span>                                 <span class="keyword">TYPE</span>                   <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line">log_archive_dest                     <span class="keyword">string</span></span><br><span class="line">log_archive_dest_1                   <span class="keyword">string</span>                 location=/u01/arch/<span class="number">1</span></span><br><span class="line">log_archive_dest_2                   <span class="keyword">string</span>                 location=/u01/arch/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 存放归档日志的路径，可以复用（最多30个）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 下面这种方法会报错，需要指定在本地还是远程</span></span><br><span class="line"><span class="comment">-- alter system set log_archive_dest_1='/u01/arch/1';</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> log_archive_dest_1=<span class="string">'location=/u01/arch/1'</span>; <span class="comment">-- 本地</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> log_archive_dest_2=<span class="string">'location=/u01/arch/2'</span>;</span><br><span class="line"><span class="comment">-- 远程，service填写一个服务名（指向远程的数据库）</span></span><br><span class="line"><span class="comment">-- alter system set log_archive_dest_3='[db12c]=/u01/arch/1'; -- 报错</span></span><br><span class="line">ORA-32017: failure in updating SPFILE</span><br><span class="line">ORA-16179: incremental changes to "log_archive_dest_3" not allowed <span class="keyword">with</span> <span class="keyword">SPFILE</span></span><br></pre></td></tr></table></figure>
<p><strong>手动归档</strong></p>
<p>可以将当前使用的日志组手动归档，此时不会写盘</p>
<p>（最好先手动做一个检查点，再手工归档。需要先将日志中的操作写入数据文件？？？）</p>
<p>ps：自动归档发生在：当前使用的日志组容量已满时，此时做检查点、写脏数据、切换日志组、顺便就归档</p>
<p>不是等到要被覆盖了才归档。后面循环到这一组时就可以直接覆盖了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看下一条待归档的日志（next log sequence to archive）</span></span><br><span class="line">archive log list</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">archive</span> <span class="keyword">log</span> <span class="keyword">current</span>;</span><br></pre></td></tr></table></figure>
<p>归档之后，完成切换日志组。上述参数规定的两个路径里出现新的归档文件，完全一致两个文件</p>
<p><strong>归档日志文件命名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter log_archive</span><br><span class="line"><span class="comment">-- 发现有一个关于归档日志命名格式的参数</span></span><br><span class="line">log_archive_format                   <span class="keyword">string</span>                 %t_%s_%r.dbf</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> log_archive_format=<span class="string">'%t_%s_%r.arc'</span> <span class="keyword">scope</span>=<span class="keyword">spfile</span>; <span class="comment">-- 静态参数</span></span><br></pre></td></tr></table></figure>
<h3 id="日志文件丢失处理处理方法">日志文件丢失处理处理方法</h3>
<h4 id="1-非当前current日志丢失">1 非当前current日志丢失</h4>
<p>数据库shutdown之后，将非current日志rm掉，模拟日志文件丢失</p>
<p>shut时，做检查点，将日志文件中对应的脏数据写盘了，例程恢复不再用到这几个日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">shutdown immediate</span><br><span class="line"></span><br><span class="line">!ls -l /u01/app/oracle/oradata/sales/redo03.log</span><br><span class="line"><span class="comment">-- 有文件</span></span><br><span class="line"></span><br><span class="line">!rm /u01/app/oracle/oradata/sales/redo03.log</span><br><span class="line"></span><br><span class="line">!ls -l /u01/app/oracle/oradata/sales/redo03.log</span><br><span class="line"><span class="comment">-- ls: 无法访问/u01/app/oracle/oradata/sales/redo03.log: 没有那个文件或目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日志文件删除成功</span></span><br><span class="line"></span><br><span class="line">startup <span class="comment">-- 起不来了，只能到mount阶段（具体哪个文件缺了也不告你）</span></span><br></pre></td></tr></table></figure>
<p>在oracle外，使用adrci工具，查看警告日志文件里，哪一个日志缺失了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oracle@ocp demo]$ adrci</span><br><span class="line"></span><br><span class="line">ADRCI: Release 12.2.0.1.0 - Production on Tue Mar 24 17:20:21 2020</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2017, Oracle and&#x2F;or its affiliates.  All rights reserved.</span><br><span class="line"></span><br><span class="line">ADR base &#x3D; &quot;&#x2F;u01&#x2F;app&#x2F;oracle&quot;</span><br><span class="line">adrci&gt; show home</span><br><span class="line">ADR Homes:</span><br><span class="line">diag&#x2F;rdbms&#x2F;db12c&#x2F;db12c</span><br><span class="line">diag&#x2F;rdbms&#x2F;sales&#x2F;sales</span><br><span class="line">diag&#x2F;tnslsnr&#x2F;ocp&#x2F;listener</span><br><span class="line"></span><br><span class="line">adrci&gt; set home diag&#x2F;rdbms&#x2F;sales&#x2F;sales</span><br><span class="line"></span><br><span class="line">adrci&gt; show alert -tail 50</span><br></pre></td></tr></table></figure>
<p>查到是这个文件没有了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ORA-00313: ??????? 3 (???? 1) ???</span><br><span class="line">ORA-00312: ???? 3 ?? 1: &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo03.log&#39;</span><br><span class="line">ORA-27037: ????????</span><br><span class="line">Linux-x86_64 Error: 2: No such file or directory</span><br><span class="line">Additional information: 7</span><br><span class="line">Errors in file &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;rdbms&#x2F;sales&#x2F;sales&#x2F;trace&#x2F;sales_lgwr_3494.trc:</span><br><span class="line">ORA-00313: ??????? 3 (???? 1) ???</span><br><span class="line">ORA-00312: ???? 3 ?? 1: &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo03.log&#39;</span><br><span class="line">ORA-27037: ????????</span><br><span class="line">Linux-x86_64 Error: 2: No such file or directory</span><br><span class="line">Additional information: 7</span><br><span class="line">Errors in file &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;rdbms&#x2F;sales&#x2F;sales&#x2F;trace&#x2F;sales_ora_3544.trc:</span><br><span class="line">ORA-00313: open failed for members of log group 1 of thread</span><br><span class="line">ORA-00312: online log 3 thread 1: &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo03.log&#39;</span><br><span class="line">USER (ospid: 3544): terminating the instance due to error 313</span><br></pre></td></tr></table></figure>
<p>查找到哪个文件缺失之后，直接clear一下，就能恢复</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conn / as sysdba</span><br><span class="line">startup mount</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">clear</span> <span class="keyword">logfile</span> <span class="keyword">group</span> <span class="number">3</span>; <span class="comment">-- log 3说明了这个日志文件位于group3</span></span><br><span class="line"></span><br><span class="line">!ls -l /u01/app/oracle/oradata/sales/redo03.log</span><br><span class="line"><span class="comment">-- 有文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">group</span><span class="comment">#,sequence#,status from v$log;</span></span><br><span class="line"></span><br><span class="line">         <span class="number">3</span>          <span class="number">0</span> <span class="keyword">UNUSED</span></span><br></pre></td></tr></table></figure>
<h4 id="2-当前current日志丢失">2 当前current日志丢失</h4>
<p>只能全部重建</p>
<p>在scott用户下更新emp表的数据，并commit。保证写到日志文件里，但没有在数据文件中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> scott.emp <span class="keyword">set</span> sal=<span class="number">4399</span> <span class="keyword">where</span> empno=<span class="number">7369</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>此时这个更新操作已经放到current日志组</p>
<p>然后把这个文件删除掉（open时删掉就出大问题了，需要用备份恢复了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!rm &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo04b.log&#39;</span><br><span class="line"></span><br><span class="line">shutdown immediate</span><br></pre></td></tr></table></figure>
<p>然后到mount状态，用clear，发现不能用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startup mount</span><br><span class="line">alter database clear logfile group 4;</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-00350: log 4 of instance sales (thread 1) needs to be archived</span><br><span class="line">ORA-00312: online log 4 thread 1: &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;redo04b.log&#39;</span><br></pre></td></tr></table></figure>
<p>recover</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">recover database until cancel;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>; <span class="comment">-- 还不能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span> <span class="keyword">resetlogs</span>; <span class="comment">-- open了</span></span><br></pre></td></tr></table></figure>
<p>日志文件全部清零（包括omf，但归档的日志还在）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">group</span><span class="comment">#,status,member from v$logfile;</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">GROUP</span><span class="comment">#,MEMBERS,SEQUENCE#,STATUS,FIRST_CHANGE#,NEXT_CHANGE#,ARCHIVED from v$log;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">GROUP</span><span class="comment">#    MEMBERS  SEQUENCE# STATUS       FIRST_CHANGE# NEXT_CHANGE# ARCHIV</span></span><br><span class="line"><span class="comment">---------- ---------- ---------- ------------ ------------- ------------ ------</span></span><br><span class="line">         <span class="number">2</span>          <span class="number">1</span>          <span class="number">1</span> <span class="keyword">CURRENT</span>            <span class="number">2890755</span>   <span class="number">1.8447E+19</span> <span class="keyword">NO</span></span><br><span class="line">         <span class="number">3</span>          <span class="number">1</span>          <span class="number">0</span> <span class="keyword">UNUSED</span>                   <span class="number">0</span>            <span class="number">0</span> YES</span><br><span class="line">         <span class="number">4</span>          <span class="number">1</span>          <span class="number">0</span> <span class="keyword">UNUSED</span>                   <span class="number">0</span>            <span class="number">0</span> YES</span><br></pre></td></tr></table></figure>
<h2 id="OMF">OMF</h2>
<p>omf = oracle manage file</p>
<p>每个omf目录下还会有[数据库名]/[文件类型名]细分（因为Oracle可以管理的文件有很多类型）</p>
<h3 id="未实现omf时，数据文件的操作">未实现omf时，数据文件的操作</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">tablespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> tbs1;</span><br><span class="line"><span class="comment">-- 没有打开omf时，不指定路径会报错</span></span><br><span class="line">ORA-02199: missing DATAFILE/TEMPFILE clause</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/tbs1.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"><span class="comment">-- 这样才能成功</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name,file_name <span class="keyword">from</span> dba_data_files;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不打开omf时，删表空间时不会实际删除文件</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> tbs1;</span><br></pre></td></tr></table></figure>
<h3 id="数据文件的omf">数据文件的omf</h3>
<p>通过一个初始化参数就可以打开</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter db_create_file_dest</span><br><span class="line"><span class="comment">-- 同样适用于日志文件</span></span><br></pre></td></tr></table></figure>
<p>为啥没有后缀1、2、3，数据文件不需要多路复用hhh</p>
<p>这个参数默认为空，适用于所有类型文件？？？</p>
<p>创建目录/u01/omf（指定好创建数据文件的默认目的地）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> db_create_file_dest=<span class="string">'/u01/omf'</span>;</span><br></pre></td></tr></table></figure>
<p>设置好omf之后，create tablespace 和drop tablespace都简单了（不用加任何参数，不用rm）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> tbs3;</span><br><span class="line"><span class="comment">-- 上面目录里自动创建了数据文件</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> tbs3;</span><br><span class="line"><span class="comment">-- 目录里的数据文件自动删除，不用写including就连着删了，为啥？？？</span></span><br><span class="line"><span class="comment">-- 如果开了omf，不加datafiles也会帮你删掉数据文件</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> small <span class="keyword">including</span> <span class="keyword">contents</span>;</span><br></pre></td></tr></table></figure>
<p>取消数据文件omf</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 把这个参数去掉，默认omf？？？没有把</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> db_create_file_dest=<span class="string">''</span>;</span><br></pre></td></tr></table></figure>
<h3 id="日志文件的omf">日志文件的omf</h3>
<p>omf和手动指定文件混合使用时：</p>
<p>eg：omf自动创建一个组，成员多路复用</p>
<p>此时如果手动添加一个日志组成员文件，删除组时不会自动管理</p>
<p>omf隐含了成员数就是多路复用的数量，无法自动添加一个</p>
<p><strong>日志文件默认OMF位置</strong></p>
<p>日志文件比较特殊，没有指定omf参数时，也会有一个默认路径，还是会有omf</p>
<p>在闪回区(Oracle Flash recovery area)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">add</span> <span class="keyword">logfile</span>;</span><br><span class="line"><span class="comment">-- 不用指定组名</span></span><br><span class="line"><span class="comment">-- 自动新加了一个组，组名从1开始看，哪个位置缺了，就在哪建一个组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">add</span> <span class="keyword">logfile</span> <span class="keyword">group</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 也可以指定组名（如果有多路复用，则成员数就是复用的数量）</span></span><br></pre></td></tr></table></figure>
<p>ps：如果设置了db_create_file_dest，那么这个地方也会有镜像</p>
<p>默认路径时，也会自动删除log文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">drop</span> <span class="keyword">logfile</span> <span class="keyword">group</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>设置omf路径后</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter db_create</span><br><span class="line"><span class="comment">-- 有6个备选复用地址</span></span><br><span class="line"><span class="comment">-- 新建组（加成员）的时候，会在这些路径中，每个路径放一个镜像文件成员</span></span><br><span class="line"><span class="comment">-- 要加同时加，要删同时删，仍然会覆盖omf</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> db_create_online_log_dest_1=<span class="string">'/u01/omf1'</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> db_create_online_log_dest_2=<span class="string">'/u01/omf2'</span>;</span><br><span class="line"></span><br><span class="line">         1 ONLINE</span><br><span class="line">/u01/omf1/SALES/onlinelog/o1_mf_1_h9tzk75t_.log</span><br><span class="line"></span><br><span class="line">         1 ONLINE</span><br><span class="line">/u01/omf2/SALES/onlinelog/o1_mf_1_h9tzk7by_.log</span><br><span class="line"><span class="comment">-- 这两个文件内容一样</span></span><br></pre></td></tr></table></figure>
<p>如果db_create_file_dest、db_create_online_log_dest_1参数共存</p>
<ul>
<li>
<p>两边设置的路径相同时，只有一份日志文件被写出</p>
</li>
<li>
<p>路径不同时，下面的覆盖db_create_file_dest，只有db_create_online_log_dest_1被写出</p>
</li>
</ul>
<h3 id="控制文件、归档日志文件">控制文件、归档日志文件</h3>
<p>TBS</p>
<h2 id="管理表空间和数据文件">管理表空间和数据文件</h2>
<h3 id="数据库存的结构层次">数据库存的结构层次</h3>
<img src="/2020/03/23/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86/image-20200329181135042.png" alt="image-20200329181135042" style="zoom:80%;">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oracle使用逻辑结构来管理数据存储</span><br><span class="line"></span><br><span class="line">逻辑结构        物理结构</span><br><span class="line">database   </span><br><span class="line">    |</span><br><span class="line">tablespace    --&gt;datafile (一个表空间最多有1023个数据文件)</span><br><span class="line">    |</span><br><span class="line">segment(table)</span><br><span class="line">    |</span><br><span class="line">extent</span><br><span class="line">    |</span><br><span class="line">db_block    --&gt;os_block</span><br></pre></td></tr></table></figure>
<p>表空间将相关的逻辑结构（段，区）组合在一起，表空间是数据库最大逻辑划分区域，通常用来存放数据表、索引、回滚段等数据对象，任何数据对象在创建时都必须指定存储在某个表空间中。</p>
<ul>
<li>一个数据库由一个或多个表空间构成，一个表空间只能属于一个数据库（不能跨越数据库）</li>
<li>一个表空间由一个或多个数据文件构成，一个数据文件只能属于一个表空间（数据文件也不跨越数据库）</li>
</ul>
<p>==表空间、段、区、db块都是逻辑单位==</p>
<p>按顺序访问则大的数据文件比较好，否则小的好</p>
<p>读写的最小的单位是块（Oracle数据块），哪怕访问，也是把包含这条记录的调掉进内存</p>
<h4 id="段segment">段segment</h4>
<p>一种==存储结构==</p>
<p>视图不是段，因为视图不是存储结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 段的类型（表属于段的一种）</span></span><br><span class="line">desc dba_segments</span><br><span class="line"><span class="comment">-- 查看有哪些类型的段</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">unique</span> segment_type <span class="keyword">from</span> dba_segments;</span><br><span class="line"></span><br><span class="line">SEGMENT_TYPE</span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line">LOBINDEX</span><br><span class="line">INDEX PARTITION</span><br><span class="line">TABLE SUBPARTITION</span><br><span class="line">TABLE PARTITION</span><br><span class="line">NESTED TABLE</span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"><span class="keyword">LOB</span> <span class="keyword">PARTITION</span></span><br><span class="line">LOBSEGMENT</span><br><span class="line"><span class="keyword">INDEX</span></span><br><span class="line"><span class="keyword">TABLE</span></span><br><span class="line">CLUSTER</span><br><span class="line">TYPE2 <span class="keyword">UNDO</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> selected.</span><br></pre></td></tr></table></figure>
<h6 id="表">表</h6>
<p>==表 &lt; 表空间 - 数据文件==，表空间为了放表，表空间是逻辑概念，数据文件是物理概念</p>
<p>【数据库其实就是柜子，柜中的抽屉是表空间，抽屉中的文件夹是数据文件，文件夹中的纸是表，写在纸上的信息就是数据】</p>
<ul>
<li>
<p>由操作系统识别的 – 物理</p>
</li>
<li>
<p>由数据库识别的 – 逻辑</p>
</li>
<li>
<p>数据库的物理设计 – 数据库里有哪些数据文件，应该放在什么地方，多大</p>
</li>
<li>
<p>数据库的逻辑设计 – 数据库中对象的设计（表、视图、索引等）</p>
</li>
</ul>
<p>表 table，全称为堆表 heap table（见Oracle concepts）</p>
<p>堆 - 表中的数据不是按顺序存放的，插入数据的时候，发现哪一块是空的插哪里</p>
<p>显示结果的时候，需要按顺序显示，需要排序区（在PGA中）</p>
<p>一个会话使用order by查询了，另一个会话不用order by的查询结果不会变</p>
<h6 id="簇cluster索引？？？">簇cluster索引？？？</h6>
<p>经常在一起使用的小表，放在一起【铅笔和橡皮放在一起】</p>
<p>比如说，EMP表和DEPT表，这两个表存储在不同的segment中，甚至有可能存储在不同的TABLESPACE中，因此，他们的数据一定不会在同一个BLOCK里。</p>
<p>而我们有会经常对这两个表做<strong>关联查询</strong>，比如说：select * from emp,dept where emp.deptno = dept.deptno。</p>
<p>仔细想想，查询主要是对BLOCK的操作，查询的BLOCK越多，系统IO就消耗越大。如果我把这<strong>两个表的数据聚集在少量的BLOCK里</strong>，查询效率一定会提高不少。</p>
<p>eg 快递两张表，既要知道订单信息，也要知道客户信息</p>
<p>orders customers，两个表如果属于一个簇，则用簇键连接，放到同一块里，查起来比较方便</p>
<p>建立顺序是：簇→簇表→数据→簇索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">2、创建簇（定义簇键），分配好空间</span><br><span class="line"><span class="keyword">create</span> cluster my_clu (deptno <span class="built_in">number</span> )</span><br><span class="line">    <span class="keyword">pctused</span> <span class="number">60</span></span><br><span class="line">    pctfree <span class="number">10</span></span><br><span class="line">    <span class="keyword">size</span> <span class="number">1024</span></span><br><span class="line">    <span class="keyword">tablespace</span> <span class="keyword">users</span></span><br><span class="line">    <span class="keyword">storage</span> (</span><br><span class="line">       <span class="keyword">initial</span> <span class="number">128</span> k</span><br><span class="line">       <span class="keyword">next</span> <span class="number">128</span> k</span><br><span class="line">       <span class="keyword">minextents</span> <span class="number">2</span></span><br><span class="line">       <span class="keyword">maxextents</span> <span class="number">20</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">3、创建簇表，定义哪个字段是簇键，直接放到簇空间里</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1_dept(</span><br><span class="line">      deptno <span class="built_in">number</span> ,</span><br><span class="line">      dname <span class="built_in">varchar2</span> ( <span class="number">20</span> )</span><br><span class="line">    )</span><br><span class="line">    cluster my_clu(deptno);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1_emp(</span><br><span class="line">      empno <span class="built_in">number</span> ,</span><br><span class="line">      ename <span class="built_in">varchar2</span> ( <span class="number">20</span> ),</span><br><span class="line">      birth_date <span class="built_in">date</span> ,</span><br><span class="line">      deptno <span class="built_in">number</span></span><br><span class="line">    )</span><br><span class="line">    cluster my_clu(deptno);</span><br><span class="line"></span><br><span class="line">4、为簇创建索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> clu_index <span class="keyword">on</span> cluster my_clu;</span><br></pre></td></tr></table></figure>
<h6 id="嵌套表nested-table">嵌套表nested table</h6>
<p>eg 学生表中一列【推荐图书】又是一个表</p>
<h4 id="区extent">区extent</h4>
<p>dba_extents</p>
<p>oracle==最小的空间分配单位==</p>
<p>分配的时候以区为单位，使用的时候以块为单位</p>
<p>【问爸妈要钱，百元大钞；在外花钱，以角为单位】</p>
<ul>
<li>区是由一组<strong>连续的</strong>oracle数据块所构成</li>
<li>一个或者多个数据块组成一个数据区，一个或者多个数据区再组成一个段</li>
<li>创建表的时候，从指定的表空间对应的数据文件中，拿多个区分配给表</li>
<li>当一个段中所有的空间被使用完后，oracle系统将自动分配一个新的数据区</li>
<li>Oracle就以数据区为单位进行存储空间的扩展</li>
</ul>
<h4 id="块block">块block</h4>
<p>oracle==最小的io单位==，oracle逻辑存储结构中最小的逻辑单元，不能小于操作系统块，一般为其整数倍</p>
<p>每次读记录，不是一条一条读，而是读一整块</p>
<ul>
<li>
<p>访问的数据量多，块大比较好，减少IO</p>
</li>
<li>
<p>访问的数据量少，块小比较好</p>
</li>
</ul>
<p>也是执行数据输入输出操作的最小单元</p>
<p>Oracle数据存放在“oracle数据块”中，而不是在“操作系统数据块”。</p>
<h3 id="文件部分常用数据字典-操作">文件部分常用数据字典+操作</h3>
<ol>
<li>dba_data_files 数据文件位于哪个表空间</li>
<li>dba_tables 表位于哪个表空间</li>
<li>dba_extents 表位于哪个数据文件id &amp; 位于哪个表空间</li>
</ol>
<p><strong>数据文件、临时文件</strong></p>
<ul>
<li>dba_data_files – tablespace_name, file_id, file_name, bytes</li>
<li>v$datafile – name（带路径）</li>
<li>dba_temp_files – file_name, file_id, tablespace_name, bytes, status</li>
<li>v$tempfile – name, bytes</li>
</ul>
<p>dba_data_files、v$datafile没有临时表空间的数据文件，需要在dba_temp_files、v$tempfile查找</p>
<p><strong>表、段、区</strong></p>
<ul>
<li>dba_tables – table_name, tablespace_name, owner, num_rows</li>
<li>dba_segments – owner, segment_name, tablespace_name, segment_type, bytes,</li>
<li>dba_extents – file_id, segment_name, BYTES, TABLESPACE_NAME, OWNER</li>
</ul>
<p><strong>表空间</strong></p>
<ul>
<li>
<p>dba_tablespaces – tablespace_name, contents, status, bigfile, extent_management</p>
<p>contents表空间类型，bigfile是否为大文件表空间，extent_management空间管理类型</p>
</li>
<li>
<p>v$tablespace – name</p>
<p>只能在dba_tablespaces、v$tablespace中查到临时表空间</p>
</li>
</ul>
<p><strong>数据库属性</strong></p>
<ul>
<li>
<p>database_properties – property_name, property_value</p>
<p>查看各种类型表空间的默认值</p>
<p>default_tbs_type，默认为小文件表空间</p>
</li>
<li>
<p>v$database</p>
</li>
</ul>
<p><strong>实例</strong></p>
<ul>
<li>v$instance – version, status, instance_name, instance_number, host_name</li>
</ul>
<p>查一个表位于哪个数据文件，位于哪个表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> file_name,file_id <span class="keyword">from</span> dba_data_files <span class="keyword">where</span> file_id <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> file_id <span class="keyword">from</span> dba_extents <span class="keyword">where</span> segment_name=<span class="string">'EMP'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> table_name,tablespace_name,owner <span class="keyword">from</span> dba_tables <span class="keyword">where</span> table_name=<span class="string">'EMP'</span>;</span><br></pre></td></tr></table></figure>
<p>查一个数据文件里有哪些表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select segment_name from dba_extents where file_id&#x3D;</span><br><span class="line">(select file_id from dba_data_files wherefile_name&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;sales&#x2F;users01.dbf&#39;);</span><br></pre></td></tr></table></figure>
<p>查看数据文件（临时文件比较特殊）的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tablespace_name, file_id, file_name, <span class="keyword">round</span>(<span class="keyword">bytes</span> / (<span class="number">1024</span> * <span class="number">1024</span>), <span class="number">0</span>) total_space <span class="keyword">FROM</span> dba_data_files</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablespace_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">bytes</span>/<span class="number">1024</span>/<span class="number">1024</span> <span class="keyword">as</span> <span class="string">"size(M)"</span> <span class="keyword">from</span> v$tempfile <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">bytes</span>;</span><br></pre></td></tr></table></figure>
<h3 id="表空间的类型（创建-alter设默认）">表空间的类型（创建&amp;alter设默认）</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看表空间</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">tablespace</span>;</span><br><span class="line">NAME</span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line">SYSTEM 放系统数据，不要把用户数据放到系统表空间，增加负担</span><br><span class="line">SYSAUX 放自动化管理的元数据</span><br><span class="line">辅助系统表空间，10g版本之后增加了自管理自优化功能，相关数据单独放出来了，不再放在system中</span><br><span class="line">UNDOTBS1 放回滚数据（撤销表空间）</span><br><span class="line">TEMP 临时表空间？？？</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表空间的类型</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name,<span class="keyword">contents</span> <span class="keyword">from</span> dba_tablespaces;</span><br></pre></td></tr></table></figure>
<h4 id="常规表空间">常规表空间</h4>
<p>（可读可写）permanent， 存放永久性数据，如表，索引等</p>
<p><strong>创建users表空间并设为数据库默认的表空间</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col property_name for a50</span><br><span class="line"><span class="keyword">select</span> property_name,property_value <span class="keyword">from</span> database_properties;</span><br><span class="line"><span class="comment">-- 查看各种类型默认表空间，现在在system</span></span><br><span class="line">DEFAULT_PERMANENT_TABLESPACE</span><br><span class="line">DEFAULT_TEMP_TABLESPACE</span><br><span class="line">DEFAULT_TBS_TYPE <span class="comment">-- 默认的表空间类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/user01.dbf'</span> <span class="keyword">size</span> <span class="number">20</span>m;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">default</span> <span class="keyword">tablespace</span> <span class="keyword">users</span>;<span class="comment">-- 设为默认，以后创建表时不指定，就放在users表空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看默认表空间，发现已修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> tablespace_name <span class="keyword">from</span> dba_tables <span class="keyword">where</span> table_name=<span class="string">'EMP'</span>; <span class="comment">-- 查看一个表所属的表空间</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.emp <span class="keyword">move</span> <span class="keyword">tablespace</span> <span class="keyword">users</span>; <span class="comment">-- 将表移到其他表空间</span></span><br></pre></td></tr></table></figure>
<h4 id="大小文件表空间">大小文件表空间</h4>
<p>创建tablespace默认就是smallfile类型的</p>
<p>一个bigfile表空间，大小是【无限】的，只能放一个数据文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建Oracle小文件 表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> <span class="keyword">smallfile</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/tbs1.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看是不是大文件表空间</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">bigfile</span> <span class="keyword">from</span> dba_tablespaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/tbs1.dbf'</span> <span class="keyword">size</span> <span class="number">20</span>m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">smallfile</span> <span class="keyword">tablespace</span> smalltbs <span class="keyword">datafile</span> </span><br><span class="line"><span class="string">'/u01/app/oracle/oradata/sales/small01.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m,</span><br><span class="line"><span class="string">'/u01/app/oracle/oradata/sales/small02.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会报错，因为一个大文件表空间只能放一个数据文件</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">bigfile</span> <span class="keyword">tablespace</span> bigtbs <span class="keyword">datafile</span></span><br><span class="line"><span class="string">'/u01/app/oracle/oradata/sales/big01.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m,</span><br><span class="line"><span class="string">'/u01/app/oracle/oradata/sales/big02.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">bigfile</span> <span class="keyword">tablespace</span> bigtbs <span class="keyword">datafile</span></span><br><span class="line"><span class="string">'/u01/app/oracle/oradata/sales/big01.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看是大文件还是小文件表空间</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name,<span class="keyword">bigfile</span> <span class="keyword">from</span> dba_tablespaces;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blocksize 2k;-- 表空间块大小2k不匹配内存中没有地方可以放2k的块</span><br><span class="line">  show parameter cache -- db_2k_cache_size   value&#x3D;0</span><br><span class="line">alter system set db_2k_cache_size &#x3D; 16m; --在内存开辟一个16m</span><br><span class="line">create tablespace smalltbs datafile&#39;F:&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;demo&#x2F;small01.dbf&#39; size 10m</span><br><span class="line">blocksize 2k;</span><br><span class="line">create tablespace bigtbs datafile&#39;F:&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;demo&#x2F;big01.dbf&#39; size 10m</span><br><span class="line">blocksize 16k;  --创建大块</span><br></pre></td></tr></table></figure>
<h4 id="撤销表空间">撤销表空间</h4>
<p>（放回滚数据）undo 保存数据修改前的镜象</p>
<p>回滚段在这个表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter undo_tablespace <span class="comment">--undo为当前表空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建撤销表空间undotbs2且设为数据库默认的撤销表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">undo</span> <span class="keyword">tablespace</span> undotbs2 <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/undotbs02.dbf'</span></span><br><span class="line"><span class="keyword">size</span> <span class="number">20</span>m;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> undo_tablespace=undotbs2; <span class="comment">-- 修改初始化参数——默认撤销表空间</span></span><br><span class="line"><span class="keyword">show</span> parameter undo_tablespace <span class="comment">-- 已修改</span></span><br></pre></td></tr></table></figure>
<h4 id="临时表空间">临时表空间</h4>
<p>排序用的</p>
<p>内存不够用的话，就在这个空间排序。不能存放永久性对象，用于保存数据库排序，分组时产生的临时数据</p>
<p>数据文件不等同于临时文件，虽然后缀都是dbf</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tablespace_name,<span class="keyword">contents</span> <span class="keyword">from</span> dba_tablespaces;  <span class="comment">--查看表空间类型</span></span><br><span class="line"><span class="keyword">show</span> parameter default_temporary_tablespace</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建临时表空间tempdef并设为数据库默认的临时表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">tablespace</span> tempdef tempfile <span class="string">'/u01/app/oracle/oradata/sales/tempdef.dbf'</span> <span class="keyword">size</span> <span class="number">20</span>m;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">default</span> <span class="keyword">temporary</span> <span class="keyword">tablespace</span> tempdef; <span class="comment">-- 设置默认</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> property_name,property_value <span class="keyword">from</span> database_properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为临时表空间添加临时数据文件</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> temp <span class="keyword">ADD</span> TEMPFILE <span class="string">'/u01/app/oracle/oradata/sales/temp01.dbf'</span> <span class="keyword">SIZE</span> <span class="number">20</span>m;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> temp <span class="keyword">ADD</span> TEMPFILE <span class="string">'/u01/app/oracle/oradata/sales/temp02.dbf'</span> <span class="keyword">SIZE</span> <span class="number">20</span>m;</span><br><span class="line"><span class="comment">-- 设置omf之后，不用指定路径和文件名也可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除临时数据文件</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> temp <span class="keyword">drop</span> TEMPFILE [file_id]; <span class="comment">-- 或者是文件路径</span></span><br></pre></td></tr></table></figure>
<h4 id="临时表空间组">临时表空间组</h4>
<p>适用：多个用户同时访问一个（临时）表空间，产生争用</p>
<p>打包多个临时表空间，不同表空间放在不同磁盘上，不同用户使用不同的临时表空间，减少争用</p>
<p>不需要创建和删除组</p>
<p>有成员-自动有组，没有成员-组自动消失</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看临时表空间组，和内部的成员</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_tablespace_groups;</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 如果有成员，组自动创建；如果没有成员，组自动删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> temp <span class="keyword">tablespace</span> <span class="keyword">group</span> group1; <span class="comment">-- 将temp加到group1中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建临时表空间的时候就加入组中</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">tablespace</span> temp1 tempfile <span class="string">'/u01/app/oracle/oradata/sales/temp101.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m <span class="keyword">tablespace</span> <span class="keyword">group</span> group1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">tablespace</span> temp2 tempfile <span class="string">'/u01/app/oracle/oradata/sales/temp201.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m <span class="keyword">tablespace</span> <span class="keyword">group</span> group1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将默认临时表空间设置为group1</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">default</span> <span class="keyword">temporary</span> <span class="keyword">tablespace</span> group1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表空间信息</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name,<span class="keyword">contents</span> <span class="keyword">from</span> dba_tablespaces;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将temp1加到group2中</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> temp1 <span class="keyword">tablespace</span> <span class="keyword">group</span> group2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将temp2退出临时表空间组</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> temp2 <span class="keyword">tablespace</span> <span class="keyword">group</span> <span class="string">''</span>;</span><br></pre></td></tr></table></figure>
<h3 id="表空间的空间管理">表空间的空间管理</h3>
<p>（区的管理？？？）了解一下</p>
<ul>
<li>字典管理：全库所有的空间分配都放在数据字典中。容易引起字典争用，而导致性能问题。</li>
<li>本地管理：空间分配不放在数据字典，而在每个数据文件头部的第3到第8个块的位图块，来管理空间分配。</li>
</ul>
<h4 id="本地管理">本地管理</h4>
<p>有关区可用或者不可用的信息存储在数据文件，每个数据文件的头部都放了一个位图</p>
<p>就是01组成的图，0表示可用，1表示区已经被分配</p>
<p>==本地管理的优点==</p>
<ol>
<li>减少对数据字典表的增用</li>
<li>增加或者减少空间需要修改数据字典，会有回滚</li>
<li>不用碎片的合并</li>
<li>每个区是一样大的</li>
</ol>
<h4 id="数据字典管理（不太用了）">数据字典管理（不太用了）</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看是本地管理还是数据字典管理</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name,extent_management <span class="keyword">from</span> dba_tablespaces;</span><br><span class="line"><span class="comment">-- 注意system表空间的管理方式是local还是dictionary</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据字典方式管理的表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> userdata <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/userdata01.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m <span class="keyword">extent</span> <span class="keyword">management</span> dictionary;</span><br></pre></td></tr></table></figure>
<p>建不好的原因：system表空间的管理方式是local</p>
<p>如果system是本地管理的，则只能创建本地管理表空间</p>
<p>是字典管理，则两个都可以</p>
<h3 id="表空间的状态">表空间的状态</h3>
<p>1）联机可读写online</p>
<p>2）只读read only（数据文件只读）</p>
<p>3）脱机offline【驱动程序卸载之后，设备还在，但是不能访问管理】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> [表空间名] <span class="keyword">offline</span>;<span class="comment">--只可对临时文件脱机，不可对临时表空间脱机</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> [数据文件名] <span class="keyword">offline</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> [表空间名] <span class="keyword">read</span> write;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> [表空间名] <span class="keyword">read</span> <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>
<p>将表空间改为只读：修改完成后</p>
<p>不可对表进行插入记录/删字段，可查+增加字段+删表（不涉及表空间的操作，只修改数据字典的操作）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.demo1(<span class="keyword">id</span> <span class="built_in">int</span>) <span class="keyword">tablespace</span> tbs1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.demo1 <span class="keyword">values</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> checkpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">read</span> <span class="keyword">only</span>;</span><br><span class="line"><span class="keyword">select</span> tablespace_name,<span class="keyword">status</span> <span class="keyword">from</span> dba_tablespaces; <span class="comment">-- 查询表空间状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.demo2(<span class="keyword">id</span> <span class="built_in">int</span>) <span class="keyword">tablespace</span> tbs1;  <span class="comment">--不能增加一个表</span></span><br><span class="line"><span class="keyword">show</span> parameter defer</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> deferred_segment_creation=<span class="literal">true</span>;<span class="comment">-- 延迟分配</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.demo2(<span class="keyword">id</span> <span class="built_in">int</span>) <span class="keyword">tablespace</span> tbs1; <span class="comment">-- 并没有分配表空间，只是有了一个表的定义</span></span><br><span class="line"><span class="keyword">select</span> segment_name <span class="keyword">from</span> dba_segments <span class="keyword">where</span> segment_name=<span class="string">'DEMO2'</span>; <span class="comment">-- 空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.demo1 <span class="keyword">values</span>(<span class="number">200</span>); <span class="comment">-- 不能插数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.demo1 <span class="keyword">add</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>);      <span class="comment">--可增加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.demo2 <span class="keyword">add</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>);      <span class="comment">--可增加字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.demo1 <span class="keyword">drop</span> <span class="keyword">column</span> <span class="keyword">name</span>;          <span class="comment">--不可删除某一字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> scott.demo2 <span class="keyword">drop</span> <span class="keyword">column</span> <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> scott.demo1; <span class="comment">--可删表，这里删了之后物理文件上还有？？？</span></span><br><span class="line"><span class="keyword">select</span> segment_name <span class="keyword">from</span> dba_segments <span class="keyword">where</span> segment_name=<span class="string">'DEMO1'</span>; <span class="comment">-- 没了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.demo2 <span class="keyword">values</span>(<span class="number">200</span>); <span class="comment">-- 此时还是没有分配空间，重启也没用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这张表有了说明就分配空间了</span></span><br><span class="line"><span class="keyword">select</span> segment_name <span class="keyword">from</span> dba_segments <span class="keyword">where</span> segment_name=<span class="string">'DEMO2'</span>; </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> tbs1 <span class="keyword">read</span> write; <span class="comment">-- 改了之后就把demo1删了？？？</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> deferred_segment_creation=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.demo2 <span class="keyword">values</span>(<span class="number">200</span>,<span class="string">'hahaha'</span>); <span class="comment">-- 插入数据时才分配空间，段表里也有定义了</span></span><br></pre></td></tr></table></figure>
<p>（考试选择题）不能脱机的3个表空间：</p>
<ol>
<li>system表空间，系统数据一定要用。eg select的时候，首先要查数据字典，看这个表是否存在</li>
</ol>
<p>数据字典在里面除非shutdown，系统表空间不可脱机</p>
<ol start="2">
<li>
<p><strong>当前的</strong>撤销表</p>
</li>
<li>
<p>临时表空间</p>
</li>
</ol>
<p>其他表空间都是可以脱机的</p>
<ul>
<li>sysaux可脱机，辅助系统表空间，但脱了就不能用自优化自管理（10g之后增强了）自动化功能了</li>
<li>非当前撤销表空间可以脱</li>
<li>只可对临时文件脱机，不可对临时表空间脱机（无论是否是当前使用的）</li>
</ul>
<h3 id="删除表空间">删除表空间</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只有空的表空间才能删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> smalltbs; <span class="comment">-- 删除表空间后，对应的数据文件还在，要手动删除</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> bigtbs;  <span class="comment">--如果表空间有表（表里有无记录无所谓），则不能删</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- contents指表空间中所有表的定义和所有记录</span></span><br><span class="line"><span class="comment">-- datafiles指这个表空间对应的所有数据文件</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> bigtbs <span class="keyword">including</span> <span class="keyword">contents</span> <span class="keyword">and</span> <span class="keyword">datafiles</span>; <span class="comment">-- 表的定义、内容+数据文件一块删掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果开了omf，不加datafiles也会帮你删掉数据文件，content呢？？？</span></span><br></pre></td></tr></table></figure>
<p>==create和drop都是DDL语句，只对数据字典操作==，不会涉及物理文件</p>
<p>DDL – 数据定义，只对数据字典操作</p>
<ul>
<li>create只是增加定义【公司招聘】</li>
<li>delete只是删除定义【公司开除一个人，没有把他物理上消灭】</li>
</ul>
<h3 id="扩展表空间大小">扩展表空间大小</h3>
<p>表空间大小 == 包含数据文件大小的和</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查出来每个表空间对应的大小</span></span><br><span class="line"><span class="keyword">SELECT</span> t.tablespace_name, <span class="keyword">round</span>(<span class="keyword">SUM</span>(<span class="keyword">bytes</span> / (<span class="number">1024</span> * <span class="number">1024</span>)), <span class="number">0</span>) ts_size</span><br><span class="line"><span class="keyword">FROM</span> dba_tablespaces t, dba_data_files d</span><br><span class="line"><span class="keyword">WHERE</span> t.tablespace_name = d.tablespace_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.tablespace_name;</span><br></pre></td></tr></table></figure>
<ol>
<li>修改表空间中原数据文件大小</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 手动扩展：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/user01.dbf'</span> <span class="keyword">resize</span> <span class="number">30</span>m;</span><br><span class="line"><span class="comment">-- 自动扩展：（一次增加5m）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/user01.dbf'</span> <span class="keyword">autoextend</span> <span class="keyword">on</span> <span class="keyword">next</span> <span class="number">10</span>m <span class="keyword">maxsize</span> <span class="number">500</span>m;</span><br><span class="line"><span class="comment">-- 关掉自动扩展</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/user01.dbf'</span> <span class="keyword">autoextend</span> <span class="keyword">off</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>给表空间增加新数据文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> tbs <span class="keyword">add</span> <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/sales/user02.dbf'</span> <span class="keyword">size</span> <span class="number">20</span>m;</span><br></pre></td></tr></table></figure>
<h3 id="数据文件的移动或重命名">数据文件的移动或重命名</h3>
<p>12c之前按旧方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>; <span class="comment">--所有的数据文件在哪（来自控制文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.将表空间脱机</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">offline</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.将数据文件在os移到别的目录下（这里也可以改名）</span></span><br><span class="line"><span class="comment">-- alter tablespace users online; --这里会失败，Oracle还是按照控制文件中的路径去找的数据文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.Oracle是不知道的，所以要改控制文件，二进制不能手动改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">rename</span> <span class="keyword">file</span> <span class="string">'/u01/app/oracle/oradata/sales/users02.dbf'</span> <span class="keyword">to</span> <span class="string">'/u01/users02.dbf'</span>;<span class="comment">--第二处写新的文件路径（可能重命名）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>; <span class="comment">-- 控制文件变化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> <span class="keyword">users</span> <span class="keyword">online</span>; <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure>
<p>新方法（12c后可以online移动）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 物理上也移动了，原来文件没有了，相当于移动</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">move</span> <span class="keyword">datafile</span> <span class="string">'/u01/users02.dbf'</span> <span class="keyword">to</span> <span class="string">'/u01/app/oracle/oradata/sales/users02.dbf'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加keep原来文件还有，相当于复制</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">move</span> <span class="keyword">datafile</span><span class="string">'D:app/omf/data01.dbf'</span> <span class="keyword">to</span></span><br><span class="line"><span class="string">'D:app/oracle/oradata/demo/userdata01.dbf'</span> <span class="keyword">keep</span>;</span><br></pre></td></tr></table></figure>
<h3 id="没有备份（归档模式）恢复数据文件">没有备份（归档模式）恢复数据文件</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在userdata表空间下创建一张新表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.demo3(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)) <span class="keyword">tablespace</span> userdata;</span><br><span class="line"><span class="keyword">select</span> segment_name <span class="keyword">from</span> dba_extents <span class="keyword">where</span> file_id=</span><br><span class="line"> (<span class="keyword">select</span> file_id <span class="keyword">from</span> dba_data_files <span class="keyword">where</span> file_name=<span class="string">'/u01/app/oracle/oradata/sales/userdata01.dbf'</span>); <span class="comment">-- 创建成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.demo3 <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.demo3 <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Jerry'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> checkpoint;</span><br><span class="line">shutdown immediate</span><br><span class="line"><span class="comment">-- os中删掉'/u01/app/oracle/oradata/sales/userdata01.dbf'</span></span><br><span class="line">startup <span class="comment">-- 报错没有一个数据文件，无法启动，只能起到mount阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先将数据文件脱机，open数据库，打开再慢慢恢复</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> [file_id] <span class="keyword">offline</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个数据文件</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">create</span> <span class="keyword">datafile</span> [file_id];</span><br><span class="line"><span class="comment">-- 试着将这个文件联机，失败</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> [file_id] <span class="keyword">online</span>;</span><br><span class="line"></span><br><span class="line">ORA-01113: file 6 needs media recovery</span><br><span class="line">ORA-01110: data file 6: '/u01/app/oracle/oradata/sales/userdata01.dbf'</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不采用备份的恢复（因为这个新的数据文件处于基线以下，需要使用归档日志）</span></span><br><span class="line">recover datafile 6;</span><br><span class="line">Specify log: &#123;&lt;RET&gt;=suggested | filename | AUTO | CANCEL&#125;</span><br><span class="line"></span><br><span class="line">ORA-00279: <span class="keyword">change</span> <span class="number">794281</span> <span class="keyword">generated</span> <span class="keyword">at</span> <span class="number">03</span>/<span class="number">27</span>/<span class="number">2020</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">48</span> needed <span class="keyword">for</span> <span class="keyword">thread</span> <span class="number">1</span></span><br><span class="line">ORA<span class="number">-00289</span>: suggestion : /u01/arch/<span class="number">2</span>/<span class="number">1</span>_8_1036012339.arc</span><br><span class="line">ORA<span class="number">-00280</span>: <span class="keyword">change</span> <span class="number">794281</span> <span class="keyword">for</span> <span class="keyword">thread</span> <span class="number">1</span> <span class="keyword">is</span> <span class="keyword">in</span> <span class="keyword">sequence</span> <span class="comment">#8</span></span><br><span class="line"><span class="comment">-- 输入auto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> [file_id] <span class="keyword">online</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.demo3; <span class="comment">-- 数据恢复成功</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 服务器架构</title>
    <url>/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><strong>服务器</strong>：提供服务的计算机，计算机经过优化处理，在某方面功能强大</p>
<p><strong>文件服务器</strong>：存储容量强</p>
<p><strong>应用服务器</strong>：CPU、内存强</p>
<p><strong>Oracle服务器</strong>干两件事：**数据存储（database）、数据处理（instance）**功能强大的计算机</p>
<a id="more"></a>
<p>==Oracle服务器 == instance + database== + 管理数据库的软件？</p>
<ol>
<li>instance【播放器（打开需要内存）】【数据处理】【安装了Oracle软件的计算机】</li>
<li>database【视频文件】【数据存储】【物理文件的集合】</li>
</ol>
<ul>
<li>instance总是打开一个且仅一个db</li>
<li>但一个db可以被多个实例装载和打开</li>
</ul>
<p>先装instance，再装database，否则会建库失败</p>
<p>两者不是绑定的【视频文件不和播放器绑定】</p>
<p>互相独立可以分离，数据库一般在raid阵列卡上</p>
<p><strong>集群（冗余机制）</strong></p>
<ul>
<li>设置多个冗余节点（一台Oracle服务器）</li>
<li>节点之间有心跳线，隔一段时间发一个信号，告诉别人我还活着</li>
<li>一台机器坏了，心不跳了，另一台就来接管</li>
</ul>
<img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200303145045139.png" alt="image-20200303145045139" style="zoom:75%;">
<h2 id="Oracle-instance">Oracle instance</h2>
<ul>
<li>翻译：例程（例行程序，示例程序）</li>
<li>通过例程访问数据库</li>
<li>例程进行数据处理工作</li>
</ul>
<p>==实例 == 内存结构 + 一组后台进程==</p>
<h3 id="内存结构">内存结构</h3>
<p>==内存 == 系统全局区域SGA + 程序全局区域PGA==</p>
<h4 id="SGA">SGA</h4>
<p>system global area，系统全局区域【分支机构都能访问的】</p>
<p>系统：遵循统一标准的集合，不同系统标准不同【教育系统，银行系统】</p>
<p><strong>例程下可以有很多会话</strong></p>
<ul>
<li>
<p>都在db12c同一个系统下，例程级别</p>
</li>
<li>
<p>instance启动时，根据初始化参数配置，向OS申请内存，所有会话可以共享（v$session）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> USERNAME,<span class="keyword">sid</span> <span class="keyword">from</span> v$<span class="keyword">session</span> <span class="keyword">where</span> username=<span class="string">'SCOTT'</span>;</span><br><span class="line"><span class="comment">-- 当scott用户连上时，会查到，且conn重连之后SID会变化</span></span><br><span class="line"><span class="comment">-- scott用户、SYS用户（总是比连接数多一个？谁？）可以通过多个会话连接，SID不同</span></span><br><span class="line"><span class="comment">-- 为什么用system as sysdba连上的用户是sys？？？</span></span><br><span class="line"><span class="comment">-- instance_name、ORACLE_SID，两者都表示oracle实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前会话的SID</span></span><br><span class="line"><span class="keyword">SELECT</span> USERENV(<span class="string">'SID'</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> INSTANCE_NUMBER <span class="keyword">from</span> v$<span class="keyword">instance</span>; <span class="comment">-- 同一个例程（sales）不同会话查到的这个视图相同</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不同数据库的内存不能共享，别的系统又有自己的一套内存</p>
</li>
<li>
<p>一个用户select之后，文件留在内存（SGA），下一个用户读取就直接从内存获得内容</p>
</li>
</ul>
<p>详细讲表 - 见Oracle知识点一栏</p>
<h5 id="1-共享池">1 共享池</h5>
<p>==共享池 == 库缓存 + 数据字典缓存==</p>
<h6 id="a-库缓存：存放代码">a 库缓存：存放代码</h6>
<p>代码放在这里（执行计划）（包括解析好的代码、DLL）</p>
<p>sql为描述性语言，所以需要解析（成cpu能执行的代码）</p>
<p>语法分析 - 语义分析 - 权限分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- scott下</span><br><span class="line">select * fom scott.emp; -- 语法不对</span><br><span class="line">select * from scott.hhh; -- 语义不对，对象不存在</span><br><span class="line">-- hr下</span><br><span class="line">select * fom scott.emp; -- 对象存在，但是没有select的权限，视为不存在</span><br></pre></td></tr></table></figure>
<p>都通过的话会生成<strong>执行计划</strong>，选择一个最优的计划解析成cpu能执行的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autot on -- 可以看到执行过程？？？</span><br></pre></td></tr></table></figure>
<p>每次都这样走一遍流程太慢，将解析好的代码放在内存，下次执行很快</p>
<p>每次解析SQL效率太低，在内存（共享池）中保存已经解析好的代码，避免重复解析</p>
<p>库缓存还能细分：</p>
<ul>
<li>sql区，缓存sql语句的</li>
<li>dlsql区，缓存sql语句块的</li>
<li>还有别的语言对应的代码</li>
</ul>
<h6 id="b-数据字典缓存：存放系统数据">b 数据字典缓存：存放系统数据</h6>
<p>Oracle并没有给出直接设置数据字典高速缓存大小的方法，只能通过设置共享池的大小来间接地设置数据字典高速缓存的大小。</p>
<p>数据分为</p>
<ul>
<li>
<p>系统数据（被Oracle维护和处理）== 数据字典 == 描述数据的数据 == 元数据 == 数据目录（编目）</p>
<p>系统数据放在数据字典缓存中</p>
<p>表上有没有索引，主键，约束等</p>
<p>数据库安装完本身带了一些包（desc dbms_xdb 很多存储过程函数）</p>
</li>
<li>
<p>用户数据（被用户维护和处理的）</p>
<p>用户数据放在数据库高速缓存中</p>
</li>
</ul>
<h5 id="2-数据库高速缓存池：存放用户数据">2 数据库高速缓存池：存放用户数据</h5>
<p>存一些select的结果</p>
<p>【共享池】和【数据库高速缓存池】占90%空间</p>
<p>ps：这4个池之外的其他的池都是可选的</p>
<ul>
<li>java池，编译完了放在这里 - 通过java应用访问数据库时才需要</li>
<li>通过c，没有c池。Oracle和微软对头，和sum好</li>
</ul>
<h5 id="2-5-事务">2.5 事务</h5>
<p>事务的ACID准则：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)</p>
<p><strong>原子性</strong></p>
<p>【转账：一边少钱，一边多钱】【存钱：口袋里掏钱，存折里多钱】</p>
<p>要不都做，要不都不做</p>
<p>事务必须commit或者rollback，查询不是事务</p>
<p><strong>一致性</strong></p>
<p>保证事务只能把数据库从一个一致状态，“转移”到另一个一致状态</p>
<p>开始之前和结束之后，数据库要处于一致状态</p>
<blockquote>
<p><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Consistency_(database_systems)">Consistency</a> ensures that a transaction can <strong>only bring the database from one valid state to another</strong>, maintaining database <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Invariant_(computer_science)">invariants</a>: <strong>any data written to the database must be valid according to all defined rules, including <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Integrity_constraints">constraints</a>, <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cascading_rollback">cascades</a>,<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Database_trigger">triggers</a>, and any combination thereof.</strong> This prevents database corruption by an illegal transaction, but does <strong>not guarantee that a transaction is *correct*.</strong></p>
</blockquote>
<p>我对这段话的理解：</p>
<ul>
<li>数据库事务的一致性是指：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态。那么，什么是数据库的有效(正确）的状态？满足给这个数据库pre-defined的一些规则的状态都是 valid 的。这些规则有哪些呢，比如说<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Integrity_constraints">constraints</a>, <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cascading_rollback">cascades</a>,<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Database_trigger">triggers</a> 及它们的组合等。具体到某个表的某个字段，比如你在定义表的时候，给这个字段的类型是number类型，并且它的值不能小于0，那么你在某个 transaction 中给这个字段插入（更改）为一个 String 值或者是负值是不可以的，这不是一个“合法”的transaction，也就是说它不满足我们给数据库定义的一些规则（约束条件）。</li>
<li>“This prevents database corruption by an illegal transaction, but does <strong>not guarantee that a transaction is *correct*. ”</strong> 这又怎么理解呢？在数据库的角度来看，它只关心 transaction 符不符合定义好的规则，符合的就是legal的，不符合的就是illegal的。transaction 是否正确是从应用层的角度来看的，数据库并不知道你应用层的逻辑意义，它不保证应用层的transaction的正确性，这个逻辑正确性是由应用层的programmer来保证的。 这么说估计还是抽象，那么看下面我们熟知的转账的例子。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Table： Account</span><br><span class="line">Columns:   Name(string), Balance（int)</span><br><span class="line">约束条件：无</span><br><span class="line"></span><br><span class="line">执行下面一个事务(A,B的初始余额均为1000，A给B转账1200）</span><br><span class="line"></span><br><span class="line">1.  往表Account插入数据（A,1000)</span><br><span class="line">2. 往表Account插入数据 （B,1000)</span><br><span class="line">3. A给B转账1200，更新A的余额为-200，（A,-200)</span><br><span class="line">4. B的余额增加1200，更新B的余额为2200（B,2200)</span><br></pre></td></tr></table></figure>
<p>那么，数据库会认为这个 transaction 合不合法呢？也就是它满不满足我们给数据库的定义的规则呢？答案就是这个 transaction 是合法的，因为你定义表的时候没有约定 Balance 不能小于0。虽然我们从应用层的角度来看，这个transaction是不正确的，因为它不符合逻辑- balance不能小于0.  但我们数据库只关心你的 transaction 满不满足你的数据库定义的rule，不关心它具有什么业务的逻辑，这个业务逻辑是应该由应用层来理解并处理的。</p>
<p>修改一下上面这个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Table： Account</span><br><span class="line">Columns:   Name(string), Balance（int)</span><br><span class="line">约束条件：Balance &gt;&#x3D; 0</span><br><span class="line"></span><br><span class="line">执行下面一个事务(A,B的初始余额均为1000，A给B转账1200）</span><br><span class="line"></span><br><span class="line">1.  往表Account插入数据（A,1000)</span><br><span class="line">2. 往表Account插入数据 （B,1000)</span><br><span class="line">3. A给B转账1200，更新A的余额为-200，（A,-200)</span><br><span class="line">4. B的余额增加1200，更新B的余额为2200（B,2200)</span><br></pre></td></tr></table></figure>
<p>注意，这里增加了约束条件Balance &gt; 0, 上面的这个transaction违反了规则Balance&gt;=0，那么这个事务数据库认为它是非法的，不满足一致性的要求，所以数据库执行这个事务会失败。</p>
<p>最后请再认真研读一下链接 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Consistency_(database_systems)">Consistency (database systems) </a>中的这段话。</p>
<blockquote>
<p>This(Consistency）does not guarantee correctness of the transaction in all ways the application programmer might have wanted (that is the responsibility of application-level code) but merely that any programming errors cannot result in the violation of any defined database constraints.[1]</p>
</blockquote>
<p><strong>读的一致性？？？</strong></p>
<p>事务开始之前和结束之后，数据库要处于一致状态</p>
<p>别的数据库，事务未结束时，给表加锁，别的用户不能访问</p>
<p>eg</p>
<p>一个会话update，未commit；另一个会话访问的是旧数据</p>
<p>oracle的读一致性 – 修改时，脏数据先在高速缓存中；别的用户在回滚段中访问旧数据，不用等事务结束</p>
<p><strong>隔离性</strong></p>
<p>只能看到事务开始和结束的状态，中间状态是看不见的</p>
<p>用锁实现</p>
<p>当事务t1进行数据修改的时候，会将数据复制到回滚带上，如果另外的事务前来查询发现（高速缓存中的）数据被锁，会到回滚带上查询</p>
<p><strong>持久性</strong></p>
<ul>
<li>
<p>持久 - 外存</p>
</li>
<li>
<p>临时 - 内存</p>
</li>
</ul>
<p>commit之后，通知LGWR将重做日志缓存，写入重做日志文件中</p>
<p>checkpoint之后，将数据库高速缓存中的脏数据，写入数据文件中</p>
<h5 id="3-重做日志缓存池">3 重做日志缓存池</h5>
<p>重做日志作用：恢复</p>
<p>==日志，记录事务==，不是增删改等细化的操作（这些操作属于事务）</p>
<ul>
<li>恢复redo，做对的事务再来一遍。【insert了100条数据，不知道什么原因没了，需要redo】</li>
<li>撤销undo，把做错的东西撤销（对冲）掉</li>
</ul>
<p>出了问题，先restore最近的备份，再用重做日志将这些事务重做一遍（recover）</p>
<p>演示：出问题</p>
<p>创建表空间、数据文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> demo <span class="keyword">datafile</span> <span class="string">'/u01/app/oracle/oradata/db12c/demo01.dbf'</span> <span class="keyword">size</span> <span class="number">10</span>m; <span class="comment">-- 同时，创建表空间数据文件？？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- scott为所有者</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.st(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)) <span class="keyword">tablespace</span> demo; <span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.st <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> scott.st <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Jerry'</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.st;</span><br><span class="line"></span><br><span class="line">desc [表名] <span class="comment">-- 查表的数据模式</span></span><br><span class="line">desc dba_data_files <span class="comment">-- 查数据文件</span></span><br><span class="line">desc v$datafile;</span><br><span class="line">desc dba_tables <span class="comment">-- 查表和所属的表空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> file_name, tablespace_name <span class="keyword">from</span> dba_data_files <span class="keyword">where</span> tablespace_name <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> tablespace_name <span class="keyword">from</span> dba_tables <span class="keyword">where</span> table_name=<span class="string">'ST'</span>);</span><br><span class="line"><span class="comment">-- 先查到这个表在哪个表空间，再看这个表空间在哪个数据文件</span></span><br><span class="line"><span class="comment">--sysaux01.dbf这里也有st表？？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- insufficient privilege，conn / as sysdba重连一下就好了</span></span><br></pre></td></tr></table></figure>
<p><strong>将数据文件删除，利用日志文件恢复</strong></p>
<p>因为表的数据在缓存里，首先要shutdown immediate，会将数据库高速缓存池中脏数据写盘，清空</p>
<p>再模拟数据丢失（在os级别rm demo01.dbf数据文件）</p>
<p>再startup时会报错，缺少数据文件，Oracle以为还有这个文件</p>
<p>【单位的人在外面被干掉了，单位还以为有这个人，被开除了就认为没了】</p>
<img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200325233435103.png" alt="image-20200325233435103" style="zoom:67%;">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">file</span><span class="comment">#,name from v$datafile; -- 查看几号文件和具体路径</span></span><br></pre></td></tr></table></figure>
<p>用日志恢复，recover要有被恢复的对象（demo01.dbf）</p>
<p>所以要创建一个文件，但又不能再os级别上创建，这样Oracle不认识</p>
<p>在Oracle下创建，缺哪个建那个（不过建完这个数据文件是空的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">create</span> <span class="keyword">datafile</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>有了dbf文件基础，可以开始用日志recover</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">recover datafile 5;</span><br></pre></td></tr></table></figure>
<p>再把数据库打开</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>
<p>就能查到信息了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.st;</span><br></pre></td></tr></table></figure>
<p>LGWR（log writer，后台进程之一）：将SGA中的重做日志缓存写入到磁盘中</p>
<p>在shutdown时，会把重做日志缓存池写磁盘，恢复见上面的例子</p>
<h6 id="重做日志缓冲区的内容">重做日志缓冲区的内容</h6>
<p>A. 对于每个dml或ddl<strong>语句</strong>，oracle服务器进程都会把用户内存空间的重做条目复制到重做日志缓冲区上</p>
<p>B. 重做条目包含：用于重做或重构dml或ddl操作对数据库所做更改的所需的信息，用于恢复数据库，并占据日志缓冲区的连续的有序的空间</p>
<h6 id="lgwr进程">lgwr进程</h6>
<p>那缓冲区满了，该怎么办呢？这就需要lgwr进程来行动了</p>
<p>A. lgwr进程负责把重做日志缓冲区的内容写到磁盘上的活动的联机重做日志文件(或活动组的成员),他写入     自上次写入后的所有复制到缓冲区的条目</p>
<p>B. 重做日志缓冲区是一个循环的缓冲区，oracle服务器进程（非LGWR，LGWR是后台进程）负责把重做的条目覆盖重做日志缓冲区的已经写入磁盘的条目，lgwr的写入速度是非常快的，以确保重做日志缓冲区总有写入新条目的空间</p>
<h6 id="触发LGWR开始工作的动作">触发LGWR开始工作的动作</h6>
<p>A. 重做日志缓冲区的已使用的空间达到三分之一时<br>
B. 当dbwn进程向磁盘写入已修改的缓冲区的时候<br>
C. 每隔3秒钟<br>
D. 用户提交事务处理时的一条提交记录(经常commit会及时刷新重做日志缓冲区空间)</p>
<h4 id="PGA">PGA</h4>
<p>program global area，程序全局区域，创建会话时才初始化（程序==会话？？？）</p>
<p>eg 表和堆表，排序区（order by子句）</p>
<ul>
<li>数据在表里一般不是顺序放的，顺序导致效率差。插数据时，哪里空插哪里</li>
<li>不是顺序放的，但需要按某种顺序显示</li>
<li>一个会话中order by了，另一个会话不会被影响</li>
<li>变量（declare）、游标在PGA中，会话之间不能共享</li>
</ul>
<h3 id="进程">进程</h3>
<ol>
<li>用户进程</li>
<li>服务器进程</li>
<li>后台进程</li>
</ol>
<h4 id="1-用户进程">1. 用户进程</h4>
<p>约等于UI，通过某个UI访问Oracle</p>
<p>sqlplus就是一个用户进程，sqldeveloper也是</p>
<p>用户进程<strong>不可以</strong>直接访问服务器进程【不能在银行柜台直接拿钱，要向柜台的人提请求】</p>
<p><a href="https://blog.csdn.net/qqww120102/article/details/79289999" target="_blank" rel="noopener">https://blog.csdn.net/qqww120102/article/details/79289999</a></p>
<p>一般来说，数据库服务名 == 全局数据库名 == SID == instance名？？？</p>
<h4 id="服务名（发连接请求）">服务名（发连接请求）</h4>
<p>形象理解【去银行取钱 == 先到银行 + 我要取钱】</p>
<p>连接数据库请求 == 先通过某个协议-找到某台机器-找到这个机器上的某个端口 + 我要某某数据库服务</p>
<p>【先考虑怎么到银行】</p>
<ul>
<li>
<p>【要找到银行在哪，xx国家xx省xx市xx街xx号】</p>
<p>（JDBC）通过什么协议，找到某台机器，在这个机器上的某个端口</p>
</li>
<li>
<p>【直接说xx银行，代表具体到门牌号的地址】</p>
<p>做一个服务名，代表（协议-机器-端口+服务名）这一串</p>
<p>==做服务名就是为了缩写连接请求，将我要某某数据库服务，还原为上面那一串==</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conn scott&#x2F;123123@db12c</span><br></pre></td></tr></table></figure>
<p>用数据库服务名【银行名】就可以。为什么？有人帮你解析</p>
<h5 id="tnsping">tnsping</h5>
<p>Oracle Net 工具（命令）tnsping，是一个OSI会话层的工具，它用来：</p>
<ol>
<li>验证名字解析（name resolution，当然是oracle自己的网络服务名）</li>
<li>远程的listener是否启动</li>
</ol>
<p>tnsping命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tnsping  &lt;service_name&gt;  n（n的意义是可以让tnsping ping多次）</span><br><span class="line">!tnsping db12c （查找db12c的意义 - service name）</span><br><span class="line"></span><br><span class="line">-- 这个感叹号代表立即刷新变化，由于IO区是需要在扫描结束后进行更新，因此对于一些需要立即更新的IO来说，其强迫IO区做立即更新。</span><br></pre></td></tr></table></figure>
<img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200326125854573-1586189129451.png" alt="image-20200326125854573" style="zoom: 50%;">
<p>上面的信息存在tnsnames.ora中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd $ORACLE_HOME&#x2F;network&#x2F;admin</span><br><span class="line">cat tnsnames.ora</span><br></pre></td></tr></table></figure>
<p>通过TCP协议，找到ocp.com主机，通过端口1521，dedicated：通过专用数据库连接的方式，请求具体的服务名是db12c（和数据库名相同？？？）</p>
<p>每次都写上面一串才能连接，太麻烦了，做一个服务名db12c代表上面一串即可。</p>
<p>综上，客户机为了和服务器连接【我为了去银行取钱】，必须先和服务器上的监听进程联络【先找到银行门口（的小姐）】</p>
<p>服务名解析基于客户端，ORACLE通过tnsnames.ora文件中的连接描述符来说明连接信息（解析的映射信息）</p>
<h4 id="监听器（监听连接请求）">监听器（监听连接请求）</h4>
<p>问题来了，上面只是通过服务名【具体到门牌号的地址】，我只到了服务器的端口【银行门口】，连接数据库服务【进门，取钱】咋办？</p>
<p>【假设银行只能由接引员引进，无法自行进入】</p>
<ul>
<li>服务名（db15c）【工商银行的门牌号】</li>
<li>名称解析到某机器的某端口 【银行在哪里，具体到门牌号】</li>
<li>但名称解析<strong>只能</strong>到某机器的某端口，不知道有没有这个数据库服务【到了银行门口，不知道有没有取钱这个业务】</li>
</ul>
<p>所以，用户进程和服务器进程中间需要<strong>监听器</strong>【银行门口的小姐】，帮你看这个服务有没有注册【看有没有取钱这个服务】，并帮你找服务器进程【领进去找工作人员】</p>
<p>监听器作用：它设置在服务端，是基于<strong>服务端</strong>的一种网络服务，用于监听==客户端向数据库端==发出的连接请求。判断一下连接请求是否正确，请求有效就连接，失败就拒绝。所以你要连接远程数据库，那么远程数据库就要配置监听器，客户端则不需要配置。</p>
<p><img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200305213828892-1586189129451.png" alt="image-20200305213828892"></p>
<p>监听器配两个东西</p>
<ul>
<li>地址（只接收来这个地址加端口的请求）【小姐不招待进农业银行的人】</li>
<li>数据库服务【要写出能办的业务（比如能取钱）】</li>
</ul>
<p>如果监听器不开【没有人介绍服务、领进银行找工作人员去】</p>
<h5 id="什么是注册">什么是注册</h5>
<ul>
<li>注册就是将数据库作为一个服务注册到监听程序。</li>
<li>客户端不需要知道数据库名和实例名，只需要知道该数据库对外提供的服务名就可以申请连接到数据库。</li>
<li>这个服务名可能与实例名一样，也有可能不一样。</li>
<li>在数据库服务器启动过程中，数据库服务器会向监听程序注册相应的服务</li>
<li>无论何时启动一个数据库，默认地都有两条信息注册到监听器中：数据库服务器对应的实例名和服务名</li>
<li>相当于是这样：在数据库服务器和客户端之间有一监听程序（Listener），在监听程序中，会记录相应数据库对应的服务名（一个数据库可能对应有多个服务名），当客户端需要连接数据库时，只需要提供服务名，就可以建立客户端和服务器之间的连接。</li>
</ul>
<h5 id="动态注册lsnrctl-status">动态注册lsnrctl status</h5>
<ol>
<li>动态注册（ready）：表现为刚起来的时候连不上，一会才能连上</li>
<li>监听文件没有配置监听数据库的信息，但是当数据库启动的时候，会自动将instance_name,service_names两个参数将实例和服务动态注册到listener中，这种监听就是动态监听。</li>
<li>因为这个监听是从数据库发起的，这个时候监听肯定是有对应的数据库，所以显示的状态是READY，当数据库关闭后这个监听也就消失了。</li>
<li>客户端（sys用户）只能在远程数据库启动的情况下连接上，远程数据库关闭时客户端连接不上远程数据库。</li>
</ol>
<p>有一个LREG进程监听轮询服务， LREG会每60秒尝试注册。监听起是起来了，但是找不到服务</p>
<p>【小姐上班了，但不知道里面有啥业务，隔一会进去看一下业务，发现有数据库业务】</p>
<h5 id="静态注册">静态注册/</h5>
<ol>
<li>
<p>静态注册（unknown）：表现为数据库一启动就注册服务，就可以连</p>
</li>
<li>
<p>如果知道数据库的信息，可以先在监听文件里面配置好要监听的数据库的实例名instance，并配置服务名server，这就是静态监听。</p>
</li>
<li>
<p>这个监听服务器是由监听程序发起的，所以状态一直是UNKNOWN。这时监听器用来表明它不知道关于该实例的任何信息，只有当客户发出连接请求时，它才检查该实例是否存在。且数据库关闭后这个监听还会存在。</p>
</li>
<li>
<p>静态注册：无论远程数据库处于开启还是关闭状态，客户端（sys用户）都可连接上。</p>
<p>换一句换说静态注册可以在客户端控制服务器端数据库的启停，而动态注册则不可以。（动态注册的监听在实例关闭时会被注销）。数据库关闭的状态下，只有sys用户可连入数据库，其他用户不可连入。</p>
</li>
</ol>
<p>【小姐上班，翻一翻手册，就知道有数据库这个业务】</p>
<h5 id="如何配置静态注册">如何配置静态注册</h5>
<p>admin之下 cat listener.ora</p>
<p>动态注册长这样（没有指定数据库服务）</p>
<img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200326134947000.png" alt="image-20200326134947000" style="zoom:67%;">
<p>静态长这样（指定了数据库服务名）</p>
<img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200326135317633.png" alt="image-20200326135317633" style="zoom:67%;">
<p>同时存在？？？</p>
<p>admin之下，export DISPLAY，netmgr</p>
<img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200326135131112.png" alt="image-20200326135131112" style="zoom:67%;">
<p>SID：启动数据库实例的服务</p>
<p>SIDXDB：高效处理XML数据的服务，默认会占用8080端口。</p>
<p>监听器启动，需要一个参数，指定参数文件（listener.ora）</p>
<p><img src="/2020/03/13/Oracle/Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20200326102538205-1586189129451.png" alt="image-20200326102538205"></p>
<ul>
<li>
<p>用lsnrctl start命令启动oracle监听器</p>
</li>
<li>
<p>在启动、关闭或者重启oracle监听器之前确保使用lsnrctl status命令检查oracle监听器的状态。</p>
</li>
<li>
<p>lsnrctl stop 关闭所有的监听器</p>
</li>
<li>
<p>snrctl stop [listener-name]  指定要关闭的监听器的名字</p>
</li>
<li>
<p>lsnrctl reload重启监听器，此命令可以代替lsnrctl stop和lsnrctl start。</p>
<p>重启将会在不需要关闭和启动监听器的情况下读取listener.ora的配置。</p>
</li>
</ul>
<h5 id="连接connection和会话session">连接connection和会话session</h5>
<p>用户进程找到服务器进程 – <strong>连接</strong>【找到这个办事的人】【到银行取钱，首先要知道银行在哪】</p>
<p>服务进程去处理、干活 – <strong>会话</strong>【这个人去办事】</p>
<h4 id="2-服务器进程">2. 服务器进程</h4>
<p>==服务器进程用于访问instance，通过后台进程和数据库交互==</p>
<p>服务器进程是用户进程的代理，帮忙做事</p>
<p>接受用户进程的请求，访问Oracle服务器，把结果返回给用户进程</p>
<p>eg 用户执行一条update语句</p>
<ul>
<li>首先，服务器进程看库缓存里有没有（之前有没有执行过这个语句）。如果做过，产生计划，则直接调用执行；没有的话，重新执行语句（语法分析等等）</li>
<li>第二，先看要操作（增删改查）的这个对象定义在数据字典缓存中有没有，没有的话去数据文件中找；有则命中</li>
<li>第三，看要改的数据在数据库高速缓存中有没有，有则直接修改；没有则从数据文件中调进来内存再改</li>
<li>最后，改完要记日志到重做日志缓存中</li>
<li>用户commit，服务器进程将发送信号给LGWR后台进程，将日志写入日志文件</li>
<li>用户退出 / 做检查点，则发信号给DBWR后台进程，将脏数据写入数据文件</li>
</ul>
<h5 id="专用服务器进程">专用服务器进程</h5>
<p>到netmgr中查看服务器类型</p>
<p>【父母为我做饭，其他人饿了也不管】</p>
<ul>
<li>
<p>专门为一个用户进程服务</p>
</li>
<li>
<p>效率高，支持用户进程数量少</p>
</li>
<li>
<p>适用：用户连接数 &lt; 200</p>
</li>
</ul>
<h5 id="共享服务器进程">共享服务器进程</h5>
<p>【去饭店吃饭，厨师为多个客户服务】</p>
<ul>
<li>
<p>为多个用户进程共享</p>
</li>
<li>
<p>效率低，支持用户进程数量多</p>
</li>
<li>
<p>适用：200 - 3000个用户连接使用数</p>
</li>
</ul>
<h5 id="池中服务器">池中服务器</h5>
<p>【下课不是去学校外面饭店吃饭，饭店吃不消，去食堂】</p>
<p>&gt;3000需要配置中间件（连接池）</p>
<p>（web logic、IBM的sphere）</p>
<h4 id="3-常见后台进程">3. 常见后台进程</h4>
<p>Linux查看进程命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef |grep ora</span><br></pre></td></tr></table></figure>
<h5 id="PMON">PMON</h5>
<p>process monitor （用户）进程监视器进程</p>
<p>PMON进行处理用户进程的异常（终止）</p>
<p>轮询方式（工作机制具体不用了解）</p>
<p>eg 用户update后，直接点了右上角×，异常终止，需要这个进程处理未完成的事务</p>
<h5 id="SMON">SMON</h5>
<p>system monitor，用来监视instance</p>
<p>解决例程恢复</p>
<p>eg update后机器重启了，脏数据未写盘</p>
<p>采用先记日志的形式，数据未写盘，但日志写进日志文件了</p>
<p>smon就会用日志进行恢复（例程恢复：东西在内存中丢掉了）</p>
<h5 id="DBWR">DBWR</h5>
<p>db writer 数据库书写器进程</p>
<p>把数据库高速缓存写入数据文件中</p>
<h5 id="LGWR">LGWR</h5>
<p>log writer 日志书写器进程</p>
<p>将重做日志高速缓存写入重做日志中（介质中）</p>
<h5 id="CKPT">CKPT</h5>
<p>checkpoint 检查点进程</p>
<p>数据库（文件）和1min前不一样，由于scn号不同</p>
<h5 id="其他后台进程">其他后台进程</h5>
<p>查数据字典 v$bgprocess（正在运行的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">type</span> <span class="keyword">from</span> v$bgprocess;</span><br></pre></td></tr></table></figure>
<p>不需要把所有都搞清楚</p>
<p>还有归档进程</p>
<h4 id="ps：SCN">ps：SCN</h4>
<p>system change number 系统改变号</p>
<p>checkpoint_change# 检查点号（#代表号的意思）</p>
<p>和时间相关的单调递增的序列，用scn号表示数据的某个状态</p>
<p>恢复数据库时，把数据库推到任意一点的scn？？？</p>
<ul>
<li>过分强调运动的绝对性，导致不可知论【我不是刚刚的我】</li>
<li>做研究需要承认相对静止【收电费，电表一直走，没法收费了，所以抄表（做检查点，相对静止点）】</li>
</ul>
<p>scn【电表的实时读数】一定大于等于checkpoint_change【抄表时的读数】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> current_scn,checkpoint_change<span class="comment"># from v$database;</span></span><br><span class="line"><span class="keyword">select</span> dbms_flashback.get_system_change_number <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<p>做检查点时，使用最新的scn号刷新检查点号</p>
<p><strong>数据文件、日志文件、控制文件都有SCN号</strong></p>
<p>eg</p>
<p>写脏数据之前要写重做日志，如果在写完重做日志后，写脏数据之前例程故障（断电）</p>
<p>日志文件SCN = 20000，数据文件SCN = 19000</p>
<p>则只需要从19000开始恢复即可，重新做一遍</p>
<h4 id="检查点">检查点</h4>
<p>Q：数据库和五分钟前一样不一样？A：scn肯定不一样</p>
<p>检查点分为：</p>
<p>系统检查点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> checkpoint_change<span class="comment"># from v$database;</span></span><br></pre></td></tr></table></figure>
<p>数据文件检查点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">file</span><span class="comment">#,checkpoint_change#,last_change# from v$datafile;</span></span><br></pre></td></tr></table></figure>
<p>数据文件头检查点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">file</span><span class="comment">#,checkpoint_change# from v$datafile_header;</span></span><br></pre></td></tr></table></figure>
<p>这三个检查点都记录在控制文件中，因此数据库必须是mount状态</p>
<p>以上三个checkpoint_change#要一致(只读、脱机表空间除外)，数据库才能正常打开。</p>
<p>否则会需要进行一步的处理。</p>
<p>正常关库时，会生成新的检查点，写入上述三个checkpoint_change#</p>
<p>同时数据文件中的last_change#也会记录下该检查点，也就是说三个checkpoint_change#与last_change#记录着同一个值。</p>
<p>数据库打开前，先确定是否介质恢复，再确定是否实例恢复。</p>
<p>介质恢复主要是更新旧的文件，而实例恢复主要是更新内存。</p>
<p>如果last_change#值为空，则说明需要进行实例恢复，恢复后的数据库才能打开。</p>
<p>checkpoint_change#、last_change#实际上全部来自于SCN</p>
<p>ps：关数据库时，mount到nomount时，需要访问控制文件写信息<br>
（如果在open的时候把控制文件改名，则无法关闭）</p>
<h5 id="自己做的实验">自己做的实验</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">shutdown immediate </span><br><span class="line">startup mount </span><br><span class="line"><span class="comment">-- 正常情况，此时3个检查点一致</span></span><br><span class="line"><span class="comment">-- 可以用上面3个sql验证</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>
<p>数据库成功打开后，数据文件中的last_change#会被清空。正常关库时，再重新下最后的检查点。</p>
<p>shutdown abort关库，这个值是空的，此时数据库需要进行实例恢复（不需要用户干预），恢复后数据库才正常打开。</p>
<h5 id="手动做检查点">手动做检查点</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> checkpoint;</span><br></pre></td></tr></table></figure>
<h5 id="做检查点的作用">做检查点的作用</h5>
<ol>
<li>同步所有的<strong>数据文件</strong></li>
</ol>
<p>查找数据文件的检查点号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,checkpoint_change<span class="comment"># from v$datafile;</span></span><br></pre></td></tr></table></figure>
<p>所有的数据文件必须处于一致性状态</p>
<p>如果有一个数据文件的SCN号比当前的checkpoint小，则说明这个数据文件太旧，需要进行介质恢复了</p>
<ol start="2">
<li>同步所有的<strong>控制文件</strong></li>
</ol>
<p>控制文件检查点号，和v$database中的checkpoint_change#一样</p>
<p>因为这个视图中的检查点信息，就是来自控制文件的。。。</p>
<p>控制文件太旧？？？</p>
<ol start="3">
<li>发送信号<strong>通知DBWR写盘</strong></li>
</ol>
<p>做检查点时要将数据库高速缓存中的脏数据写盘</p>
<p>==例程恢复，根据检查点号来==，直接从最近的检查点开始恢复</p>
<h5 id="检查点的间隔时间">检查点的间隔时间</h5>
<p>长/短好：根据业务需求设置</p>
<ul>
<li>短：减少例程的恢复时间，但检查点是IO密集型事件，性能下降【打字每隔1s保存一次，很难受】</li>
<li>长：与短相反</li>
</ul>
<p>【希望多长时间恢复正常卖票】：5min</p>
<p>通过初始化参数设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter mttr</span><br><span class="line">-- fast_start_mttr_target</span><br><span class="line">-- instance 启动时进行初始化配置的文件</span><br><span class="line">-- 0：代表禁用自动checkpoint</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> fast_start_mttr_target=<span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<p>不是绝对的300s保存一次，出了问题恢复数据不能超过的时间</p>
<p>数据库一直在操作，如果不写盘，出问题时要redo</p>
<p>如果恢复这些数据的时间大于300s时，系统自动做一次检查点（写盘）</p>
<p>【打字快的人，保存的要频繁一些】</p>
<h5 id="查看数据库恢复时间">查看数据库恢复时间</h5>
<p>问题：做了一次检查点之后，几乎没有做任何操作，现在这个数据库挂了，恢复需要多长时间？</p>
<p>小于等于300，不知道，查数据字典</p>
<p>用户一直在操作，产生的脏数据越来越多，只有日志写盘，脏数据还在数据库高速缓存中</p>
<p>如果按照估算，按照日志恢复这些数据的时间超过300s，则做checkpoint</p>
<p>estimated_mttr：后台进程监视，这个值达到300时自动checkpoint</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> estimated_mttr <span class="keyword">from</span> v$instance_recovery;</span><br></pre></td></tr></table></figure>
<h2 id="database">database</h2>
<p>数据库 == 文件的集合</p>
<p>核心为数据文件（dbf），其他为辅助</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;</span><br></pre></td></tr></table></figure>
<p>文件 == 代码 + 数据（系统数据 + 用户数据）==数据字典 == 系统数据 == 数据目录 == 元数据==</p>
<ul>
<li>Oracle内部文件 - 灰色，Oracle自己管理，都带SCN号（不能拷出去拷回来）</li>
<li>Oracle外部文件 - 蓝色，也是Oracle文件，没有SCN号，但是性质等同于OS的文件，dba管理</li>
</ul>
<h3 id="数据文件">数据文件</h3>
<p>系统文件 + 用户文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;</span><br></pre></td></tr></table></figure>
<h3 id="控制文件">控制文件</h3>
<p>记录整个数据库的状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">controlfile</span>;</span><br></pre></td></tr></table></figure>
<p>控制文件，不能拷出来，再拷回去</p>
<p>这个文件是有checkpoint（SCN号）的，自带时钟，和时间有关系，拷出拷进会导致和其他文件的不一致</p>
<p>这个文件是由Oracle处理的</p>
<p>区分控制文件复用的情形？？？</p>
<h3 id="（联机）重做日志文件">（联机）重做日志文件</h3>
<p>联机和归档相对</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">member</span> <span class="keyword">from</span> v$<span class="keyword">logfile</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数文件">参数文件</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show parameter</span><br><span class="line">-- 显示全部的初始化参数</span><br></pre></td></tr></table></figure>
<p>内部有初始化参数</p>
<p>用户不去修改，永远不会变</p>
<h3 id="口令文件">口令文件</h3>
<p>验证机制：Oracle数据库完全信任OS，能访问操作系统就能访问数据库？？？</p>
<p>随意写用户名和口令，甚至都没有，都可以连上数据库</p>
<p>不用操作系统验证，改用口令验证方式，需要创建password file？？？</p>
<h3 id="归档日志文件">归档日志文件</h3>
<p>重要</p>
<h3 id="Oracle日志工作体系">Oracle日志工作体系</h3>
<ul>
<li>开用户进程做事务时（Transaction1），服务器进程（server process）把T1作为一个条目，放到重做日志缓存中</li>
<li>commit后，发送信号，通知日志书写器（LGWR）将【重做日志缓存数据】写到联机重做日志【当前组文件】中</li>
<li>联机重做日志文件以日志组形式管理</li>
</ul>
<h4 id="查日志组">查日志组</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">group</span><span class="comment">#,sequence#,status from v$log;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3个日志文件组</li>
<li>group# 组号，sequence# 当前序列号</li>
<li>status - current/active/inactive</li>
<li>谁是current往谁里写</li>
</ul>
<h4 id="查具体的日志文件">查具体的日志文件</h4>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">group</span><span class="comment">#, member from v$logfile;</span></span><br></pre></td></tr></table></figure>
<p>文件满了之后，自动切换日志组（组内文件互为镜像），对于切换到的新的日志组里原来的文件怎么办，取决于数据库的日志模式</p>
<h4 id="查数据库日志模式">查数据库日志模式</h4>
<p>两种方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, log_mode <span class="keyword">from</span> v$<span class="keyword">database</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">archive log list</span><br><span class="line"></span><br><span class="line">Database log mode              Archive Mode</span><br><span class="line">Automatic archival             Enabled</span><br><span class="line">Archive destination            /u01/arch/2</span><br><span class="line">Oldest online log sequence     8</span><br><span class="line">Next log sequence to archive   10 <span class="comment">-- 下一个要被归档的日志（组？？？</span></span><br><span class="line">Current log sequence           10</span><br></pre></td></tr></table></figure>
<ol>
<li>非归档模式（noarchivelog）：直接覆盖原来的日志文件【旧书直接扔掉】</li>
<li>归档模式：覆盖之前，先把原来的日志放在归档日志文件中【旧书转移到档案馆里，给新书腾出位置】</li>
</ol>
<p>切换日志文件，循环工作方式（组1 - 组2 - 组3 - 组1。。。）</p>
<p>sequence#序列号是递增的（resetlog？？？）</p>
<h4 id="手动切换日志组">手动切换日志组</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">switch</span> <span class="keyword">logfile</span>;</span><br></pre></td></tr></table></figure>
<h4 id="查询归档日志">查询归档日志</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$archived_log;</span><br><span class="line"><span class="comment">-- 非归档模式，没有归档文件（no rows selected）</span></span><br></pre></td></tr></table></figure>
<h4 id="切换数据库归档模式">切换数据库归档模式</h4>
<p>==在数据库的mount阶段敲==</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">shutdown immediate</span><br><span class="line">startup mount</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">archivelog</span>;</span><br><span class="line"><span class="comment">--alter database noarchivelog;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>; <span class="comment">-- 再将数据库打开</span></span><br></pre></td></tr></table></figure>
<h4 id="手动归档当前日志">手动归档当前日志</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">archive</span> <span class="keyword">log</span> <span class="keyword">current</span>;</span><br></pre></td></tr></table></figure>
<h4 id="如何管理">如何管理</h4>
<p>联机重做日志文件由Oracle管理，归档日志由dba管理</p>
<p>当归档日志太多的时候，就做一个整库备份【设置一个基线】，之前的归档日志文件就不需要了</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 零碎知识点</title>
    <url>/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="数据字典">数据字典</h3>
<ul>
<li>
<p>数据字典系统表（dict），保存在system表空间中</p>
</li>
<li>
<p>DICTIONARY contains descriptions of data dictionary tables and views. （只有数据字典表和视图，没有用户表）</p>
</li>
<li>
<p>dict表（视图）中有table_name, comments字段：看某个表有什么用</p>
</li>
<li>
<p>动态静态都能查到</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name,comments <span class="keyword">from</span> dict <span class="keyword">where</span> table_name=<span class="keyword">UPPER</span>(<span class="string">'user_tables'</span>); <span class="comment">-- 注意大小写</span></span><br></pre></td></tr></table></figure>
<p>数据字典主要可分为四部分：</p>
<a id="more"></a>
<h4 id="1-内部RDBMS表">1. 内部RDBMS表</h4>
<p><code>x$*</code></p>
<p>用于跟踪内部数据库信息，维持DB的正常运行。是加密命名的， 而且Oracle不做文档说明。不允许sysdba以外的用户直接访问，显示授权不被允许。</p>
<p>X$表是Oracle数据库的运行基础，在数据库启动时由Oracle应用程序动态创建。</p>
<h4 id="2-数据字典表-（Data-dictionary-table）">2. 数据字典表 （Data dictionary table）</h4>
<p><code>*$</code>，如<code>tab$,obj$,ts$</code>等</p>
<p>用来存储表、索引、约束以及其他数据库结构的信息。</p>
<p>在创建数据库的时候通过运行$ORACLE_HOME/rdbms/admin/sql.bsq脚本来创建。</p>
<h4 id="3-静态数据字典视图">3. 静态数据字典视图</h4>
<p>视图，不是一种存储结构</p>
<p>静态数据字典视图，来自一些系统表，这些系统表一般放在system表空间下？？？</p>
<p><strong>查看视图原表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> REFERENCED_NAME, REFERENCED_TYPE</span><br><span class="line"><span class="keyword">from</span> SYS.ALL_DEPENDENCIES</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">TYPE</span> = <span class="string">'VIEW'</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">NAME</span> = <span class="keyword">UPPER</span>(<span class="string">'DBA_TABLE'</span>)</span><br><span class="line"><span class="keyword">and</span> REFERENCED_TYPE = <span class="string">'TABLE'</span>;</span><br></pre></td></tr></table></figure>
<p><code>user_*、all_*、dba_*</code></p>
<p>由于X$表和数据字典表通常不能直接被用户访问，Oracle创建了静态数据字典视图来<strong>提供用户对于数据字典信息的访问</strong>，由于这些信息通常相对稳定，不能直接修改，所以又被称为静态数据字典视图。</p>
<p>静态数据字典视图在创建数据库时由$ORACLE_HOME/rdbms/admin/catagory.sql脚本创建。</p>
<p>通过三类视图在本质上是为了实现权限控制。在Oracle数据库中，每个用户与方案（Schema）是对应的，Schema是用户所拥有的对象的集合。数据库通过Schema将不同用户的对象隔离开来，用户可以自由的访问自己的对象，但是要访问其他Schema对象就需要相关的授权。</p>
<ul>
<li>内容来自：数据文件</li>
<li>统计数据，要及时更新。安排作业？？？每天晚上自动更新</li>
<li>一般是<strong>复数形式</strong></li>
</ul>
<p>遇到下面的前缀，权限从小到大，dba需要授权</p>
<ul>
<li>
<p>USER_  当前用户是所有者的对象</p>
</li>
<li>
<p>ALL_  当前用户是所有者的对象 + 当前用户有权限访问的对象</p>
</li>
<li>
<p>DBA_ dba是所有者的对象 +dba有权限访问的对象</p>
<p>在hr下，访问不了这类表，<strong>权限</strong>不够。需要在sysdba（权限大的角色）下访问</p>
</li>
</ul>
<p>查一个表有几条数据，==不用count，要查字典==，【count == 把学生叫道操场数数】</p>
<p>静态数据字典视图，更新问题</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp; <span class="comment">-- 删除一个表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp; <span class="comment">-- table or view does not exist</span></span><br><span class="line">flashback table emp to before <span class="keyword">drop</span>; <span class="comment">-- flashback complete</span></span><br><span class="line"></span><br><span class="line">desc user_tables</span><br><span class="line"><span class="keyword">select</span> table_name, num_rows <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'EMP'</span>; <span class="comment">-- 大小写问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- drop table之后，数据字典中numrows变为空</span></span><br><span class="line"><span class="comment">-- flashback</span></span><br><span class="line"><span class="comment">-- 表闪回之后，数据字典没有更新回删除之前的状态！！！</span></span><br><span class="line"><span class="comment">-- Oracle按照这个旧的统计数据指定执行计划</span></span><br><span class="line"><span class="comment">-- 旧数据行数很少，所以不走索引全表扫描，但实际数据很多，导致性能极低</span></span><br><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> emp <span class="keyword">compute</span> <span class="keyword">statistics</span>; <span class="comment">-- 更新统计数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno,ename) <span class="keyword">values</span>(<span class="number">1234</span>, <span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">select</span> table_name, num_rows <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'EMP'</span>; <span class="comment">-- 数量没有变</span></span><br><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> emp <span class="keyword">compute</span> <span class="keyword">statistics</span>; <span class="comment">-- 更新统计数据</span></span><br><span class="line"><span class="keyword">select</span> table_name, num_rows <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'EMP'</span>; <span class="comment">-- 数量+1</span></span><br></pre></td></tr></table></figure>
<h4 id="4-动态性能视图">4. 动态性能视图</h4>
<p><code>gv$*， v$*</code></p>
<p>记录了DB运行时信息和统计数据，大部分动态性能视图被实时更新以反映DB当前状态。</p>
<p>内容来自：内存和控制文件</p>
<p>视图内部的指标大多和性能相关</p>
<p>==v$ 开头的==</p>
<p>eg 查看库缓存的命中率（命中率高，效率高）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc v$librarycache <span class="comment">-- namespace，gethitratio</span></span><br><span class="line"><span class="keyword">select</span> NAMESPACE <span class="keyword">from</span> v$librarycache <span class="comment">-- 包含每种对象（sql area、index等）的命中率</span></span><br><span class="line"><span class="keyword">select</span> NAMESPACE,GETHITRATIO <span class="keyword">from</span> v$librarycache <span class="keyword">where</span> NAMESPACE <span class="keyword">in</span> (<span class="string">'SQL AREA'</span>,<span class="string">'TABLE/PROCEDURE'</span>); <span class="comment">-- sql语句和存储过程的命中率0.4 0.6左右</span></span><br><span class="line"><span class="comment">-- 生产中90%以下需要优化</span></span><br></pre></td></tr></table></figure>
<p>如果猜不到, 就老老实实查总表，==dictionary 同义词为 dict==</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc dict <span class="comment">-- 两个字段：table_name, comments</span></span><br><span class="line"><span class="comment">-- select table_name from dict; -- 四千多行，需要筛选</span></span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> dict <span class="keyword">where</span> table_name <span class="keyword">like</span> <span class="string">'%SGA%'</span>; <span class="comment">-- 剩二十多行</span></span><br><span class="line"></span><br><span class="line">desc V$SGAINFO; <span class="comment">-- sga各部分的信息（里面有sga各部分大小：共享池等）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">bytes</span>/<span class="number">1024</span>/<span class="number">1024</span> <span class="keyword">sizes</span> <span class="keyword">from</span> V$SGAINFO; <span class="comment">-- 单位换算成MB</span></span><br></pre></td></tr></table></figure>
<p>在数据库启动时，Oracle动态创建X$表。在此基础上，Oracle创建了GV$和V$视图，GV$即Global V$，除了一些特例外，每个V$都对应一个GV$。GV$产生是为了OPS/RAC环境的需要，每个V$都是基于GV$的，只是GV$多了INST_ID列来显示实例ID。 在非Sys用户下，我们访问的都是同义词，而不是V$视图或GV$视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询V$视图时，报的错却是V_$视图不存在，V_$视图不是基于V$视图创建的吗，怎么反向报错了？</span><br><span class="line"></span><br><span class="line">为了防止普通用户的误操作，Oracle对通过软件机制对V$视图的访问做了限制，它不允许普通用户直接访问V$视图，但我们平时不是经常访问吗？这其实是Oracle引入了V_$视图。</span><br><span class="line">在建立V$视图后，Oracle就建立了V_$视图，随后为V_$视图建立了与V$视图同名的共用同义词。这些工作都是通过catalog.sql脚本（该脚本位于$ORACLE_HOME&#x2F;rdbms&#x2F;admin&#x2F;目录下）实现的。</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">create or replace view v_$fixed_table as select * from v$fixed_table;</span><br><span class="line">create or replace public synonym v$fixed_table for v_$fixed_table;   --同名同义词</span><br><span class="line"></span><br><span class="line">也就是说，大部分用户访问的V$对象，并不是视图，而是执行V_$视图的同义词；而V_$视图时基于真正V$视图创建的。</span><br></pre></td></tr></table></figure>
<h4 id></h4>
<h3 id="例程管理、配置">例程管理、配置</h3>
<h4 id="关闭例程">关闭例程</h4>
<p>四种模式</p>
<p>eg</p>
<ul>
<li>
<p>超市关门，门口站个人说不能进 == 禁止新的连接</p>
</li>
<li>
<p>等所有人走完，关门 == 等所有会话结束</p>
</li>
<li>
<p>等正在买东西的顾客 == 等所有事务结束</p>
</li>
<li>
<p>正在买东西的顾客，放下东西赶出去 == 立即关闭</p>
</li>
<li>
<p>商店火灾，</p>
</li>
</ul>
<ol>
<li>
<p>正常关闭(normal，默认模式)</p>
<p>等所有会话结束（sqlplus的exit、或者rman连接数据库也算）才能关闭，所以时间比较长</p>
</li>
<li>
<p>事务性关闭(transactional)</p>
<p>等所有事务结束（commit或rollback）才能关闭，比1快</p>
</li>
<li>
<p>立即关闭(==immediate==)</p>
<p>不需要等事务结束，如果事务还没有commit，会回滚之后关闭</p>
<p><strong>123会做检查点（缓存数据会写到数据文件中），对数据库没有什么伤害</strong></p>
</li>
<li>
<p>中止退出(abort) 丢数据</p>
<p>不做检查点，会丢失数据</p>
</li>
</ol>
<img src="/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200320080400696.png" alt="image-20200320080400696" style="zoom:67%;">
<h4 id="启动例程">启动例程</h4>
<img src="/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200419220233324.png" alt="image-20200419220233324" style="zoom:80%;">
<p>分配内存 + 启动后台进程</p>
<p>startup</p>
<p>默认为 startup open</p>
<p>怎么看位于哪个阶段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> v$<span class="keyword">instance</span>;</span><br></pre></td></tr></table></figure>
<h5 id="1-例程启动（nomount阶段）">1.例程启动（nomount阶段）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup nomount <span class="comment">-- 分配内存，同时启动后台进程</span></span><br></pre></td></tr></table></figure>
<p>条件：需要访问正确的<strong>初始化参数文件</strong></p>
<p>功能：在nomount下，只能访问一部分动态性能视图（内容来自内存）</p>
<p>动态性能视图来自内存和控制文件，不能访问数据文件</p>
<p>初始化参数文件中，知道了控制文件的路径，但还没有加载控制文件？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v$sga;         <span class="comment">-- ok</span></span><br><span class="line">desc v$datafile; <span class="comment">-- 只能看到结构，不能访问内容</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;    <span class="comment">--不存在，因为数据库没有打开，数据文件还没打开，查不到数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;        <span class="comment">--不存在</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化参数文件</strong></p>
<p>1.文本文件</p>
<ul>
<li>
<p>文件名格式：<code>init&lt;sid&gt;.ora</code></p>
</li>
<li>
<p>pfile（parameter file、dba管理的参数文件），文本文件</p>
<p>每次修改这个文件，重启数据库读这个文件才能生效</p>
<p>生产中，重启数据库要减少频率</p>
</li>
<li>
<p>sid == 服务名</p>
</li>
</ul>
<p>2.二进制文件</p>
<ul>
<li>文件名格式：<code>spfile&lt;sid&gt;.ora</code>（server管理的pfile）</li>
<li>有这个就不需要pfile了</li>
<li>不由可显示字符组成，不可用文本编辑器修改，否则文件会被破坏</li>
<li>spfile是用来服务器的启动的，不可以随便修改，要用命令修改，修改之后直接生效不用重启</li>
</ul>
<p><strong>查看初始化参数（spfile里的）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter                   <span class="comment">--看所有初始化参数</span></span><br><span class="line"><span class="keyword">show</span> parameter shared_pool_size  <span class="comment">--看具体某一个（共享池大小）</span></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line"><span class="keyword">show</span> parameter <span class="keyword">share</span>             <span class="comment">--查询所有名字包含子字符串share的参数</span></span><br></pre></td></tr></table></figure>
<p><strong>如何看自己用什么启动</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter <span class="keyword">spfile</span></span><br><span class="line"><span class="comment">-- 如果为空，则说明用pfile启动的；如果有值，则说明用spfile启动的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改为spfile启动，Oracle会检测这个文件是否存在</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> <span class="keyword">spfile</span>=<span class="string">'/u01/app/oracle/product/12.2.0/dbhome_1/dbs/spfiledb12c.ora'</span>;</span><br><span class="line"><span class="comment">-- 修改为pfile启动</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> <span class="keyword">spfile</span>=<span class="string">''</span>;</span><br></pre></td></tr></table></figure>
<p><strong>例程在启动时选择初始化参数文件的顺序</strong></p>
<p>Oracle在$ORACLE_HOME/dbs下找这几个文件，如果你的参数文件不在这里，则需要用4)</p>
<p>1)spfile<sid>.ora有此文件，其他文件都不看，第一顺位</sid></p>
<p>2)spfile.ora 第二顺位</p>
<p>3)init<sid>.ora</sid></p>
<p>4)都找不到就报错=&gt;解决：利用指定的q初始化参数文件启动startup pfile=d:\a\a.ora</p>
<p>路径不加引号</p>
<img src="/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200320103835250.png" alt="image-20200320103835250" style="zoom:80%;">
<p>如果在操作系统级别把所有初始化参数文件（spfile和pfile）改名，则会起不了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup nomount</span><br><span class="line"></span><br><span class="line">ORA-01078: failure in processing system parameters</span><br><span class="line">LRM-00109: could not open parameter file '/u01/app/oracle/product/12.2.0/dbhome_1/dbs/initdb12c.ora'</span><br></pre></td></tr></table></figure>
<h5 id="2-加载数据库-mount阶段">2.加载数据库(mount阶段)</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">mount</span>;  <span class="comment">--已经进行了startup nomount就不可以再进行startup mount</span></span><br></pre></td></tr></table></figure>
<p>条件：需要能访问到<strong>控制文件</strong>（记录数据库状态）</p>
<p>功能：可以访问所有的动态视图</p>
<p>现在加载了控制文件，知道了联机重做日志文件、数据文件的位置，但还没有加载他们？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter control_files  <span class="comment">--查询出oracle的控制文件</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> v$<span class="keyword">instance</span>;  <span class="comment">--查询处于什么阶段（mounted），表示处于mount阶段</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">datafile</span>;    <span class="comment">--可以访问</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;        <span class="comment">--不存在，表在数据文件中</span></span><br></pre></td></tr></table></figure>
<p>alter mount时，如果访问不到正确的控制文件（改个名字）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">mount</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-00205</span>: <span class="keyword">error</span> <span class="keyword">in</span> identifying control <span class="keyword">file</span>, <span class="keyword">check</span> alert <span class="keyword">log</span> <span class="keyword">for</span> more info</span><br></pre></td></tr></table></figure>
<h5 id="3-打开数据库（open阶段）">3.打开数据库（open阶段）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>
<p>条件：需要访问<strong>联机重做日志文件和数据文件</strong>（在控制文件中定义好的）</p>
<p>功能：可以访问所有的文件（包括数据文件，静态字典视图）</p>
<p>如果在open前，把日志文件改个名，会启动失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database open</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-03113: end-of-file on communication channel</span><br><span class="line">Process ID: 28800</span><br><span class="line">Session ID: 9 Serial number: 61831</span><br></pre></td></tr></table></figure>
<p>到另一个tab的os下，使用adrci命令查看警告日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adrci</span><br><span class="line">adrci&gt; help</span><br><span class="line">adrci&gt; show homes</span><br><span class="line">ADR Homes:</span><br><span class="line">diag/rdbms/db12c/db12c</span><br><span class="line">diag/rdbms/dummy/sales</span><br><span class="line">diag/rdbms/sales/sales</span><br><span class="line">diag/rdbms/oradup/oradup</span><br><span class="line">diag/rdbms/kwra_pitr_sales/kwra</span><br><span class="line">diag/rdbms/eyhf_pitr_sales/EyhF</span><br><span class="line">diag/rdbms/cdb/cdb</span><br><span class="line">diag/clients/user_oracle/host_901187968_107</span><br><span class="line">diag/tnslsnr/ocp/listener</span><br><span class="line"></span><br><span class="line">adrci&gt; set home diag/rdbms/db12c/db12c</span><br><span class="line">adrci&gt; show home</span><br><span class="line">ADR Homes:</span><br><span class="line">diag/rdbms/db12c/db12c</span><br><span class="line"></span><br><span class="line">adrci&gt; show alert -tail 30</span><br><span class="line"><span class="comment">-- 从后往前看，30行</span></span><br><span class="line">Errors in file /u01/app/oracle/diag/rdbms/db12c/db12c/trace/db12c_lgwr_28757.trc:</span><br><span class="line">ORA-00313: ??????? 1 (???? 1) ???</span><br><span class="line">ORA-00312: ???? 1 ?? 1: '/u01/app/oracle/oradata/db12c/redo01.log'</span><br><span class="line">ORA-27037: ????????</span><br><span class="line">Linux-x86_64 Error: 2: No such file or directory</span><br><span class="line"><span class="comment">-- 发现是redo01.log这个文件坏了</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">member</span> <span class="keyword">from</span> v$<span class="keyword">logfile</span>;</span><br></pre></td></tr></table></figure>
<p>在open之前把数据文件改个名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-01157</span>: cannot identify/<span class="keyword">lock</span> <span class="keyword">data</span> <span class="keyword">file</span> <span class="number">7</span> - see DBWR <span class="keyword">trace</span> <span class="keyword">file</span></span><br><span class="line">ORA<span class="number">-01110</span>: <span class="keyword">data</span> <span class="keyword">file</span> <span class="number">7</span>: <span class="string">'/u01/app/oracle/oradata/db12c/users01.dbf'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SYS</span>@db12c&gt;<span class="keyword">select</span> <span class="keyword">file</span><span class="comment">#,name from v$datafile;</span></span><br><span class="line"><span class="comment">-- 把名字改回来</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>; <span class="comment">-- 恢复正常</span></span><br></pre></td></tr></table></figure>
<p>1）只读的方式打开数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup open read only;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,open_mode <span class="keyword">from</span> v$<span class="keyword">database</span>;       <span class="comment">--查询打开模式</span></span><br><span class="line"><span class="keyword">select</span> current_scn <span class="keyword">from</span> v$<span class="keyword">database</span>;          <span class="comment">--这个是不变的，平常是变化的</span></span><br><span class="line"><span class="keyword">update</span> scott.emp <span class="keyword">set</span> sal = <span class="number">1800</span> <span class="keyword">where</span> empno = <span class="number">7369</span>; <span class="comment">--报错！数据库只读，不可以修改</span></span><br></pre></td></tr></table></figure>
<p>2）以受限的模式打开数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup restrict;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,open_mode <span class="keyword">from</span> v$<span class="keyword">database</span>;       <span class="comment">--查询打开模式</span></span><br><span class="line"><span class="keyword">select</span> instance_name,logins <span class="keyword">from</span> v$<span class="keyword">instance</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 让有些用户连，有些用户不连（有restriction权限的可以访问）</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">restricted</span> <span class="keyword">session</span> <span class="keyword">to</span> hr;              <span class="comment">--hr就可以登录了</span></span><br><span class="line">    禁用受限模式</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">disable</span> <span class="keyword">restricted</span> <span class="keyword">session</span>;</span><br><span class="line">    启用受限模式</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">enable</span> restricited <span class="keyword">session</span>;</span><br></pre></td></tr></table></figure>
<h4 id="例程的配置">例程的配置</h4>
<p>数据库参考手册，Oracle database reference</p>
<h5 id="修改初始化参数">修改初始化参数</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> shared_pool_size = <span class="number">128</span>m; <span class="comment">-- 参数为big integer类型</span></span><br><span class="line"><span class="comment">-- alter system为例程级别</span></span><br><span class="line"><span class="keyword">show</span> parameter shared_pool_size</span><br><span class="line"><span class="comment">-- 生效，重启后仍然有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个参数是静态参数，无法动态修改，先写到文件里，重启才可生效。</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> sga_max_size = <span class="number">2000</span>m;</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-02095: specified initialization parameter cannot be modified</span><br></pre></td></tr></table></figure>
<p>查看参数类型（静态/动态）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看参数类型</span></span><br><span class="line">desc v$parameter</span><br><span class="line"><span class="comment">-- ISSYS_MODIFIABLE字段有三种类型</span></span><br><span class="line">  deferred       <span class="comment">--延时，不会马上/也不需要生效，对以后登录的会话生效（重新连接就可生效）</span></span><br><span class="line">  immediate      <span class="comment">--可立即改，并立即生效</span></span><br><span class="line">  false          <span class="comment">--说明是静态参数，不可直接改，只能先写到文件中，必须重启才能生效</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,ISSYS_MODIFIABLE <span class="keyword">from</span> v$parameter <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'sga_max_size'</span>; <span class="comment">-- false类型</span></span><br></pre></td></tr></table></figure>
<h5 id="scope子句">scope子句</h5>
<ul>
<li>是否生效：看show parameter 有没有改变</li>
<li>是否写到spfile中： 可以用文本编辑器打开spfile看一下，但千万不要编辑！！！</li>
</ul>
<ol>
<li>memory：只在内存改，不在spfile文件改（临时生效）</li>
<li>spfile：先写在文件中，下次重启数据库生效</li>
<li>both：（默认）立即生效，同时在文件中修改</li>
</ol>
<p>注：静态类型参数只能spfile</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> shared_pool_size=<span class="number">256</span>m <span class="keyword">scope</span> = <span class="keyword">memory</span>;</span><br><span class="line"><span class="comment">-- 立即生效，但文件没有修改，下次修改还是原来的值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> shared_pool_size=<span class="number">256</span>m <span class="keyword">scope</span> = <span class="keyword">both</span>;</span><br><span class="line"><span class="comment">-- 立即生效，且文件已经被修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> shared_pool_size=<span class="number">256</span>m <span class="keyword">scope</span> = <span class="keyword">spfile</span>;</span><br><span class="line"><span class="comment">-- 没有生效，但是已经写到spfile文件里面了，下次启动Oracle生效（shutdown之后重新startup）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> sga_max_size=<span class="number">5000</span>m <span class="keyword">scope</span> = <span class="keyword">spfile</span>;</span><br><span class="line"><span class="comment">-- 用memory和both都会报错</span></span><br><span class="line"><span class="comment">-- ORA-02095: specified initialization parameter cannot be modified</span></span><br></pre></td></tr></table></figure>
<h5 id="reset将某个初始化参数还原成默认值">reset将某个初始化参数还原成默认值</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter shared_server</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">reset</span> shared_server;  <span class="comment">--复位，重启数据库之后才生效</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">reset</span> shared_pool_size;</span><br></pre></td></tr></table></figure>
<h5 id="将所有初始化参数都还原成默认值">将所有初始化参数都还原成默认值</h5>
<p>初始化参数文件中没有说明的参数，就取他们的默认值</p>
<p>所以可以直接创建一个空的初始化参数文件，这样所有的参数就都是默认值了</p>
<p>先把原来的spfile改个名，让Oracle认不得</p>
<p>然后再把pfile中的所有内容都删掉，但这样会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db12c.__data_transfer_cache_size&#x3D;0</span><br><span class="line">db12c.__db_cache_size&#x3D;1275068416</span><br><span class="line">db12c.__inmemory_ext_roarea&#x3D;0</span><br><span class="line">db12c.__inmemory_ext_rwarea&#x3D;0</span><br><span class="line">db12c.__java_pool_size&#x3D;16777216</span><br><span class="line">db12c.__large_pool_size&#x3D;33554432</span><br><span class="line">db12c.__oracle_base&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#39;#ORACLE_BASE set from environment</span><br><span class="line">db12c.__pga_aggregate_target&#x3D;603979776</span><br><span class="line">db12c.__sga_target&#x3D;1811939328</span><br><span class="line">db12c.__shared_io_pool_size&#x3D;83886080</span><br><span class="line">db12c.__shared_pool_size&#x3D;385875968</span><br><span class="line">db12c.__streams_pool_size&#x3D;0</span><br><span class="line">*.audit_file_dest&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;admin&#x2F;db12c&#x2F;adump&#39;</span><br><span class="line">*.audit_trail&#x3D;&#39;db&#39;</span><br><span class="line">*.compatible&#x3D;&#39;12.2.0&#39;</span><br><span class="line">*.control_files&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;db12c&#x2F;control01.ctl&#39;,&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;recovery_area&#x2F;db12c&#x2F;control02.ctl&#39;</span><br><span class="line">*.db_block_size&#x3D;8192</span><br><span class="line">*.db_name&#x3D;&#39;db12c&#39;</span><br><span class="line">*.db_recovery_file_dest&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;recovery_area&#39;</span><br><span class="line">*.db_recovery_file_dest_size&#x3D;8016m</span><br><span class="line">*.diagnostic_dest&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#39;</span><br><span class="line">*.dispatchers&#x3D;&#39;(PROTOCOL&#x3D;TCP) (SERVICE&#x3D;db12cXDB)&#39;</span><br><span class="line">*.local_listener&#x3D;&#39;LISTENER_DB12C&#39;</span><br><span class="line">*.nls_language&#x3D;&#39;SIMPLIFIED CHINESE&#39;</span><br><span class="line">*.nls_territory&#x3D;&#39;CHINA&#39;</span><br><span class="line">*.open_cursors&#x3D;300</span><br><span class="line">*.pga_aggregate_target&#x3D;571m</span><br><span class="line">*.processes&#x3D;320</span><br><span class="line">*.remote_login_passwordfile&#x3D;&#39;EXCLUSIVE&#39;</span><br><span class="line">*.sga_max_size&#x3D;1811939328</span><br><span class="line">*.sga_target&#x3D;1713m</span><br><span class="line">*.undo_tablespace&#x3D;&#39;UNDOTBS1&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup nomount</span><br><span class="line">ORA-01506: missing or illegal database name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把这个加到文件里</span></span><br><span class="line">*.db_name='db12c'</span><br><span class="line"></span><br><span class="line">startup nomount <span class="comment">-- 起来了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">mount</span>;</span><br><span class="line">ORA-00205: error in identifying control file, <span class="keyword">check</span> alert <span class="keyword">log</span> <span class="keyword">for</span> more info</span><br><span class="line"><span class="comment">-- 把这个加到文件里</span></span><br><span class="line">*.control_files=<span class="string">'/u01/app/oracle/oradata/db12c/control01.ctl'</span>,<span class="string">'/u01/app/oracle/recovery_area/db12c/control02.ctl'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">shutdown</span> <span class="keyword">immediate</span> <span class="comment">-- 内存中pfile不会即时更新，需要shut之后，重新读一次pfile</span></span><br><span class="line"><span class="keyword">startup</span> <span class="keyword">mount</span> <span class="comment">-- 起来了</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>; <span class="comment">-- 起来了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> parameter <span class="keyword">spfile</span></span><br><span class="line"><span class="keyword">NAME</span>                                 <span class="keyword">TYPE</span>                   <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ---------------------- ------------------------------</span></span><br><span class="line"><span class="keyword">spfile</span>                               <span class="keyword">string</span></span><br><span class="line"><span class="comment">-- 此时是以pfile启动的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果无法shutdown immediate</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> checkpoint; <span class="comment">-- 手动做检查点</span></span><br><span class="line">shutdown abort</span><br></pre></td></tr></table></figure>
<h5 id="修复错误的初始化参数（要会">修复错误的初始化参数（要会</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> parameter <span class="keyword">spfile</span> <span class="comment">-- 查看是不是用spfile启动的，如果是空，则用pfile；不空则用spfile</span></span><br><span class="line"><span class="comment">-- 保证这里是spfile启动的</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> shared_pool_size=<span class="number">200</span>G <span class="keyword">scope</span>=<span class="keyword">spfile</span>; <span class="comment">-- 下次生效（虽然下次都不一定能起来</span></span><br><span class="line">shutdown immediate</span><br><span class="line">startup</span><br><span class="line"><span class="comment">-- 搞坏参数，用spfile起不来了，startup报错sga_target总空间太小，其中的一部分太大</span></span><br><span class="line"><span class="comment">-- 只能用pfile起了</span></span><br><span class="line">ORA-00821: Specified value of sga_target 2048M is too small, needs to be at least 207360M</span><br><span class="line">ORA-01078: failure in processing system parameters</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> shared_pool_size=<span class="number">160</span>m <span class="keyword">scope</span>=<span class="keyword">spfile</span>;</span><br><span class="line"><span class="comment">-- Oracle没启动哈哈哈改不了</span></span><br></pre></td></tr></table></figure>
<p>==查看警告日志文件==，记录死锁、Oracle内部错误等等重大事件</p>
<p>知道是哪一个参数不对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;rdbms&#x2F;db12c&#x2F;trace&#x2F;alert_db12c.log</span><br></pre></td></tr></table></figure>
<p>这个文件可以删，记录日志时会自动产生</p>
<p>pfile，用于修复错误时用，人可以修改</p>
<p>根据现在的spfile创建pfile文件（不要用刚刚的空pfile，spfile中的参数会丢掉）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> pfile <span class="keyword">from</span> <span class="keyword">spfile</span>;</span><br><span class="line"><span class="comment">-- 不startup nomount就能建？？？</span></span><br></pre></td></tr></table></figure>
<p>生成initdb12c.ora（覆盖了原来的空pfile），是文本文件可修改</p>
<p>把那个错误参数shared_pool_size修改160m，保存</p>
<p>将原来的spfile改名，让Oracle找不到spfile，只能用pfile启动</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">startup nomount</span><br></pre></td></tr></table></figure>
<p>出现了莫名其妙的错误。shared_pool_reserved_min_alloc必须位于4000和0之间</p>
<p>解决方法</p>
<ul>
<li>直接把那个shared_pool_size参数去掉，当作默认值</li>
<li>或者两个参数都加上？</li>
</ul>
<p>再根据pfile创建spfile</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">spfile</span> <span class="keyword">from</span> pfile;</span><br></pre></td></tr></table></figure>
<p>重启之后，show parameter spfile – 发现又按spfile启动了</p>
<h3 id="关闭数据库发生的事情">关闭数据库发生的事情</h3>
<p>1，关闭数据库，oracle将<strong>重做日志高速缓存</strong>中的内容写入重做日志文件，并且将<strong>数据库高速缓存</strong>中被改动过的数据写入数据文件，然后再关闭所有的数据文件和重做日志文件，这时数据库的控制文件仍然处于打开状态，但是由于数据库处于关闭状态，所以用户无法访问数据库</p>
<p>2，卸载数据库，关闭数据库后，例程才能被卸载，控制文件再这个时候被关闭，但例程仍然存在</p>
<p>3，终止例程，进程终止，分配给例程的内存sga区被回收。</p>
<h3 id="做服务名">做服务名</h3>
<p>如果想把db15c作为一个服务名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd $ORACLE_HOME&#x2F;network&#x2F;admin</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200326130527532-1586189129451.png" alt="image-20200326130527532"></p>
<p>tnsnames.ora文件用来存放==服务名==</p>
<p><img src="/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200326130607997-1586189129451.png" alt="image-20200326130607997"></p>
<p>用图形界面修改方法，Oracle外</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DISPLAY&#x3D;192.168.11.1:0.0</span><br><span class="line">netmgr</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP</li>
<li>主机名，如果电脑有多个ip地址，则最好不填主机名，解析容易出错。填ip</li>
<li>第一个网络服务名可以随便写，但后面的服务名 == Oracle数据库的服务名 == 全局数据库名</li>
<li>测试时密码记得修改成123123，他默认用的tiger</li>
<li>记得保存网络配置</li>
</ul>
<p><img src="/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200303170141238.png" alt="image-20200303170141238"></p>
<p><img src="/2020/03/17/Oracle/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200326131510091.png" alt="image-20200326131510091"></p>
<p>此时!tnsping db15c正常了</p>
<p>conn scott/123123@db15c也可以连上服务器了</p>
<h3 id="全局数据库名和SID">全局数据库名和SID</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,DB_UNIQUE_NAME <span class="keyword">from</span> v$<span class="keyword">database</span>; <span class="comment">-- name就是全局数据库名？？？</span></span><br></pre></td></tr></table></figure>
<p>全局数据库名用于区别<strong>分布式数据库</strong>各个不同机器上的实例， 用于外部区分</p>
<p>SID用于区别同一台机器上的不同实例，用于内部区分</p>
<p><strong>数据库域名</strong></p>
<p>在分布式数据库系统中，不同版本的数据库服务器之间，不论运行的操作系统是unix或是<a href="http://www.2cto.com/os/windows/" target="_blank" rel="noopener">windows</a>，各服务器之间都可以通过<a href="http://www.2cto.com/database/" target="_blank" rel="noopener">数据库</a>链路进行远程复制，数据库域名主要用于oracle<strong>分布式环境</strong>中的复制。举例说明如：</p>
<p>全国交通运政系统的分布式数据库，其中：</p>
<ul>
<li>福建节点：fj.jtyz</li>
<li>福建厦门节点：xm.fj.jtyz</li>
<li>江西：jx.jtyz</li>
<li>江西上饶：sr.jx.jtyz</li>
</ul>
<p>这就是数据库域名。</p>
<p>数据库域名在存在于参数文件中，他的参数是db_domain</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库域名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> v$parameter <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'db_domain'</span>;</span><br><span class="line"><span class="keyword">show</span> parameter <span class="keyword">domain</span></span><br></pre></td></tr></table></figure>
<p>全局数据库名</p>
<p>==全局数据库名 = 数据库名 + 数据库域名==，如前述福建节点的全局数据库名是：oradb.fj.jtyz</p>
<h3 id="alter-system-database-session">alter system / database / session</h3>
<p>看着那张结构图</p>
<ul>
<li>
<p>对instance（内存 + 进程）操作就是alter system</p>
<p>做检查点，进程属于instance，所以alter system</p>
</li>
<li>
<p>对数据库操作就是alter database</p>
<p>新建一个数据文件，所以alter database</p>
</li>
</ul>
<h3 id="nls">nls</h3>
<p>national language support</p>
<p>怎么查所有的nls参数（三个级别上）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nls_session_parameters;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nls_instance_parameters;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nls_database_parameters;</span><br></pre></td></tr></table></figure>
<h4 id="nls-date-format">nls_date_format</h4>
<p>修改的4种方式，alter system不允许？？？：<a href="https://blog.csdn.net/xie_xiansheng/article/details/50776226" target="_blank" rel="noopener">https://blog.csdn.net/xie_xiansheng/article/details/50776226</a></p>
<p>亲测这个可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim .bash_profile</span><br><span class="line">加一句alter session set nls_date_format &#x3D; &#39;yyyy-mm-dd hh24:mi:ss&#39;;</span><br><span class="line">重启</span><br></pre></td></tr></table></figure>
<p>1、查询nls_date_format</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nls_session_parameters <span class="keyword">where</span> parameter = <span class="string">'NLS_DATE_FORMAT'</span>;</span><br><span class="line"><span class="comment">--显示：NLS_DATE_FORMAT  DD-MON-RR</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nls_database_parameters <span class="keyword">where</span> parameter = <span class="string">'NLS_DATE_FORMAT'</span>;</span><br><span class="line"><span class="comment">--显示：NLS_DATE_FORMAT  DD-MON-RR</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nls_instance_parameters <span class="keyword">where</span> parameter = <span class="string">'NLS_DATE_FORMAT'</span>;</span><br><span class="line"><span class="comment">--显示：NLS_DATE_FORMAT  null （在我本地nls_instance_parameters中没有设置NLS_DATE_FORMAT）</span></span><br><span class="line"><span class="comment">-- alter system级别时，设置到这里了，但是会被session级别的覆盖</span></span><br></pre></td></tr></table></figure>
<p>2、设置nls_date_format</p>
<p>1)首先，介绍一下NLS参数相关的三个视图。</p>
<ol>
<li>NLS_SESSION_PARAMETERS</li>
<li>NLS_INSTANCE_PARAMETERS</li>
<li>NLS_DATABASE_PARAMTERS</li>
</ol>
<ul>
<li>NLS参数分session/ instance/ database三个级别</li>
<li>session级别覆盖instance级别，instance级别覆盖database级别（注意不是反的）。</li>
<li>就是说，如果session级别、instance级别和database级别都给某个参数赋值了，如nls_date_format参数，则先看session级别、如果session级别没有设定值，则看instance级别，以此类推。</li>
</ul>
<p>2)其次，设定nls_date_format的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session级别设定值：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_date_format = <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>;设定之后再查询会发现<span class="comment">-- nls_session_parameters视图中nls_date_format的值已经变了，而nls_instance_parameters、nls_database_parameters视图中的值没有变。</span></span><br><span class="line"><span class="comment">-- SESSION级别——如果只是希望自己看到某种格式而不影响其他人看到的结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- instance级别设定值：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> nls_date_format = <span class="string">'yyyy-mm-dd hh24:mi:ss'</span> <span class="keyword">scope</span>=<span class="keyword">spfile</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- database级别设定值：</span></span><br><span class="line"><span class="comment">-- oracle不允许设定此级别的参数值，也没有提供设定语句。</span></span><br></pre></td></tr></table></figure>
<p>3)然后，我们可以通过以下查询，发现本数据库是不允许instance级别和database级别参数值更改的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col name for a20</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, isses_modifiable, issys_modifiable, isinstance_modifiable <span class="keyword">from</span> v$parameter <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'nls_date_format'</span>;</span><br><span class="line"></span><br><span class="line">NAME                 ISSES_MODI ISSYS_MODIFIABLE   ISINSTANCE</span><br><span class="line"><span class="comment">-------------------- ---------- ------------------ ----------</span></span><br><span class="line">nls_date_format      TRUE       FALSE              FALSE</span><br></pre></td></tr></table></figure>
<h4 id="nls-territory">nls_territory</h4>
<p>改变当地地区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> nls_territory=america;</span><br></pre></td></tr></table></figure>
<p>￥变成了＄</p>
<h4 id="nls-language">nls_language</h4>
<h3 id="数据库和实例">数据库和实例</h3>
<p>数据库实例名是用于和操作系统进行联系的标识，就是说<strong>数据库和操作系统之间的交互用的是数据库实例名</strong></p>
<p>数据库名和实例名可以相同也可以不同。</p>
<p>在一般情况下，数据库名和实例名是一对一的关系</p>
<p>但如果在oracle并行服务器架构（即oracle实时应用<strong>集群</strong>）中，数据库名和实例名是一对多的关系。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询当前数据库实例名，两种方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> instance_name,<span class="keyword">status</span> <span class="keyword">from</span> v$<span class="keyword">instance</span>;</span><br><span class="line"><span class="keyword">show</span> parameter <span class="keyword">instance</span> <span class="comment">-- 出来好多</span></span><br></pre></td></tr></table></figure>
<!--more-->
<h3 id="数据库服务">数据库服务</h3>
<p>注册就是将数据库作为一个服务注册到监听程序。</p>
<p>客户端不需要知道数据库名和实例名，只需要知道该数据库对外提供的服务名就可以申请连接到数据库。</p>
<p>在数据库服务器和客户端之间有一监听程序（Listener）</p>
<p>在监听程序中，会记录相应数据库对应的服务名（一个数据库可能对应有多个服务名，一对一时，一般数据库名和服务名相同），当客户端需要连接数据库时，只需要提供服务名，就可以建立客户端和服务器之间的连接。</p>
<p>_connect_identifier，在tnsnames.ora中定义？？？</p>
<h3 id="大小写问题">大小写问题</h3>
<ul>
<li>
<p>关键字不区分大小写</p>
</li>
<li>
<p>建表时，表名和字段名不要加双引号，系统自动全部转为大写存储</p>
<p>不加引号查表时，不会区分大小写</p>
<p>加双引号查表时，双引号内的必须全部大写才能匹配到（双引号内的大小写保留？？？）</p>
</li>
<li>
<p>建表时加上双引号，系统不会处理，保留原样；查表时，就要双引号且严格符合大小写</p>
<p>特殊情况，如果建表时，某字段/表名双引号内全部大写，那么这个特定的字段/表名查询时不区分大小写，其余未全部大写的字段&amp;表名仍然区分大小写</p>
</li>
<li>
<p>表中数据：查询时区分大小写</p>
<p>注意一种特殊情况：查数据字典时，有的表明和字段名是作为数据存储在表中的，查询时就要区分大小写</p>
</li>
</ul>
<h3 id="回滚和闪回的区别">回滚和闪回的区别</h3>
<p>scott下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- flashback</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp; <span class="comment">-- 删除一个表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp; <span class="comment">-- table or view does not exist</span></span><br><span class="line">flashback table emp to before <span class="keyword">drop</span>; <span class="comment">-- 闪回这个表到删除之前flashback complete</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- rollback</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp; <span class="comment">-- 忘了加条件，删除了所有行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp; <span class="comment">-- no rows selected</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- rollback complete？？？</span></span><br></pre></td></tr></table></figure>
<p>回滚适用于DML，闪回操作一般对应于DDL</p>
<ul>
<li>
<p>闪回适用于<strong>逻辑错误</strong>：误删一张表、DDL</p>
</li>
<li>
<p>回滚适用于<strong>物理错误</strong>：磁盘损坏、数据文件被删除</p>
</li>
<li>
<p>flashback 原数据块保留：数据块出了问题直接拿过来备份【直接换一个新的备份手机】</p>
</li>
<li>
<p>rollback 使用对冲机制：delete之后想要回滚，要insert【修手机】</p>
<p>看起来什么都没干，但实际上做了两件相反的事</p>
<p>也就是说回滚INSERT对应产生了DELETE的日志信息</p>
</li>
</ul>
<h3 id="restore-recover区别">restore recover区别</h3>
<ul>
<li>restore还原，backup逆过程</li>
<li>recover == redo == 前滚，重新打开数据库就ok，用的是日志文件【用新的覆盖旧的】</li>
</ul>
<ol>
<li>备份时，将所有的数据文件（dbf文件）变成一个备份文件（bak文件）【压缩 - 解压缩】</li>
<li>还原时，将这一个bak文件还原成多个dbf文件</li>
</ol>
<h4 id="instance-recovery例程恢复">instance recovery例程恢复</h4>
<p>数据在内存中丢失，没有来得及写入磁盘</p>
<h4 id="media-recovery介质恢复">media recovery介质恢复</h4>
<p>数据在介质文件中丢失</p>
<h3 id="数据文件的扩展">数据文件的扩展</h3>
<p>备份文件越来越大，数据放在数据文件中，数据文件不够大</p>
<p>两者矛盾：性能开销（dba和db的开销成反比，人不做的事情交给机器）</p>
<h4 id="自动扩展">自动扩展</h4>
<p>使用情形：数据库目前运行流畅</p>
<p>开发人员设计后台进程，跟踪数据文件的使用情况，指定一个临界值（10%），此时触发自动扩展</p>
<h4 id="手动扩展">手动扩展</h4>
<p>适用情形：卡顿严重，性能不行的时候，需要手动优化</p>
<p>ban掉自动扩展，管理员手册中加一条：每天手动监控数据文件使用情况，手动敲命令扩展，不是监控</p>
<h3 id="自学）实例恢复">自学）实例恢复</h3>
<p><a href="http://blog.itpub.net/29863023/viewspace-2652139/" target="_blank" rel="noopener">http://blog.itpub.net/29863023/viewspace-2652139/</a></p>
<p>update事务为例</p>
<h4 id="1-sql语句解析">1.sql语句解析</h4>
<p>首先会经过在share pool中的sql语句的解析过程，这一过程只要是针对sql语法，执行计划这些进行处理，这一部分不细讲</p>
<h4 id="2-将数据块读入数据库高速缓存中">2.将数据块读入数据库高速缓存中</h4>
<p>接着，到了sql执行后，数据库从物理文件读出数据行相应的数据块到 buffer cache中（假设此时内存不存在相应的数据块同时不讨论锁的过程），这一过程也涉及到数据块写到dirty list，并写脏块，为新读取的数据块寻找空闲空间的过程 。</p>
<h4 id="3-保留一份修改前的数据块映像">3.保留一份修改前的数据块映像</h4>
<p>同时会分配回滚段并在undo段再保留一份修改前的数据块映像。</p>
<h4 id="4-写入重做日志缓存">4.写入重做日志缓存</h4>
<p>为事务修改数据块，并在执行更改完成后，针对此数据块的修改也生成redo信息。这里是将该语句所影响的并被读入db buffer中的这些行数据的rowid及要更新的原值和新值及scn等信息从PGA逐条的写入redo log buffer中</p>
<h4 id="5-执行commit命令">5.执行commit命令</h4>
<p>声明redo log buffer 中的redo处于commit状态，然后修改事务表相应slot，声明事务已提交，最后通知lgwr进程将redo log buffer中的数据写入redo log file。待lgwr进程通知已经写入完成后，向用户发出commit完成的信息</p>
<h3 id="三个后台进程">三个后台进程</h3>
<p>CKPT：检查点进程（Checkpoint Process）只是更新数据文件的文件首部，以辅助建立检查点的进程</p>
<p>什么时候发生normal checkpoint</p>
<p>下面这些操作将会触发checkpoint事件：</p>
<ul>
<li>日志切换，通过ALTER SYSTEM SWITCH LOGFILE。</li>
<li>DBA发出checkpoint命令，通过ALTER SYSTEM checkpoint。</li>
<li>对数据文件进行热备时，针对该数据文件的checkpoint也会进行，ALTER TABLESPACE TS_NAME BEGIN BACKUP/END BACKUP。</li>
<li>当运行ALTER TABLESPACE/DATAFILE READ ONLY的时候。</li>
<li>SHUTDOWN命令发出时。</li>
</ul>
<p>因为每次完全的checkpoint都需要把buffer cache所有的脏块都写入到数据文件中，这样就是产生一个很大的IO消耗，频繁的完全checkpoint操作很对系统的性能有很大的影响，为此Oracle引入的增量checkpoint的概念，buffer cache中的脏块将会按照BCQ队列的顺序持续不断的被写入到磁盘当中，同时CKPT进程将会每3秒中检查DBWn的写入进度并将相应的RBA信息记录到控制文件中。</p>
<p>有了增量checkpoint之后在进行实例恢复的时候就不需要再从崩溃前的那个完全checkpoint开始应用重做日志了，只需要从控制文件中记录的RBA开始进行恢复操作，这样能节省恢复的时间。</p>
<p>发生增量checkpoint的先决条件</p>
<ul>
<li>恢复需求设定 （FAST_START_IO_TARGET/FAST_START_MTTR_TARGET）</li>
<li>LOG_checkpoint_INTERVAL参数值</li>
<li>LOG_checkpoint_TIMEOUT参数值</li>
<li>最小的日志文件大小</li>
<li>buffer cache中的脏块的数量</li>
</ul>
<p>DBWn：数据库块写入器（Database Block Writer）负责将脏块写入磁盘的后台进程。</p>
<p>触发DBWR进程的条件有：</p>
<ul>
<li>DBWR超时，大约3秒</li>
<li>系统中没有多余的空缓冲区来存放数据</li>
<li>CKPT 进程触发DBWR</li>
<li>free buffer waits 40% 触发 dbwr吧lruw脏块写入磁盘</li>
<li>关机会触发dbwr写</li>
<li>alter system checkpoint 触发dbwr写</li>
<li>redo 日志切换 触发dbwr写</li>
<li>表空间 offline /online 触发dbwr写</li>
</ul>
<p>DBWR作为一个后台进程，只有在某些条件满足了才会触发。这些条件包括：</p>
<ol>
<li>
<p>当进程在辅助LRU链表和主LRU链表上扫描以查找可以覆盖的buffer header时，如果已经扫描的buffer header的数量到达一定的限度（由隐藏参数：_db_block_max_scan_pct决定）时，触发DBWR进程。_db_block_max_scan_pct表示已经扫描的buffer header的个数占整个LRU链表上buffer header总数的百分比。这时，搜索可用buffer header的进程挂起，在v$session_wait中表现为等待“free buffer wait”事件，同时增加v$sysstat中的“dirty buffers inspected”的值。</p>
</li>
<li>
<p>当DBWR在主LRUW链表上查找已经更新完而正在等待被写入数据文件的buffer header时，如果找到的buffer header的数量超过一定限度（由隐藏参数：_db_writer_scan_depth_pct决定）时，DBWR就不再继续往下扫描了，而转到辅助LRUW链表上将其上的脏数据块写入数据文件。_db_writer_scan_depth_pct表示已经扫描的脏数据块的个数占整个主LRUW链表上buffer header总数的百分比。</p>
</li>
<li>
<p>如果主LRUW链表和辅助LRUW链表上的脏数据块的总数超过一定限度，也将触发DBWR进程。该限度由隐藏参数：_db_large_dirty_queue决定。</p>
</li>
<li>
<p>发生增量检查点（incremental checkpoint）或完全检查点（complete checkpoint）时触发DBWR。</p>
</li>
<li>
<p>每隔三秒钟启动一次DBWR。</p>
</li>
<li>
<p>将表空间设置为离线（offline）状态时触发DBWR。</p>
</li>
<li>
<p>发出命令：alter tablespace … begin backup，从而将表空间设置为热备份状态时触发DBWR。</p>
</li>
<li>
<p>将表空间设置为只读状态时，触发DBWR。</p>
</li>
<li>
<p>删除对象时（比如删除某个表）会触发DBWR。</p>
</li>
</ol>
<p>LGWR：日志写入器（Log Writer）负责将SGA中重做日志缓冲区的内容刷新输出到磁盘。</p>
<p>触发LGWn工作的时点有几个：</p>
<ol>
<li>用户提交 ，commit时必须写LOGFILE.</li>
<li>有1/3重做日志缓冲区未被写入磁盘</li>
<li>有大于1M的重做日志缓冲区未被写入磁盘</li>
<li>3秒超时</li>
<li>DBWR 需要写入的数据的SCN大于LGWR记录的SCN，DBWR 触发LGWR写入。</li>
</ol>
<p>这三个进程都是为了更好地完成一件事：<strong>安全高效地实现内存数据块写入数据文件</strong>，就是将内存中修改的数据反映到硬盘的数据文件上。 我在事务未提交时做一个刷新buffer cache，此时发现数据块已经被刷新到磁盘文件中，通过以上三个进程的触发条件也可以看出刷新数据块与事务是否提交关系不大。</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>latex文献引用</title>
    <url>/2020/07/14/Research/latex%E6%96%87%E7%8C%AE%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>参考文献可以在文中显示，或者在文章结束显示</p>
<h4 id="写在前面">写在前面</h4>
<p>latex编写软件：TexMaker</p>
<p>他有个很方便的功能：快速构建，但需要配置好</p>
<p><img src="/2020/07/14/Research/latex%E6%96%87%E7%8C%AE%E5%BC%95%E7%94%A8/image-20210714204327561.png" alt="image-20210714204327561"></p>
<p>配置成这样才能正常使用文献引用的功能~</p>
<a id="more"></a>
<h4 id="case1-文中">case1 文中</h4>
<p>这种用的不是很多，只是在周报这些地方用下。</p>
<p>直接上例子：</p>
<p><img src="/2020/07/14/Research/latex%E6%96%87%E7%8C%AE%E5%BC%95%E7%94%A8/image-20210714204432277.png" alt="image-20210714204432277"></p>
<p>这是代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% !Mode:: &quot;TeX:UTF-8&quot;</span><br><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[UTF8]&#123;ctex&#125;</span><br><span class="line">\usepackage&#123;titlesec&#125;</span><br><span class="line">\usepackage[margin&#x3D;1.2in]&#123;geometry&#125;</span><br><span class="line">\usepackage[toc,page]&#123;appendix&#125;</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\usepackage&#123;float&#125;</span><br><span class="line">\usepackage&#123;subfigure&#125;</span><br><span class="line">\usepackage[subfigure]&#123;tocloft&#125;</span><br><span class="line">\usepackage[square,numbers]&#123;natbib&#125;</span><br><span class="line">\usepackage&#123;lipsum&#125;</span><br><span class="line">\usepackage&#123;caption&#125;</span><br><span class="line">\usepackage&#123;pdfpages&#125;</span><br><span class="line">\usepackage[colorlinks,linkcolor&#x3D;red]&#123;hyperref&#125;</span><br><span class="line">\usepackage&#123;bibentry&#125;</span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;multirow&#125;</span><br><span class="line">\usepackage&#123;CJKulem&#125;</span><br><span class="line">\usepackage&#123;booktabs&#125;</span><br><span class="line">\usepackage&#123;color&#125;</span><br><span class="line">\usepackage&#123;url&#125;</span><br><span class="line">\usepackage&#123;microtype&#125;</span><br><span class="line">% 加了microtype之后没有badbox的warning了</span><br><span class="line">\nobibliography*</span><br><span class="line">% 这里是重点，必须no才能不在文末显示</span><br><span class="line"></span><br><span class="line">\newcommand\listexamplename&#123;周报目录&#125;</span><br><span class="line">\newlistof&#123;exam&#125;&#123;ex&#125;&#123;\listexamplename&#125;</span><br><span class="line">\newenvironment&#123;weekReport&#125;&#123;</span><br><span class="line"> 		\refstepcounter&#123;exam&#125;</span><br><span class="line">&#125;&#123;\par&#125;</span><br><span class="line">\newcommand&#123;\exam&#125;[1]&#123;%</span><br><span class="line">\addcontentsline&#123;ex&#125;&#123;exam&#125;&#123;\protect\numberline&#123;\theexam&#125;#1&#125;\par</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">\listofexam</span><br><span class="line">\thispagestyle&#123;empty&#125;</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">\newpage</span><br><span class="line">\pagenumbering&#123;arabic&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">\Large \bfseries  计划表</span><br><span class="line"></span><br><span class="line">% Table generated by Excel2LaTeX from sheet &#39;Sheet1&#39;</span><br><span class="line">\begin&#123;table&#125;[htbp]</span><br><span class="line">  \centering</span><br><span class="line">    \begin&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line">		\hline</span><br><span class="line">		阶段 &amp; 安排 &amp; 任务进度   \\ \hline</span><br><span class="line">		\multirow&#123;1&#125;&#123;*&#125;&#123;03月01日-03月07日&#125;</span><br><span class="line">		&amp; 写一篇博客 &amp; 完成 \\ \cline&#123;2-3&#125;</span><br><span class="line">		</span><br><span class="line">		\hline</span><br><span class="line">		\multirow&#123;1&#125;&#123;*&#125;&#123;03月08日-03月15日&#125;</span><br><span class="line">		&amp; eat &amp; 完成 \\ \cline&#123;2-3&#125;</span><br><span class="line">		&amp; sleep &amp; 完成 \\ \cline&#123;2-3&#125;</span><br><span class="line">		&amp; CODE！！  &amp; 完成 \\ \cline&#123;2-3&#125;</span><br><span class="line">		</span><br><span class="line">		\hline</span><br><span class="line">    \end&#123;tabular&#125;%</span><br><span class="line">  \label&#123;tab:addlabel&#125;%</span><br><span class="line">\end&#123;table&#125;%</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">\clearpage</span><br><span class="line"></span><br><span class="line">% ------------------------- 第二十周 -------------------------</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">    \Large 2020-2021学年 春</span><br><span class="line">    \begin&#123;weekReport&#125;\exam&#123;2020-2021学年·春·第20周（7月12日-7月18日）&#125;</span><br><span class="line">    \Large \bfseries 第20周（7月12日-7月18日）</span><br><span class="line">    \end&#123;weekReport&#125;</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line"></span><br><span class="line">    \setcounter&#123;section&#125;&#123;0&#125;</span><br><span class="line">    \setcounter&#123;figure&#125;&#123;0&#125;</span><br><span class="line">    \setcounter&#123;subfigure&#125;&#123;0&#125;</span><br><span class="line"></span><br><span class="line">    \section&#123;总体情况&#125;</span><br><span class="line">    \begin&#123;itemize&#125;</span><br><span class="line">    \item 对博弈模型展开表示，并用latex编写；</span><br><span class="line">    \item 对代码进行重构；</span><br><span class="line">    \item 将EPEC博士论文中的方法，映射到本模型；</span><br><span class="line">    \item 得到求近似解的方法；</span><br><span class="line">    \item 学习求解器使用方法，将该求近似解的方法使用python实现；</span><br><span class="line">    \end&#123;itemize&#125;</span><br><span class="line"></span><br><span class="line">    \section&#123;论文阅读&#125;</span><br><span class="line">    \begin&#123;itemize&#125;</span><br><span class="line">    \item \bibentry&#123;2005Equilibrium&#125;</span><br><span class="line">    \end&#123;itemize&#125;</span><br><span class="line">	</span><br><span class="line">    \section&#123;代码编写&#125;</span><br><span class="line">    \begin&#123;itemize&#125;</span><br><span class="line">    \item 对代码进行重构，修改充电桩数量时，不必改动多处，仅需在config中修改即可</span><br><span class="line">    \end&#123;itemize&#125;</span><br><span class="line"></span><br><span class="line">    \section&#123;下阶段安排&#125;</span><br><span class="line">    暂无</span><br><span class="line"></span><br><span class="line">    \section&#123;存在困难&#125;</span><br><span class="line">    暂无</span><br><span class="line"></span><br><span class="line">    \section&#123;具体内容&#125;</span><br><span class="line">    \begin&#123;itemize&#125;</span><br><span class="line">    \item 前面的区域，以后再来探索吧QAQ</span><br><span class="line">    \end&#123;itemize&#125;</span><br><span class="line">\clearpage</span><br><span class="line"></span><br><span class="line">% 设置参考文献格式</span><br><span class="line">\bibliographystyle&#123;IEEETran&#125;</span><br><span class="line">% 这里是重点，必须no才能不在文末显示</span><br><span class="line">\nobibliography&#123;references&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bib文件">bib文件</h4>
<p>新建一个bib后缀的文件（如reference.bib），放在和tex文件同级目录</p>
<p>ps：不知道为什么，从dblp上复制的BibTex就会报错（xx ended before xxx），从谷歌学术那边的就不会</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 第二十周</span></span><br><span class="line">@phdthesis&#123;2005Equilibrium,</span><br><span class="line">  title=&#123;Equilibrium problems with equilibrium constraints: stationarities, algorithms, and applications&#125;,</span><br><span class="line">  author=&#123; Su, C. L. &#125;,</span><br><span class="line">  school=&#123;Stanford University.&#125;,</span><br><span class="line">  year=&#123;2005&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第五周</span></span><br><span class="line">@article&#123;zhao2020go,</span><br><span class="line">  title=&#123;Where to go next: A spatio-temporal gated network for next poi recommendation&#125;,</span><br><span class="line">  author=&#123;Zhao, Pengpeng and Luo, Anjing and Liu, Yanchi and Zhuang, Fuzhen and Xu, Jiajie and Li, Zhixu and Sheng, Victor S and Zhou, Xiaofang&#125;,</span><br><span class="line">  journal=&#123;IEEE Transactions on Knowledge and Data Engineering&#125;,</span><br><span class="line">  year=&#123;2020&#125;,</span><br><span class="line">  publisher=&#123;IEEE&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第四周</span></span><br><span class="line">@inproceedings&#123;wu2020joint,</span><br><span class="line">  title=&#123;Joint item recommendation and attribute inference: An adaptive graph convolutional network approach&#125;,</span><br><span class="line">  author=&#123;Wu, Le and Yang, Yonghui and Zhang, Kun and Hong, Richang and Fu, Yanjie and Wang, Meng&#125;,</span><br><span class="line">  booktitle=&#123;Proceedings of the 43rd International ACM SIGIR Conference on Research and Development in Information Retrieval&#125;,</span><br><span class="line">  pages=&#123;679--688&#125;,</span><br><span class="line">  year=&#123;2020&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="case2-文末">case2 文末</h4>
<p>还没研究。不过这种引用比较正常，用的人也很多，网上也有很多教程。</p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm Deployment使用方法</title>
    <url>/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="功能">功能</h2>
<ul>
<li>文件同步：本地PC一个路径下的项目，和服务器上一个路径下的项目</li>
<li>代码放在服务器跑：配置好后，用户感知不到服务器的存在，在本地PC上正常运行、调试</li>
</ul>
<a id="more"></a>
<h2 id="配置方法">配置方法</h2>
<h4 id="Step-1-新建一个部署">Step 1 新建一个部署</h4>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328151353704-16484516365891.png" alt="image-20220328151353704">
<p>选SFTP，输入服务器名（仅用于标识）</p>
<h4 id="Step-2-配置Connection、Mappings">Step 2 配置Connection、Mappings</h4>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328151811645.png" alt="image-20220328151811645">
<ul>
<li>下拉框添加SSH的配置。如果没有就在【…】新建一个</li>
<li>Test Connection</li>
<li>Local path：本地项目绝对路径。是默认配置好的</li>
<li>Root Path：服务器根目录。注意<strong>不是项目目录</strong>，一般填项目目录的上一级（存放多个项目的路径）</li>
<li>Root path和Mapping里的Deployment path，拼成项目在服务器端完整的<strong>绝对路径</strong></li>
</ul>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328153350663.png" alt="image-20220328153350663">
<h4 id="Step-3-为项目配置interpreter">Step 3 为项目配置interpreter</h4>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328153821269.png" alt="image-20220328153821269">
<p>Python Interpreter - Show All</p>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328154308311.png" alt="image-20220328154308311">
<p>添加好之后，需要配置一下Mapping（不太懂为啥这里还要再配置一次</p>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328154455013.png" alt="image-20220328154455013">
<ul>
<li>修改Interpreter的路径为服务器已经配置好的Conda环境</li>
<li>记得修改Sync folders：不然会在服务器上新建一个临时文件夹放工程</li>
</ul>
<h4 id="Step-4-其他配置">Step 4 其他配置</h4>
<p>给Deployment一个快捷键会方便很多</p>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328153459883.png" alt="image-20220328153459883">
<p>设置同步（本地变化自动同步服务器）</p>
<img src="/2022/03/28/Python/Pycharm%20Deployment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20220328153055295.png" alt="image-20220328153055295">
<h2 id="使用方法">使用方法</h2>
<p>正常使用</p>
<p>除了服务器那边生成的文件（例如训练好的模型）需要手动同步回本地PC？</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip、Conda、Anaconda</title>
    <url>/2020/07/14/Research/pip%E3%80%81conda%E3%80%81anaconda/</url>
    <content><![CDATA[<h2 id="pip">pip</h2>
<h2 id="Anaconda">Anaconda</h2>
<ul>
<li>软件</li>
<li>Anaconda == conda + 各种包</li>
</ul>
<h2 id="Conda">Conda</h2>
<p>用来管理环境的包（既是一个包，又是环境管理用具）</p>
<h3 id="写在前面">写在前面</h3>
<ul>
<li>用管理者模式打开命令行</li>
<li>否则就给权限：右键属性 - 安全 - Users的都勾上允许</li>
</ul>
<h3 id="环境变量">环境变量</h3>
<p>win下，用set命令即可看到所有环境变量</p>
<p>用conda prompt就不用配了？</p>
<p>所有命令的帮助，可以用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda [命令] -h</span><br></pre></td></tr></table></figure>
<h3 id="下载源相关">下载源相关</h3>
<p>命令行、用户根目录下的.condarc文件、Anaconda Navigator均可查看和更改</p>
<h4 id="查看下载源">查看下载源</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --show channels</span><br></pre></td></tr></table></figure>
<p>用来生成.condarc文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<h4 id="添加下载源">添加下载源</h4>
<p>==记得把-default删掉！==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;conda-forge</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;msys2&#x2F;</span><br></pre></td></tr></table></figure>
<p>add是添加到最上面。当有多个源时，也可以用这条语句来调整位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(base) C:\Users\zhx&gt;conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;msys2&#x2F;</span><br><span class="line">Warning: &#39;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;msys2&#x2F;&#39; already in &#39;channels&#39; list, moving to the top</span><br></pre></td></tr></table></figure>
<p>清除索引缓存，保证用的是镜像站提供的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda clean -i</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(base) C:\Users\zhx&gt;conda clean -i</span><br><span class="line">Will remove 1 index cache(s).</span><br><span class="line">Proceed ([y]&#x2F;n)? y</span><br></pre></td></tr></table></figure>
<p>Clean命令：<a href="https://blog.csdn.net/qq_16184125/article/details/108371581" target="_blank" rel="noopener">https://blog.csdn.net/qq_16184125/article/details/108371581</a></p>
<h3 id="环境相关">环境相关</h3>
<p>自定义环境的安装路径：<a href="https://blog.csdn.net/XC___XC/article/details/134013893" target="_blank" rel="noopener">https://blog.csdn.net/XC___XC/article/details/134013893</a></p>
<p>讲路径：<a href="https://blog.csdn.net/weixin_43970786/article/details/129364905" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43970786/article/details/129364905</a></p>
<h4 id="查看环境的配置">查看环境的配置</h4>
<p>envs_dirs即为环境所在的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda info</span><br><span class="line">conda config --show</span><br></pre></td></tr></table></figure>
<h4 id="更改环境所在的路径">更改环境所在的路径</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add envs_dirs [路径名]</span><br><span class="line">conda config --remove envs_dirs [路径名]</span><br></pre></td></tr></table></figure>
<p>同理，add已经有的路径，会将其置顶</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">envs_dirs:</span><br><span class="line">C:\Users\zhx\.conda\envs</span><br><span class="line">C:\Users\zhx\AppData\Local\conda\conda\envs  # 实际上没有</span><br><span class="line"></span><br><span class="line">pkgs_dirs:</span><br><span class="line">C:\Users\zhx\.conda\pkgs</span><br><span class="line">C:\Users\zhx\AppData\Local\conda\conda\pkgs  # 实际上没有</span><br></pre></td></tr></table></figure>
<p>这几个都remove掉？注意：remove只能删除自己添加的路径，系统默认的就会报错</p>
<h4 id="查看有哪些环境">查看有哪些环境</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<h4 id="创建新环境">创建新环境</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n [环境名] python&#x3D;[版本号]</span><br><span class="line">conda create -n py396 python&#x3D;3.9.6</span><br><span class="line">不好用，因为没有名字，每次都得用这个路径表示环境</span><br><span class="line">conda create -n py396 --prefix&#x3D;[指定的路径名（最后一级为环境名）] python&#x3D;3.9.6</span><br></pre></td></tr></table></figure>
<p>记得用管理员打开，用户模式安装不到自定义的路径（比如说C:\Softwares\anaconda3\envs\py396）</p>
<p>非要在用户模式下，则需要更改Users对C:\Softwares\anaconda3\的权限</p>
<h4 id="激活环境">激活环境</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda activate [环境名]</span><br></pre></td></tr></table></figure>
<p>环境退回到base</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<h4 id="删除环境">删除环境</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove -n [环境名] --all</span><br><span class="line">？ conda env remove -n noti  # 删除指定环境</span><br></pre></td></tr></table></figure>
<p>删除指定环境中安装的所有包以及该环境的所有信息和文件，-y 选项不会询问确认信息</p>
<p>但是删不了pkgs里的东西？</p>
<h3 id="包相关">包相关</h3>
<h4 id="查看有哪些包">查看有哪些包</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
<h4 id="查看包的安装位置">查看包的安装位置</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda show [包名]</span><br></pre></td></tr></table></figure>
<ul>
<li>envs\虚拟环境\Lib\site-packages</li>
<li>envs\虚拟环境\pkgs</li>
<li>这两个位置的包有什么区别？</li>
</ul>
<h4 id="安装包">安装包</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install [包名]</span><br></pre></td></tr></table></figure>
<p>安装本地包，需要进入whl文件的路径，然后用pip安装，不能用conda</p>
<h4 id="删除包">删除包</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove -n [环境名] [包名]</span><br></pre></td></tr></table></figure>
<h2 id="概念">概念</h2>
<p><a href="https://blog.csdn.net/weixin_58283091/article/details/133349022" target="_blank" rel="noopener">https://blog.csdn.net/weixin_58283091/article/details/133349022</a></p>
<p>显卡驱动 → CUDA → CUDA Toolkit → cuDNN → Pytorch</p>
<p>即显卡（驱动）决定了CUDA版本，CUDA版本决定了CUDA Toolkit、cuDNN、Pytorch、torch-vision各自的版本</p>
<p><a href="https://zhuanlan.zhihu.com/p/669089641" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/669089641</a></p>
<ol>
<li>CUDA：并行计算的基础架构</li>
<li>CUDA Toolkit：用于CUDA开发的软件包</li>
<li>cuDNN（CUDA Deep Neural Network library）：用于深度学习的GPU加速库</li>
<li>Pytorch：机器学习框架</li>
</ol>
<h3 id="查看版本">查看版本</h3>
<p><strong>驱动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<ul>
<li>Driver Version: 546.33</li>
<li>CUDA Version: 12.3（本机最高支持的CUDA版本）</li>
</ul>
<p><strong>CUDA</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<p>其余都是python包</p>
<p><strong>cuDNN</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\include\cudnn.h</span><br><span class="line"></span><br><span class="line"># DEFINE CUDNN_MAJOR之类的就是版本号</span><br></pre></td></tr></table></figure>
<p>使用 PyTorch 查看 CUDA 和 cuDNN 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.__version__)</span><br><span class="line"></span><br><span class="line">print(torch.version.cuda)</span><br><span class="line">print(torch.backends.cudnn.version())</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/wuliytTaotao/p/11453265.html#%E6%9F%A5%E7%9C%8B-cudnn-%E7%89%88%E6%9C%AC-1" target="_blank" rel="noopener">https://www.cnblogs.com/wuliytTaotao/p/11453265.html#查看-cudnn-版本-1</a></p>
<h3 id="版本对应关系">版本对应关系</h3>
<p>pytorch和以及cuda对应表</p>
<p><a href="https://blog.csdn.net/FL1768317420/article/details/134769203" target="_blank" rel="noopener">https://blog.csdn.net/FL1768317420/article/details/134769203</a></p>
<p><a href="https://blog.csdn.net/shiwanghualuo/article/details/122860521" target="_blank" rel="noopener">https://blog.csdn.net/shiwanghualuo/article/details/122860521</a></p>
<p>很好的安装教程：<a href="https://blog.csdn.net/2302_76726543/article/details/134722054" target="_blank" rel="noopener">https://blog.csdn.net/2302_76726543/article/details/134722054</a></p>
<h2 id="CUDA安装">CUDA安装</h2>
<p>win11只能装11.6之上的版本，更低版本那会win11还没出（</p>
<p>如果版本安装错了要卸载：把以下东西都卸掉，CUDA文件夹下V11.6文件夹删除就好</p>
<p><img src="/2020/07/14/Research/pip%E3%80%81conda%E3%80%81anaconda/image-20240123210101750.png" alt="image-20240123210101750"></p>
<p>不行的话尝试：<a href="https://www.zhihu.com/tardis/bd/art/609847842?source_id=1001" target="_blank" rel="noopener">https://www.zhihu.com/tardis/bd/art/609847842?source_id=1001</a></p>
<h2 id="cuDNN安装">cuDNN安装</h2>
<p>要自己注册英伟达账户 才能下载</p>
<p>从官网https://developer.nvidia.com/rdp/cudnn-archive，下载对应版本的cudnn</p>
<p>解压后，把里面cudnn中的include，lib，bin文件夹里面的所有文件分别复制到</p>
<p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6文件 对应的include，lib，bin文件里面</p>
<h2 id="百度OCR">百度OCR</h2>
<p>保证已经安装了CUDA和cuDDN</p>
<p>并且手动安装了正确版本的pytorch和torchvision，否则会报错，后缀要有+cu113之类的才是gpu版本</p>
<h3 id="Step-1：安装paddlepaddle">Step 1：安装paddlepaddle</h3>
<p><a href="https://www.paddlepaddle.org.cn/" target="_blank" rel="noopener">https://www.paddlepaddle.org.cn/</a></p>
<p><img src="/2020/07/14/Research/pip%E3%80%81conda%E3%80%81anaconda/image-20240123203337690.png" alt="image-20240123203337690"></p>
<p>记得选对CUDA版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install paddlepaddle-gpu&#x3D;&#x3D;2.6.0 cudatoolkit&#x3D;11.6 -c https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;Paddle&#x2F; -c conda-forge</span><br></pre></td></tr></table></figure>
<p>这条命令顺便安装CUDA Toolkit和cuDNN</p>
<h3 id="Step-2：安装Shapely">Step 2：安装Shapely</h3>
<p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#shapely" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#shapely</a></p>
<p><img src="/2020/07/14/Research/pip%E3%80%81conda%E3%80%81anaconda/image-20240123204510643.png" alt="image-20240123204510643"></p>
<p>找好对应python版本的包，进到whl所在的目录，本地安装</p>
<p>这里也是只能用pip，不能用conda，为什么？</p>
<h3 id="Step-3：安装PaddleOCR">Step 3：安装PaddleOCR</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install paddleocr</span><br></pre></td></tr></table></figure>
<p>不知道为啥conda安不上，pip可以</p>
<h3 id="报错记录">报错记录</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The GPU architecture in your current machine is Ampere, which is not compatiable</span><br></pre></td></tr></table></figure>
<p>CUDA版本太旧（20系是Turing，30 40都是Ampere）</p>
<p>解决方法：整套重新装</p>
<p><img src="/2020/07/14/Research/pip%E3%80%81conda%E3%80%81anaconda/image-20240123213114949.png" alt="image-20240123213114949"></p>
<p>这不对</p>
<p><img src="/2020/07/14/Research/pip%E3%80%81conda%E3%80%81anaconda/image-20240123213127001.png" alt="image-20240123213127001"></p>
<p>这才对</p>
<p>运行起来可能会报各种ModuleNotFoundError，比如decorator、idna</p>
<p>解决方法：用本地安装的paddlepaddle-gpu有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InvalidMatchSpec: Invalid spec &#39;paddlepaddle-gpu[url&#x3D;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;zhx&#x2F;Py</span><br></pre></td></tr></table></figure>
<p>decorator手动装上不报错，但idna本身在conda list里，还报错。所以remove掉重装</p>
<p>后面还报了两个包：urllib3.exception和You need either charset normalizer or chardet installed</p>
<p>remove掉urllib3的时候，自动帮忙把exception补全了？？</p>
<p>手动装了chardet，成功运行！</p>
<p>但还是报了个错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: &#39;&lt;&#39; not supported between instances of &#39;tuple&#39; and &#39;float&#39;</span><br></pre></td></tr></table></figure>
<p>示例代码太旧的原因，在新版本PaddleOCR上运行会报错</p>
<p><a href="https://blog.csdn.net/Blackrosetian/article/details/130386122" target="_blank" rel="noopener">https://blog.csdn.net/Blackrosetian/article/details/130386122</a></p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>pip</tag>
        <tag>Conda</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow安装</title>
    <url>/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/</url>
    <content><![CDATA[<h2 id="1-python3-7">1. python3.7</h2>
<p>下载并安装python3.7版本的anaconda</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.anaconda.com&#x2F;distribution&#x2F;</span><br></pre></td></tr></table></figure>
<img src="/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/image-20200313234202516.png" alt="image-20200313234202516" style="zoom:67%;">
<a id="more"></a>
<img src="/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/image-20200313235925634.png" alt="image-20200313235925634" style="zoom:67%;">
<p>都选上？为啥第一个不选？为啥新版本没有上面这个了？</p>
<p>Anaconda指的是一个<strong>开源的Python发行版本</strong>，其包含了conda、Python等180多个科学包及其依赖项，</p>
<p>完整版内部有很多包（numpy</p>
<h4 id="注意配环境变量">注意配环境变量</h4>
<p><img src="/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/image-20200313233929663.png" alt="image-20200313233929663"></p>
<p>anaconda注意有3条环境变量</p>
<p>配环境变量的目的，为了在任何路径下都能打开xx.exe？？？</p>
<p>输入conda --version，出现版本号说明安装成功</p>
<h2 id="2-tensorflow">2. tensorflow</h2>
<p>tensorflow各种版本的下载，注意版本（我用的1.15.0）</p>
<p>最好离线下载，直接pip install慢到怀疑人生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;xisan505&#x2F;article&#x2F;details&#x2F;90438484</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;tensorflow-gpu&#x2F; </span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;tensorflow&#x2F;#files</span><br></pre></td></tr></table></figure>
<p>在anaconda中？？？多个python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install 上面的whl  some-package -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>
<p>后缀是为了加快支持包的下载，使用国内源</p>
<p>注意whl文件的路径，要不cd进去装，要不用绝对路径</p>
<p>卸载包 pip uninstall</p>
<p>查看当前包 pip list / conda list</p>
<h4 id="bug">bug</h4>
<ul>
<li>
<p>ImportError: DLL load failed</p>
<p>缺少一些dll时，说明tf和coda的版本不符</p>
</li>
<li>
<p>Could not load dynamic library ‘cudnn64_7.dll’; dlerror: cudnn64_7.dll</p>
<p>没有装cudnn</p>
</li>
<li>
<p>AttributeError: module ‘tensorflow’ has no attribute ‘placeholder’</p>
<p>1.0版本和2.0版本之间的问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior() <span class="comment"># 有时候不需要这一行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-cuda-10-0">3. cuda 10.0</h2>
<p>查看电脑显卡（最高？？？）支持哪个版本的cuda</p>
<p>英伟达控制面板 - 帮助 - 系统信息 - 组件 - 3D设置</p>
<p><img src="/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/image-20200314000500523.png" alt="image-20200314000500523"></p>
<p>测试看看是否安装成功：</p>
<p>在cmd中输入：nvcc -V，出现版本号说明成功</p>
<p>在python（命令行即可，进入有tf的python环境，别进错了）中运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.__version__</span><br><span class="line"><span class="comment"># tf.__path__ # 查询tensorflow安装路径为:</span></span><br></pre></td></tr></table></figure>
<h4 id="bug-2">bug</h4>
<p>出现 ImportError  或者Could not load dynamic library ，说明cuda和tf版本不符</p>
<p>一般CUDA安装失败都是由于其中Visual Studio(VS) Intergration无法安装导致的，和原有的冲突</p>
<p>自定义安装，取消这一项即可</p>
<p><img src="/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/image-20200314000615976.png" alt="image-20200314000615976"></p>
<h2 id="4-cudnn">4. cudnn</h2>
<p>装好之后，将cudnn中解压出来的东西分别拷贝到cuda对应文件夹中（管理员权限</p>
<p>cuda 10.0</p>
<p><img src="/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/image-20200313234722211.png" alt="image-20200313234722211"></p>
<p>cudnn（虽然解压出来的文件夹也叫cuda？？？）</p>
<p><img src="/2019/10/28/Research/%E9%85%8D%E7%BD%AEtensorflow/image-20200313234753718.png" alt="image-20200313234753718"></p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
</search>
